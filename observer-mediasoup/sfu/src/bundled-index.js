(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],2:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Accumulator = void 0;
const schemas_1 = require("@observertc/schemas");
const supplyDefaultConfig = () => {
    const defaultConfig = {
        forwardIfEmpty: false,
    };
    return defaultConfig;
};
class Accumulator {
    constructor(config) {
        // the first message constains the schema version
        this._samples = {
            meta: {
                schemaVersion: schemas_1.version
            }
        };
        this._buffer = [];
        this._empty = true;
        this._config = config;
    }
    static create(config) {
        const appliedConfig = Object.assign(supplyDefaultConfig(), config);
        return new Accumulator(appliedConfig);
    }
    get isEmpty() {
        return this._empty;
    }
    drainTo(consumer) {
        this._buffering();
        if (this._buffer.length < 1) {
            if (this._config.forwardIfEmpty) {
                consumer();
            }
            return;
        }
        const buffer = this._buffer;
        this._buffer = [];
        buffer.forEach(samples => {
            consumer(samples);
        });
    }
    addClientSample(clientSample) {
        let clientSamples = this._samples.clientSamples;
        if (!clientSamples) {
            clientSamples = [];
            this._samples.clientSamples = clientSamples;
        }
        clientSamples.push(clientSample);
        this._empty = false;
        if (this._config.maxClientSamples && clientSamples.length <= this._config.maxClientSamples) {
            this._buffering();
        }
    }
    _buffering() {
        if (this._empty)
            return;
        this._buffer.push(this._samples);
        this._samples = {};
        this._empty = true;
    }
}
exports.Accumulator = Accumulator;

},{"@observertc/schemas":33}],4:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientDevices = void 0;
const Bowser = __importStar(require("bowser"));
const UNKNOWN_OS = {
    name: "Unkown",
    version: undefined,
    versionName: undefined,
};
const UNKNOWN_BROWSER = {
    name: "Unknown",
    version: undefined,
};
const UNKNOWN_PLATFORM = {
    type: "Unknown",
    vendor: undefined,
    model: undefined,
};
const UNKNOWN_ENGINE = {
    name: "Unknown",
    version: undefined,
};
class ClientDevices {
    constructor() {
        this._os = UNKNOWN_OS;
        this._browser = UNKNOWN_BROWSER;
        this._platform = UNKNOWN_PLATFORM;
        this._engine = UNKNOWN_ENGINE;
        /* eslint-disable @typescript-eslint/no-explicit-any */
        let outerNavigator = undefined;
        if (navigator)
            outerNavigator = navigator;
        else if (window && window.navigator)
            outerNavigator = window.navigator;
        else
            return this;
        const parsedResult = Bowser.parse(outerNavigator.userAgent);
        this._browser = Object.assign(this._browser, parsedResult.browser);
        this._engine = Object.assign(this._engine, parsedResult.engine);
        this._os = Object.assign(this._os, parsedResult.os);
        this._platform = Object.assign(this._platform, parsedResult.platform);
        return this;
    }
    get os() {
        return this._os;
    }
    get browser() {
        return this._browser;
    }
    get platform() {
        return this._platform;
    }
    get engine() {
        return this._engine;
    }
}
exports.ClientDevices = ClientDevices;

},{"bowser":87}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.create = exports.setLogLevel = void 0;
const ClientMonitorImpl_1 = require("./ClientMonitorImpl");
const logger_1 = require("./utils/logger");
/**
* Sets the level of logging of the module
*
* possible values are: "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "SILENT"
*/
function setLogLevel(level) {
    (0, logger_1.setLevel)(level);
}
exports.setLogLevel = setLogLevel;
/**
 * Create ClientObserver
 *
 * @param config the given config to setup the observer
 */
function create(config) {
    return ClientMonitorImpl_1.ClientMonitorImpl.create(config);
}
exports.create = create;

},{"./ClientMonitorImpl":6,"./utils/logger":31}],6:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientMonitorImpl = void 0;
const schemas_1 = require("@observertc/schemas");
const Collector_1 = require("./Collector");
const EventsRelayer_1 = require("./EventsRelayer");
const Sampler_1 = require("./Sampler");
const Sender_1 = require("./Sender");
const ClientDevices_1 = require("./ClientDevices");
const MediaDevices_1 = require("./utils/MediaDevices");
const Timer_1 = require("./utils/Timer");
const StatsStorage_1 = require("./entries/StatsStorage");
const Accumulator_1 = require("./Accumulator");
const logger_1 = require("./utils/logger");
const Sampler_2 = require("./Sampler");
const Metrics_1 = require("./Metrics");
const events_1 = __importDefault(require("events"));
// import * as proto from "./ProtobufSamples"
const logger = (0, logger_1.createLogger)("ClientMonitor");
const supplyDefaultConfig = () => {
    const defaultConfig = {
        // samplingPeriodInMs: 5000,
        // sendingPeriodInMs: 10000,
        sampler: (0, Sampler_2.supplyDefaultConfig)(),
    };
    return defaultConfig;
};
logger.debug("Version of the loaded schema:", schemas_1.version);
const TIMER_INVOKED_SEND_SENDER_NOT_EXISTS = "timerInvokedSendSenderNotExists";
class ClientMonitorImpl {
    constructor(config) {
        this._closed = false;
        this._flags = new Set();
        this._config = config;
        this._clientDevices = new ClientDevices_1.ClientDevices();
        this._mediaDevices = new MediaDevices_1.MediaDevices();
        this._statsStorage = new StatsStorage_1.StatsStorage();
        this._metrics = new Metrics_1.Metrics();
        this._accumulator = Accumulator_1.Accumulator.create(config.accumulator);
        this._eventer = EventsRelayer_1.EventsRelayer.create();
        this._collector = this._makeCollector();
        this._sampler = this._makeSampler();
        this._createSender();
        this._createTimer();
        this._sampler.addEngine(this._clientDevices.engine);
        this._sampler.addPlatform(this._clientDevices.platform);
        this._sampler.addBrowser(this._clientDevices.browser);
        this._sampler.addOs(this._clientDevices.os);
    }
    static create(config) {
        if ((config === null || config === void 0 ? void 0 : config.maxListeners) !== undefined) {
            events_1.default.setMaxListeners(config.maxListeners);
        }
        const appliedConfig = config ? Object.assign(supplyDefaultConfig(), config) : supplyDefaultConfig();
        const result = new ClientMonitorImpl(appliedConfig);
        logger.debug("Created", appliedConfig);
        return result;
    }
    get clientId() {
        /* eslint-disable @typescript-eslint/no-non-null-assertion */
        return this._sampler.clientId;
    }
    get callId() {
        return this._sampler.callId;
    }
    get os() {
        return this._clientDevices.os;
    }
    get metrics() {
        return this._metrics;
    }
    get browser() {
        return this._clientDevices.browser;
    }
    get platform() {
        return this._clientDevices.platform;
    }
    get engine() {
        return this._clientDevices.engine;
    }
    get audioInputs() {
        return this._mediaDevices.values("audioinput");
    }
    get audioOutputs() {
        return this._mediaDevices.values("audiooutput");
    }
    get videoInputs() {
        return this._mediaDevices.values("videoinput");
    }
    get events() {
        return this._eventer;
    }
    get storage() {
        return this._statsStorage;
    }
    connect(senderConfig) {
        if (this._sender) {
            logger.warn(`Sender is already established`);
            return;
        }
        this._config.sender = senderConfig;
        this._createSender();
    }
    disconnect() {
        if (!this._sender) {
            return;
        }
        if (!this._sender.closed) {
            this._sender.close();
        }
        this._sender = undefined;
    }
    addTrackRelation(trackRelation) {
        this._sampler.addTrackRelation(trackRelation);
    }
    removeTrackRelation(trackId) {
        this._sampler.removeTrackRelation(trackId);
    }
    addStatsCollector(collector) {
        this._collector.add(collector);
        this._statsStorage.register(collector.id, collector.label);
    }
    removeStatsCollector(collectorId) {
        this._collector.remove(collectorId);
        this._statsStorage.unregister(collectorId);
    }
    addMediaDevice(device) {
        this._mediaDevices.add(device);
        this._sampler.addMediaDevice(device);
    }
    removeMediaDevice(device) {
        if (device.id === undefined)
            return;
        this._mediaDevices.remove(device.id);
    }
    addMediaConstraints(constrain) {
        this._sampler.addMediaConstraints(constrain);
    }
    addUserMediaError(message) {
        this._sampler.addUserMediaError(message);
    }
    addExtensionStats(stats) {
        this._sampler.addExtensionStats(stats);
    }
    addLocalSDP(localSDP) {
        this._sampler.addLocalSDP(localSDP);
    }
    setMarker(marker) {
        this._sampler.setMarker(marker);
    }
    async collect() {
        const started = Date.now();
        await this._collector.collect().catch(err => {
            logger.warn(`Error occurred while collecting`, err);
        });
        const elapsedInMs = Date.now() - started;
        this._metrics.setCollectingTimeInMs(elapsedInMs);
        this._eventer.emitStatsCollected();
        if (this._config.statsExpirationTimeInMs) {
            const expirationThresholdInMs = Date.now() - this._config.statsExpirationTimeInMs;
            this._statsStorage.trim(expirationThresholdInMs);
        }
    }
    async sample() {
        const clientSample = this._sampler.make();
        if (!clientSample)
            return;
        if (this._sender) {
            this._accumulator.addClientSample(clientSample);
        }
        this._eventer.emitSampleCreated(clientSample);
    }
    async send() {
        if (!this._sender) {
            if (this._flags.has(TIMER_INVOKED_SEND_SENDER_NOT_EXISTS)) {
                return;
            }
            this._flags.add(TIMER_INVOKED_SEND_SENDER_NOT_EXISTS);
            logger.warn(`No Sender is available to send data`);
            return;
        }
        const queue = [];
        this._accumulator.drainTo(bufferedSamples => {
            if (!bufferedSamples)
                return;
            queue.push(bufferedSamples);
        });
        for (const samples of queue) {
            this._sender.send(samples);
        }
        this._eventer.emitSampleSent();
    }
    close() {
        var _a;
        if (this._closed) {
            logger.warn(`Attempted to close twice`);
            return;
        }
        try {
            if (this._timer) {
                this._timer.clear();
            }
            this._collector.close();
            this._sampler.close();
            (_a = this._sender) === null || _a === void 0 ? void 0 : _a.close();
            this._statsStorage.clear();
        }
        finally {
            this._closed = true;
            logger.info(`Closed`);
        }
    }
    _makeCollector() {
        var _a, _b;
        const collectorConfig = this._config.collectors;
        const createdAdapterConfig = {
            browserType: (_a = this._clientDevices.browser) === null || _a === void 0 ? void 0 : _a.name,
            browserVersion: (_b = this._clientDevices.browser) === null || _b === void 0 ? void 0 : _b.version,
        };
        const appliedCollectorsConfig = Object.assign({ adapter: createdAdapterConfig }, collectorConfig);
        const result = Collector_1.Collector.builder()
            .withConfig(appliedCollectorsConfig)
            .build();
        result.statsAcceptor = this._statsStorage;
        return result;
    }
    _makeSampler() {
        const samplerConfig = this._config.sampler;
        const result = Sampler_1.Sampler.builder()
            .withConfig(samplerConfig)
            .build();
        result.statsProvider = this._statsStorage;
        return result;
    }
    _createSender() {
        if (this._sender) {
            logger.warn(`Attempted to replace an already established Sender component`);
            return;
        }
        const senderConfig = this._config.sender;
        if (!senderConfig) {
            return;
        }
        this._sender = Sender_1.Sender.create(senderConfig)
            .onClosed(() => {
            this._sender = undefined;
        }).onError(() => {
            this._eventer.emitSenderDisconnected();
            this._sender = undefined;
        });
    }
    _createTimer() {
        if (this._timer) {
            logger.warn(`Attempted to create timer twice`);
            return;
        }
        const { collectingPeriodInMs, samplingPeriodInMs, sendingPeriodInMs, } = this._config;
        if (!collectingPeriodInMs && !samplingPeriodInMs && !sendingPeriodInMs) {
            return;
        }
        const result = new Timer_1.Timer();
        if (collectingPeriodInMs && 0 < collectingPeriodInMs) {
            result.add({
                type: "collect",
                process: this.collect.bind(this),
                fixedDelayInMs: collectingPeriodInMs,
                context: "Collect Stats"
            });
        }
        if (samplingPeriodInMs && 0 < samplingPeriodInMs) {
            result.add({
                type: "sample",
                process: this.sample.bind(this),
                fixedDelayInMs: samplingPeriodInMs,
                context: "Creating Sample"
            });
        }
        if (sendingPeriodInMs && 0 < sendingPeriodInMs) {
            result.add({
                type: "send",
                process: this.send.bind(this),
                fixedDelayInMs: sendingPeriodInMs,
                context: "Sending Samples"
            });
        }
        this._timer = result;
    }
}
exports.ClientMonitorImpl = ClientMonitorImpl;

},{"./Accumulator":3,"./ClientDevices":4,"./Collector":7,"./EventsRelayer":8,"./Metrics":9,"./Sampler":10,"./Sender":11,"./entries/StatsStorage":23,"./utils/MediaDevices":26,"./utils/Timer":28,"./utils/logger":31,"@observertc/schemas":33,"events":1}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Collector = void 0;
const Adapter_1 = require("./adapters/Adapter");
const logger_1 = require("./utils/logger");
const logger = (0, logger_1.createLogger)("Collector");
const supplyDefaultConfig = () => {
    const defaultConfig = {};
    return defaultConfig;
};
class Collector {
    constructor(config) {
        this._statsCollectors = new Map();
        this._closed = false;
        this._config = config;
        this._adapter = (0, Adapter_1.createAdapter)(this._config.adapter);
    }
    static builder() {
        let config;
        const result = {
            withConfig(value) {
                config = value;
                return result;
            },
            build() {
                if (!config)
                    throw new Error(`Cannot build a Collector without a config`);
                const result = new Collector(config);
                logger.debug(`Built`, config);
                return result;
            }
        };
        return result;
    }
    static create(config) {
        const appliedConfig = Object.assign(supplyDefaultConfig(), config);
        return new Collector(appliedConfig);
    }
    set statsAcceptor(value) {
        this._statsWriter = value;
    }
    async collect() {
        if (this._closed) {
            throw new Error(`Collector is already closed`);
        }
        if (!this._statsWriter) {
            logger.warn(`Output of the collector has not been set`);
            return;
        }
        /* eslint-disable @typescript-eslint/no-explicit-any */
        const illConfigs = [];
        const promises = [];
        for (const statsConfig of this._statsCollectors.values()) {
            const { id: collectorId, getStats } = statsConfig;
            const promise = new Promise(resolve => {
                getStats().then(scrappedStats => {
                    resolve([collectorId, scrappedStats]);
                }).catch((err) => {
                    illConfigs.push([collectorId, err]);
                    resolve(undefined);
                });
            });
            promises.push(promise);
        }
        for await (const scrappedEntry of promises) {
            if (scrappedEntry === undefined)
                continue;
            if (this._closed) {
                // if the collector is closed meanwhile it is collecting
                return;
            }
            /* eslint-disable @typescript-eslint/no-explicit-any */
            const [collectorId, scrappedStats] = scrappedEntry;
            for (const statsEntry of this._adapter.adapt(scrappedStats)) {
                if (!statsEntry)
                    continue;
                try {
                    this._statsWriter.accept(collectorId, statsEntry);
                }
                catch (err) {
                    illConfigs.push([collectorId, err]);
                }
            }
        }
        for (const illConfig of illConfigs) {
            // remove and log problems
            const [collectorId, err] = illConfig;
            this.remove(collectorId);
            logger.warn(`collector ${collectorId} is removed due to reported error`, err);
        }
    }
    /**
     * Adds a collector for a stats of a peer connection
     * @param pcStatsCollector Collector wanted to add.
     */
    add(pcStatsCollector) {
        if (this._closed) {
            throw new Error(`Cannot add StatsCollector because the Collector is closed`);
        }
        const { id: collectorId } = pcStatsCollector;
        if (this._statsCollectors.has(collectorId)) {
            throw new Error(`StatsCollector with id ${collectorId} has already been added`);
        }
        this._statsCollectors.set(collectorId, pcStatsCollector);
    }
    has(statsCollectorId) {
        return this._statsCollectors.has(statsCollectorId);
    }
    remove(collectorId) {
        if (this._closed) {
            throw new Error(`Cannot remove StatsCollector because the Collector is closed`);
        }
        if (!this._statsCollectors.delete(collectorId)) {
            logger.warn(`Collector with peer connection id ${collectorId} was not found`);
        }
    }
    close() {
        if (this._closed) {
            logger.warn(`Attempted to close Collector twice`);
            return;
        }
        try {
            for (const collectorId of this._statsCollectors.keys()) {
                this.remove(collectorId);
            }
        }
        finally {
            this._closed = true;
            logger.info(`Closed`);
        }
    }
}
exports.Collector = Collector;

},{"./adapters/Adapter":12,"./utils/logger":31}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventsRelayer = void 0;
const events_1 = require("events");
const ON_STATS_COLLECTED_EVENT_NAME = "onStatsCollected";
const ON_SAMPLE_CREATED_EVENT_NAME = "onSampleCreated";
const ON_SAMPLES_SENT_EVENT_NAME = "onSamplesSent";
const ON_SENDER_DISCONNECTED_EVENT_NAME = "onSamplesSent";
class EventsRelayer {
    constructor() {
        this._emitter = new events_1.EventEmitter({});
    }
    static create() {
        return new EventsRelayer();
    }
    onStatsCollected(listener) {
        this._emitter.on(ON_STATS_COLLECTED_EVENT_NAME, listener);
        return this;
    }
    emitStatsCollected() {
        this._emitter.emit(ON_STATS_COLLECTED_EVENT_NAME);
    }
    offStatsCollected(listener) {
        this._emitter.off(ON_STATS_COLLECTED_EVENT_NAME, listener);
        return this;
    }
    onSampleCreated(listener) {
        this._emitter.on(ON_SAMPLE_CREATED_EVENT_NAME, listener);
        return this;
    }
    emitSampleCreated(clientSample) {
        this._emitter.emit(ON_SAMPLE_CREATED_EVENT_NAME, clientSample);
    }
    offSampleCreated(listener) {
        this._emitter.off(ON_SAMPLE_CREATED_EVENT_NAME, listener);
        return this;
    }
    onSampleSent(listener) {
        this._emitter.on(ON_SAMPLES_SENT_EVENT_NAME, listener);
        return this;
    }
    emitSampleSent() {
        this._emitter.emit(ON_SAMPLES_SENT_EVENT_NAME);
    }
    offSampleSent(listener) {
        this._emitter.off(ON_SAMPLES_SENT_EVENT_NAME, listener);
        return this;
    }
    onSenderDisconnected(listener) {
        this._emitter.on(ON_SENDER_DISCONNECTED_EVENT_NAME, listener);
        return this;
    }
    emitSenderDisconnected() {
        this._emitter.emit(ON_SENDER_DISCONNECTED_EVENT_NAME);
    }
    offSenderDisconnected(listener) {
        this._emitter.off(ON_SENDER_DISCONNECTED_EVENT_NAME, listener);
        return this;
    }
}
exports.EventsRelayer = EventsRelayer;

},{"events":1}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Metrics = void 0;
class Metrics {
    setCollectingTimeInMs(value) {
        this._collectingTimeInMs = value;
    }
    get collectingTimeInMs() {
        return this._collectingTimeInMs;
    }
}
exports.Metrics = Metrics;

},{}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sampler = exports.supplyDefaultConfig = void 0;
const uuid_1 = require("uuid");
const common_1 = require("./utils/common");
const validators_1 = require("./utils/validators");
const logger_1 = require("./utils/logger");
const logger = (0, logger_1.createLogger)("Sampler");
const supplyDefaultConfig = () => {
    const defaultConfig = {
        roomId: (0, uuid_1.v4)(),
        clientId: (0, uuid_1.v4)(),
        incrementalSampling: true,
    };
    return defaultConfig;
};
exports.supplyDefaultConfig = supplyDefaultConfig;
class Sampler {
    constructor(config) {
        // private _peerConnections: Map<string, PeerConnectionEntry> = new Map();
        this._trackRelations = new Map();
        this._sampleSeq = 0;
        this._timezoneOffset = new Date().getTimezoneOffset();
        this._closed = false;
        if (config.callId && !(0, validators_1.isValidUuid)(config.callId)) {
            throw new Error(`Sampler.config.callId must be a valid UUID`);
        }
        if (!(0, validators_1.isValidUuid)(config.clientId)) {
            throw new Error(`Sampler.config.clientId must be a valid UUID`);
        }
        this._config = config;
    }
    static builder() {
        let config;
        const result = {
            withConfig(value) {
                config = value;
                return result;
            },
            build() {
                if (!config)
                    throw new Error(`Cannot create a Sampler without config`);
                const appliedConfig = Object.assign((0, exports.supplyDefaultConfig)(), config);
                return new Sampler(appliedConfig);
            }
        };
        return result;
    }
    static create(config) {
        const appliedConfig = Object.assign((0, exports.supplyDefaultConfig)(), config);
        const result = new Sampler(appliedConfig);
        logger.debug(`Created`, appliedConfig);
        return result;
    }
    set statsProvider(value) {
        this._statsReader = value;
    }
    get clientId() {
        return this._config.clientId;
    }
    get callId() {
        return this._config.callId;
    }
    addTrackRelation(trackRelation) {
        this._trackRelations.set(trackRelation.trackId, trackRelation);
    }
    removeTrackRelation(trackId) {
        this._trackRelations.delete(trackId);
    }
    addEngine(engine) {
        this._engine = engine;
    }
    addPlatform(platform) {
        this._platform = platform;
    }
    addBrowser(browser) {
        this._browser = browser;
    }
    addOs(os) {
        this._os = os;
    }
    addMediaConstraints(constrain) {
        if (!this._mediaConstraints)
            this._mediaConstraints = [];
        this._mediaConstraints.push(constrain);
    }
    addUserMediaError(message) {
        if (!this._userMediaErrors)
            this._userMediaErrors = [];
        this._userMediaErrors.push(message);
    }
    addExtensionStats(stats) {
        if (!this._extensionStats)
            this._extensionStats = [];
        this._extensionStats.push(stats);
    }
    addLocalSDP(localSDP) {
        if (!this._localSDP)
            this._localSDP = [];
        this._localSDP.push(...localSDP);
    }
    addMediaDevice(mediaDevice) {
        if (!this._mediaDevices)
            this._mediaDevices = [];
        this._mediaDevices.push(mediaDevice);
    }
    setMarker(marker) {
        this._marker = marker;
    }
    close() {
        if (this._closed) {
            logger.warn(`Attempted to close the Sampler twice`);
            return;
        }
        this._closed = true;
        logger.info(`Closed`);
    }
    make() {
        if (this._closed) {
            throw new Error(`Cannot sample a closed Sampler`);
        }
        const now = Date.now();
        const clientSample = {
            callId: this._config.callId,
            clientId: this._config.clientId,
            sampleSeq: this._sampleSeq,
            roomId: this._config.roomId,
            userId: this._config.userId,
            timeZoneOffsetInHours: this._timezoneOffset,
            marker: this._marker,
            localSDPs: this._localSDP,
            engine: this._engine,
            platform: this._platform,
            browser: this._browser,
            os: this._os,
            mediaConstraints: this._mediaConstraints,
            userMediaErrors: this._userMediaErrors,
            extensionStats: this._extensionStats,
            mediaDevices: this._mediaDevices,
            timestamp: now,
        };
        ++this._sampleSeq;
        this._engine = undefined;
        this._platform = undefined;
        this._browser = undefined;
        this._os = undefined;
        this._mediaConstraints = undefined;
        this._userMediaErrors = undefined;
        this._extensionStats = undefined;
        this._mediaDevices = undefined;
        this._localSDP = undefined;
        if (!this._statsReader) {
            logger.warn(`No StatsProvider has been assigned to Sampler`);
            this._sampled = clientSample.timestamp;
            return clientSample;
        }
        let inboundAudioTracks;
        let inboundVideoTracks;
        let outboundAudioTracks;
        let outboundVideoTracks;
        let pcTransports;
        let mediaSources;
        let codecs;
        let certificates;
        let iceLocalCandidates;
        let iceRemoteCandidates;
        let dataChannels;
        let iceServers;
        for (const peerConnection of this._statsReader.peerConnections()) {
            for (const [inboundAudioTrack, inboundVideoTrack] of this._makeInboundTrack(peerConnection)) {
                if (inboundAudioTrack) {
                    if (!inboundAudioTracks)
                        inboundAudioTracks = [];
                    inboundAudioTracks.push(inboundAudioTrack);
                }
                if (inboundVideoTrack) {
                    if (!inboundVideoTracks)
                        inboundVideoTracks = [];
                    inboundVideoTracks.push(inboundVideoTrack);
                }
            }
            for (const [outboundAudioTrack, outboundVideoTrack] of this._makeOutboundTrack(peerConnection)) {
                if (outboundAudioTrack) {
                    if (!outboundAudioTracks)
                        outboundAudioTracks = [];
                    outboundAudioTracks.push(outboundAudioTrack);
                }
                if (outboundVideoTrack) {
                    if (!outboundVideoTracks)
                        outboundVideoTracks = [];
                    outboundVideoTracks.push(outboundVideoTrack);
                }
            }
            for (const pcTransport of this._makePcTransport(peerConnection)) {
                if (!pcTransports)
                    pcTransports = [];
                pcTransports.push(pcTransport);
            }
            for (const mediaSource of this._makeMediaSource(peerConnection)) {
                if (!mediaSources)
                    mediaSources = [];
                mediaSources.push(mediaSource);
            }
            for (const codec of this._makeCodec(peerConnection)) {
                if (!codecs)
                    codecs = [];
                codecs.push(codec);
            }
            for (const certificate of this._makeCertificate(peerConnection)) {
                if (!certificates)
                    certificates = [];
                certificates.push(certificate);
            }
            for (const iceLocalCandidate of this._makeIceLocalCandidate(peerConnection)) {
                if (!iceLocalCandidates)
                    iceLocalCandidates = [];
                iceLocalCandidates.push(iceLocalCandidate);
            }
            for (const iceRemoteCandidate of this._makeIceRemoteCandidate(peerConnection)) {
                if (!iceRemoteCandidates)
                    iceRemoteCandidates = [];
                iceRemoteCandidates.push(iceRemoteCandidate);
            }
            for (const dataChannel of this._makeDataChannel(peerConnection)) {
                if (!dataChannels)
                    dataChannels = [];
                dataChannels.push(dataChannel);
            }
            for (const iceServer of this._makeIceServer(peerConnection)) {
                if (!iceServers)
                    iceServers = [];
                iceServers.push(iceServer);
            }
        }
        clientSample.inboundAudioTracks = inboundAudioTracks;
        clientSample.inboundVideoTracks = inboundVideoTracks;
        clientSample.outboundAudioTracks = outboundAudioTracks;
        clientSample.outboundVideoTracks = outboundVideoTracks;
        clientSample.pcTransports = pcTransports;
        clientSample.mediaSources = mediaSources;
        clientSample.codecs = codecs;
        clientSample.certificates = certificates;
        clientSample.iceLocalCandidates = iceLocalCandidates;
        clientSample.iceRemoteCandidates = iceRemoteCandidates;
        clientSample.dataChannels = dataChannels;
        clientSample.iceServers = iceServers;
        this._sampled = clientSample.timestamp;
        logger.debug(`Assembled ClientSample`, clientSample);
        return clientSample;
    }
    *_makeOutboundTrack(peerConnection) {
        var _a, _b;
        for (const outboundRtp of peerConnection.outboundRtps()) {
            if (this._config.incrementalSampling &&
                this._sampled &&
                outboundRtp.updated <= this._sampled) {
                continue;
            }
            const remoteInboundRtpStats = ((_a = outboundRtp.getRemoteInboundRtp()) === null || _a === void 0 ? void 0 : _a.stats) || {};
            const mediaSource = outboundRtp.getMediaSource();
            const codec = outboundRtp.getCodec();
            let codecStats = {};
            if (!this._config.incrementalSampling && (codec === null || codec === void 0 ? void 0 : codec.stats)) {
                codecStats = codec === null || codec === void 0 ? void 0 : codec.stats;
            }
            else if ((codec === null || codec === void 0 ? void 0 : codec.stats) && this._sampled && this._sampled <= codec.updated) {
                codecStats = codec === null || codec === void 0 ? void 0 : codec.stats;
            }
            const { ended, trackIdentifier: senderTrackId } = ((_b = outboundRtp.getSender()) === null || _b === void 0 ? void 0 : _b.stats) || {};
            if (outboundRtp.stats.kind === "audio") {
                /* eslint-disable @typescript-eslint/no-explicit-any */
                const { trackIdentifier: sourceTrackId, ...audioSourceStats } = mediaSource ? mediaSource.stats : {};
                let mediaSourceStats = {};
                if (audioSourceStats) {
                    if (!this._config.incrementalSampling)
                        mediaSourceStats = audioSourceStats;
                    else if (mediaSource && this._sampled && this._sampled <= mediaSource.updated)
                        mediaSourceStats = audioSourceStats;
                }
                const trackId = sourceTrackId || senderTrackId;
                if (trackId && !(0, validators_1.isValidUuid)(trackId)) {
                    logger.debug(`Invalid outbound audio track id ${trackId}, not be sampled`);
                    continue;
                }
                const { sfuStreamId } = this._trackRelations.get(trackId || "notId") || {};
                const { perDscpPacketsSent: perDscpPackets, ...outboundStats } = outboundRtp.stats;
                const perDscpId = perDscpPackets ? Object.keys(perDscpPackets)[0] : undefined;
                const perDscpPacketsSent = perDscpPackets && perDscpId ? perDscpPackets[perDscpId] : undefined;
                const outboundAudioTrack = {
                    ...codecStats,
                    ...mediaSourceStats,
                    ...remoteInboundRtpStats,
                    ...outboundStats,
                    peerConnectionId: peerConnection.collectorId,
                    // perDscpId,
                    perDscpPacketsSent,
                    trackId,
                    sfuStreamId,
                    ended,
                };
                yield [outboundAudioTrack, undefined];
            }
            if (outboundRtp.stats.kind === "video") {
                const { trackIdentifier: sourceTrackId, ...videoSourceStats } = mediaSource ? mediaSource.stats : {};
                let mediaSourceStats = {};
                if (videoSourceStats) {
                    if (!this._config.incrementalSampling)
                        mediaSourceStats = videoSourceStats;
                    else if (mediaSource && this._sampled && this._sampled <= mediaSource.updated)
                        mediaSourceStats = videoSourceStats;
                }
                const trackId = sourceTrackId || senderTrackId;
                if (trackId && !(0, validators_1.isValidUuid)(trackId)) {
                    logger.debug(`Invalid outbound video track id ${trackId}, not be sampled`);
                    continue;
                }
                const { sfuStreamId } = this._trackRelations.get(trackId || "notId") || {};
                const { qualityLimitationDurations, perDscpPacketsSent: perDscpPackets, ...outboundStats } = outboundRtp.stats;
                const perDscpId = perDscpPackets ? Object.keys(perDscpPackets)[0] : undefined;
                const perDscpPacketsSent = perDscpPackets && perDscpId ? perDscpPackets[perDscpId] : undefined;
                const outboundVideoTrack = {
                    ...codecStats,
                    ...mediaSourceStats,
                    ...remoteInboundRtpStats,
                    ...outboundStats,
                    peerConnectionId: peerConnection.collectorId,
                    qualityLimitationDurationNone: qualityLimitationDurations === null || qualityLimitationDurations === void 0 ? void 0 : qualityLimitationDurations.none,
                    qualityLimitationDurationCPU: qualityLimitationDurations === null || qualityLimitationDurations === void 0 ? void 0 : qualityLimitationDurations.cpu,
                    qualityLimitationDurationBandwidth: qualityLimitationDurations === null || qualityLimitationDurations === void 0 ? void 0 : qualityLimitationDurations.bandwidth,
                    qualityLimitationDurationOther: qualityLimitationDurations === null || qualityLimitationDurations === void 0 ? void 0 : qualityLimitationDurations.none,
                    // perDscpId,
                    perDscpPacketsSent,
                    trackId,
                    sfuStreamId,
                    ended,
                };
                yield [undefined, outboundVideoTrack];
            }
        }
    }
    *_makeInboundTrack(peerConnection) {
        var _a, _b;
        // remoteOutboundRtp.getTransport().
        for (const inboundRtp of peerConnection.inboundRtps()) {
            if (this._config.incrementalSampling &&
                this._sampled &&
                inboundRtp.updated <= this._sampled) {
                continue;
            }
            const remoteOutboundRtpStats = ((_a = inboundRtp.getRemoteOutboundRtp()) === null || _a === void 0 ? void 0 : _a.stats) || {};
            const { ended, trackIdentifier: trackId } = ((_b = inboundRtp.getReceiver()) === null || _b === void 0 ? void 0 : _b.stats) || {};
            if (trackId && !(0, validators_1.isValidUuid)(trackId)) {
                logger.debug(`Invalid inbound track id ${trackId}, not be sampled`);
                continue;
            }
            const { sfuSinkId, remoteClientId } = this._trackRelations.get(trackId || "notId") || {};
            const codec = inboundRtp.getCodec();
            let codecStats = {};
            if (!this._config.incrementalSampling && (codec === null || codec === void 0 ? void 0 : codec.stats)) {
                codecStats = codec === null || codec === void 0 ? void 0 : codec.stats;
            }
            else if ((codec === null || codec === void 0 ? void 0 : codec.stats) && this._sampled && this._sampled <= codec.updated) {
                codecStats = codec === null || codec === void 0 ? void 0 : codec.stats;
            }
            const { perDscpPacketsReceived: perDscpPackets, ...inboundRtpStats } = inboundRtp.stats;
            const perDscpId = perDscpPackets ? Object.keys(perDscpPackets)[0] : undefined;
            const perDscpPacketsReceived = perDscpPackets && perDscpId ? perDscpPackets[perDscpId] : undefined;
            if (inboundRtp.stats.kind === "audio") {
                const inboundAudioTrack = {
                    ...remoteOutboundRtpStats,
                    ...codecStats,
                    // to overwrite id and other stuffs:
                    ...inboundRtpStats,
                    perDscpPacketsReceived,
                    trackId,
                    sfuSinkId,
                    remoteClientId,
                    ended,
                    peerConnectionId: peerConnection.collectorId,
                };
                yield [inboundAudioTrack, undefined];
            }
            if (inboundRtp.stats.kind === "video") {
                const inboundVideoTrack = {
                    ...remoteOutboundRtpStats,
                    ...codecStats,
                    // to overwrite id and other stuffs:
                    ...inboundRtpStats,
                    trackId,
                    sfuSinkId,
                    remoteClientId,
                    ended,
                    peerConnectionId: peerConnection.collectorId,
                };
                yield [undefined, inboundVideoTrack];
            }
        }
    }
    *_makePcTransport(peerConnection) {
        for (const transport of peerConnection.transports()) {
            if (this._config.incrementalSampling &&
                this._sampled &&
                transport.updated <= this._sampled) {
                continue;
            }
            const transportStats = transport.stats;
            const selectedCandidatePair = transport.getSelectedIceCandidatePair();
            /*eslint-disable @typescript-eslint/ban-types*/
            let candidatePairStats = {};
            /*eslint-disable @typescript-eslint/ban-types*/
            let localCandidateStats = {};
            /*eslint-disable @typescript-eslint/ban-types*/
            let remoteCandidateStats = {};
            if (selectedCandidatePair) {
                if (!this._config.incrementalSampling || !this._sampled || this._sampled <= selectedCandidatePair.updated) {
                    candidatePairStats = (0, common_1.makePrefixedObj)(selectedCandidatePair.stats, `candidatePair`, true);
                    const localCandidate = selectedCandidatePair.getLocalCandidate();
                    localCandidateStats = localCandidate ? (0, common_1.makePrefixedObj)(localCandidate.stats, `local`, true) : {};
                    const remoteCandidate = selectedCandidatePair.getRemoteCandidate();
                    remoteCandidateStats = remoteCandidate ? (0, common_1.makePrefixedObj)(remoteCandidate.stats, `remote`, true) : {};
                }
            }
            const sample = {
                ...peerConnection.stats,
                ...transportStats,
                ...candidatePairStats,
                ...localCandidateStats,
                ...remoteCandidateStats,
                peerConnectionId: peerConnection.collectorId,
                label: peerConnection.collectorLabel,
            };
            yield sample;
        }
    }
    *_makeMediaSource(peerConnection) {
        for (const mediaSourceEntry of peerConnection.mediaSources()) {
            if (this._config.incrementalSampling &&
                this._sampled &&
                mediaSourceEntry.updated <= this._sampled) {
                continue;
            }
            const stats = mediaSourceEntry.stats;
            const sample = {
                ...((stats.kind === "audio") ? stats : stats),
            };
            yield sample;
        }
    }
    *_makeCodec(peerConnection) {
        for (const codec of peerConnection.codecs()) {
            if (this._config.incrementalSampling &&
                this._sampled &&
                codec.updated <= this._sampled) {
                continue;
            }
            const stats = codec.stats;
            const sampledCodec = {
                ...stats,
            };
            yield sampledCodec;
        }
    }
    *_makeCertificate(peerConnection) {
        for (const certificate of peerConnection.certificates()) {
            if (this._config.incrementalSampling &&
                this._sampled &&
                certificate.updated <= this._sampled) {
                continue;
            }
            const stats = certificate.stats;
            const sampledCertificate = {
                ...stats,
            };
            yield sampledCertificate;
        }
    }
    *_makeIceLocalCandidate(peerConnection) {
        for (const iceLocalCandidate of peerConnection.localCandidates()) {
            if (this._config.incrementalSampling &&
                this._sampled &&
                iceLocalCandidate.updated <= this._sampled) {
                continue;
            }
            const stats = iceLocalCandidate.stats;
            const sampledLocalCandidate = {
                ...stats,
                peerConnectionId: peerConnection.collectorId,
            };
            yield sampledLocalCandidate;
        }
    }
    *_makeIceRemoteCandidate(peerConnection) {
        for (const iceRemoteCandidate of peerConnection.remoteCandidates()) {
            if (this._config.incrementalSampling &&
                this._sampled &&
                iceRemoteCandidate.updated <= this._sampled) {
                continue;
            }
            const stats = iceRemoteCandidate.stats;
            yield {
                ...stats,
                peerConnectionId: peerConnection.collectorId,
            };
        }
    }
    *_makeDataChannel(peerConnection) {
        var _a;
        for (const dataChannel of peerConnection.dataChannels()) {
            if (this._config.incrementalSampling &&
                this._sampled &&
                dataChannel.updated <= this._sampled) {
                continue;
            }
            const stats = dataChannel.stats;
            yield {
                ...stats,
                peerConnectionId: (_a = peerConnection.collectorId) !== null && _a !== void 0 ? _a : common_1.NULL_UUID,
            };
        }
    }
    *_makeIceServer(peerConnection) {
        for (const iceServer of peerConnection.iceServers()) {
            if (this._config.incrementalSampling &&
                this._sampled &&
                iceServer.updated <= this._sampled) {
                continue;
            }
            const url = iceServer.stats.url;
            yield url;
        }
    }
}
exports.Sampler = Sampler;

},{"./utils/common":29,"./utils/logger":31,"./utils/validators":32,"uuid":120}],11:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sender = void 0;
const Codec_1 = require("./codecs/Codec");
const WebsocketTransport_1 = require("./transports/WebsocketTransport");
const logger_1 = require("./utils/logger");
const events_1 = __importDefault(require("events"));
const logger = (0, logger_1.createLogger)("Sender");
const supplyDefaultConfig = () => {
    const defaultConfig = {};
    return defaultConfig;
};
function createTransport(config) {
    if (config.websocket) {
        const result = WebsocketTransport_1.WebsocketTransport.create(config.websocket);
        return result;
    }
    throw new Error(`No transport is manifested for config ${config}`);
}
const ON_ERROR_EVENT_NAME = "onError";
const ON_CLOSED_EVENT_NAME = "onClosed";
class Sender {
    constructor(config) {
        this._closed = false;
        this._emitter = new events_1.default();
        this._config = config;
        this._codec = (0, Codec_1.createCodec)(this._config.format);
        this._transport = createTransport({
            websocket: config.websocket,
        });
    }
    static create(config) {
        const appliedConfig = Object.assign(supplyDefaultConfig(), config);
        const result = new Sender(appliedConfig);
        logger.debug(`Created`, appliedConfig);
        return result;
    }
    close() {
        if (this._closed) {
            return;
        }
        this._close();
    }
    _close(err) {
        if (this._closed) {
            logger.warn(`Attempted to close the Sender twice`);
            return;
        }
        try {
            if (this._transport && !this._transport.closed) {
                this._transport.close();
            }
        }
        finally {
            this._closed = true;
            logger.info(`Closed`);
        }
        if (err) {
            this._emitter.emit(ON_ERROR_EVENT_NAME, err);
        }
        else {
            this._emitter.emit(ON_CLOSED_EVENT_NAME);
        }
        [
            ON_CLOSED_EVENT_NAME,
            ON_ERROR_EVENT_NAME
        ].forEach(eventType => this._emitter.removeAllListeners(eventType));
    }
    get closed() {
        return this._closed;
    }
    send(samples) {
        if (this._closed) {
            throw new Error(`Cannot use an already closed Sender`);
        }
        const message = this._codec.encode(samples);
        // --- for observer decoding tests ---
        // const messageInBase64 = require("js-base64").Base64.fromUint8Array(message);
        // logger.info({
        //     original: JSON.stringify(samples),
        //     messageInBase64
        // });
        this._transport.send(message).catch(err => {
            logger.warn(err);
            if (!this._closed) {
                this.close();
            }
        });
    }
    /*eslint-disable @typescript-eslint/no-explicit-any */
    onError(listener) {
        if (this._closed) {
            throw new Error(`Cannot subscribe / unsubscribe events of a closed Sender`);
        }
        this._emitter.on(ON_ERROR_EVENT_NAME, listener);
        return this;
    }
    /*eslint-disable @typescript-eslint/no-explicit-any */
    offError(listener) {
        if (this._closed) {
            return this;
        }
        this._emitter.off(ON_ERROR_EVENT_NAME, listener);
        return this;
    }
    /*eslint-disable @typescript-eslint/no-explicit-any */
    onClosed(listener) {
        if (this._closed) {
            throw new Error(`Cannot subscribe / unsubscribe events of a closed Sender`);
        }
        this._emitter.on(ON_CLOSED_EVENT_NAME, listener);
        return this;
    }
    /*eslint-disable @typescript-eslint/no-explicit-any */
    offClosed(listener) {
        if (this._closed) {
            return this;
        }
        this._emitter.off(ON_CLOSED_EVENT_NAME, listener);
        return this;
    }
}
exports.Sender = Sender;

},{"./codecs/Codec":17,"./transports/WebsocketTransport":25,"./utils/logger":31,"events":1}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.castStats = exports.createAdapter = void 0;
const Chrome86Adapter_1 = require("./Chrome86Adapter");
const DefaultAdapter_1 = require("./DefaultAdapter");
const schemas_1 = require("@observertc/schemas");
const Firefox94Adapter_1 = require("./Firefox94Adapter");
const Safari14Adapter_1 = require("./Safari14Adapter");
const logger_1 = require("../utils/logger");
const logger = (0, logger_1.createLogger)(`Adapter`);
const supplyDefaultConfig = () => {
    const defaultConfig = {};
    return defaultConfig;
};
function createChromeAdapter(version) {
    if (!version) {
        return new DefaultAdapter_1.DefaultAdapter();
    }
    const majorVersion = version.split(".")[0];
    if (!majorVersion) {
        logger.warn(`Cannot recognize chrome version ${version}`);
        return new DefaultAdapter_1.DefaultAdapter();
    }
    const majorVersionNumber = Number.parseInt(majorVersion);
    if (!Number.isInteger(majorVersionNumber)) {
        logger.warn(`Cannot recognize chrome version major number ${majorVersion}`);
        return new DefaultAdapter_1.DefaultAdapter();
    }
    if (majorVersionNumber < 86) {
        logger.info(`There is no adapter for chrome before version 86`);
        return new DefaultAdapter_1.DefaultAdapter();
    }
    return new Chrome86Adapter_1.Chrome86Adapter();
}
function createFirefoxAdapter(version) {
    if (!version) {
        return new DefaultAdapter_1.DefaultAdapter();
    }
    const majorVersion = version.split(".")[0];
    if (!majorVersion) {
        logger.warn(`Cannot recognize firefox version ${version}`);
        return new DefaultAdapter_1.DefaultAdapter();
    }
    const majorVersionNumber = Number.parseInt(majorVersion);
    if (!Number.isInteger(majorVersionNumber)) {
        logger.warn(`Cannot recognize firefox version major number ${majorVersion}`);
        return new DefaultAdapter_1.DefaultAdapter();
    }
    return new Firefox94Adapter_1.Firefox94Adapter();
}
function createSafariAdapter(version) {
    if (!version) {
        return new DefaultAdapter_1.DefaultAdapter();
    }
    const majorVersion = version.split(".")[0];
    if (!majorVersion) {
        logger.warn(`Cannot recognize safari version ${version}`);
        return new DefaultAdapter_1.DefaultAdapter();
    }
    const majorVersionNumber = Number.parseInt(majorVersion);
    if (!Number.isInteger(majorVersionNumber)) {
        logger.warn(`Cannot recognize safari version major number ${majorVersion}`);
        return new DefaultAdapter_1.DefaultAdapter();
    }
    return new Safari14Adapter_1.Safari14Adapter();
}
function createAdapter(providedConfig) {
    const config = Object.assign(supplyDefaultConfig(), providedConfig);
    if (!config || !config.browserType) {
        return new DefaultAdapter_1.DefaultAdapter();
    }
    switch (config.browserType.toLowerCase()) {
        case "chrome":
            return createChromeAdapter(config.browserVersion);
        case "firefox":
            return createFirefoxAdapter(config.browserVersion);
        case "safari":
            return createSafariAdapter(config.browserVersion);
        default:
            // logger.info(`Browser type ${config.browserType} is not recognized`);
            return new DefaultAdapter_1.DefaultAdapter();
    }
}
exports.createAdapter = createAdapter;
/*eslint-disable @typescript-eslint/no-explicit-any */
function castStats(rtcStatType, rtcStatValue) {
    switch (rtcStatType.toLowerCase()) {
        case schemas_1.W3CStats.StatsType.codec:
            return [schemas_1.W3CStats.StatsType.codec, rtcStatValue];
        case schemas_1.W3CStats.StatsType.inboundRtp:
            return [schemas_1.W3CStats.StatsType.inboundRtp, rtcStatValue];
        case schemas_1.W3CStats.StatsType.outboundRtp:
            return [schemas_1.W3CStats.StatsType.outboundRtp, rtcStatValue];
        case schemas_1.W3CStats.StatsType.remoteInboundRtp:
            return [schemas_1.W3CStats.StatsType.remoteInboundRtp, rtcStatValue];
        case schemas_1.W3CStats.StatsType.remoteOutboundRtp:
            return [schemas_1.W3CStats.StatsType.remoteOutboundRtp, rtcStatValue];
        case schemas_1.W3CStats.StatsType.mediaSource:
            return [schemas_1.W3CStats.StatsType.mediaSource, rtcStatValue];
        case schemas_1.W3CStats.StatsType.csrc:
            return [schemas_1.W3CStats.StatsType.csrc, rtcStatValue];
        case schemas_1.W3CStats.StatsType.peerConnection:
            return [schemas_1.W3CStats.StatsType.peerConnection, rtcStatValue];
        case schemas_1.W3CStats.StatsType.dataChannel:
            return [schemas_1.W3CStats.StatsType.dataChannel, rtcStatValue];
        case schemas_1.W3CStats.StatsType.stream:
            return undefined; // unsupported
        case schemas_1.W3CStats.StatsType.track:
            return undefined; // unsupported
        case schemas_1.W3CStats.StatsType.transceiver:
            return [schemas_1.W3CStats.StatsType.transceiver, rtcStatValue];
        case schemas_1.W3CStats.StatsType.sender:
            return [schemas_1.W3CStats.StatsType.sender, rtcStatValue];
        case schemas_1.W3CStats.StatsType.receiver:
            return [schemas_1.W3CStats.StatsType.receiver, rtcStatValue];
        case schemas_1.W3CStats.StatsType.transport:
            return [schemas_1.W3CStats.StatsType.transport, rtcStatValue];
        case schemas_1.W3CStats.StatsType.sctpTransport:
            return [schemas_1.W3CStats.StatsType.sctpTransport, rtcStatValue];
        case schemas_1.W3CStats.StatsType.candidatePair:
            return [schemas_1.W3CStats.StatsType.candidatePair, rtcStatValue];
        case schemas_1.W3CStats.StatsType.localCandidate:
            return [schemas_1.W3CStats.StatsType.localCandidate, rtcStatValue];
        case schemas_1.W3CStats.StatsType.remoteCandidate:
            return [schemas_1.W3CStats.StatsType.remoteCandidate, rtcStatValue];
        case schemas_1.W3CStats.StatsType.certificate:
            return [schemas_1.W3CStats.StatsType.certificate, rtcStatValue];
        case schemas_1.W3CStats.StatsType.iceServer:
            return [schemas_1.W3CStats.StatsType.iceServer, rtcStatValue];
        default:
            return undefined;
    }
}
exports.castStats = castStats;

},{"../utils/logger":31,"./Chrome86Adapter":13,"./DefaultAdapter":14,"./Firefox94Adapter":15,"./Safari14Adapter":16,"@observertc/schemas":33}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chrome86Adapter = void 0;
const Adapter_1 = require("./Adapter");
const logger_1 = require("../utils/logger");
const logger = (0, logger_1.createLogger)("Chrome86Adapter");
class Chrome86Adapter {
    /*eslint-disable @typescript-eslint/no-explicit-any */
    *adapt(rtcStats) {
        if (!rtcStats || !rtcStats.values || typeof rtcStats.values !== 'function') {
            logger.warn(`not rtcStats object is provided to the adapter: `, rtcStats);
            return;
        }
        const tracks = new Map();
        for (const rtcStatValue of rtcStats.values()) {
            if (rtcStatValue && rtcStatValue.type === "track") {
                tracks.set(rtcStatValue.id, rtcStatValue);
            }
        }
        const senders = new Map();
        const receivers = new Map();
        for (let rtcStatValue of rtcStats.values()) {
            const rawType = rtcStatValue.type;
            if (!rtcStatValue)
                continue;
            if (!rawType || typeof rawType !== 'string')
                continue;
            if (rawType === "track")
                continue;
            if (rawType === "inbound-rtp" || rawType === "outbound-rtp") {
                if (rtcStatValue.trackId) {
                    const trackStats = tracks.get(rtcStatValue.trackId);
                    if (trackStats) {
                        rtcStatValue = {
                            ...trackStats,
                            ...rtcStatValue,
                        };
                        if (rawType === "outbound-rtp") {
                            senders.set(trackStats.id, trackStats);
                        }
                        else if (rawType === "inbound-rtp") {
                            receivers.set(trackStats.id, trackStats);
                        }
                    }
                }
                if (rtcStatValue.mediaType && !rtcStatValue.kind) {
                    rtcStatValue.kind = rtcStatValue.mediaType;
                }
                if (rawType === "inbound-rtp" && rtcStatValue.trackId && !rtcStatValue.receiverId) {
                    rtcStatValue.receiverId = rtcStatValue.trackId;
                }
                if (rawType === "outbound-rtp" && rtcStatValue.trackId && !rtcStatValue.senderId) {
                    rtcStatValue.senderId = rtcStatValue.trackId;
                }
            }
            else if (rawType === "local-candidate" || rawType === "remote-candidate") {
                if (rtcStatValue.ip && !rtcStatValue.address) {
                    rtcStatValue.address = rtcStatValue.ip;
                }
            }
            yield (0, Adapter_1.castStats)(rawType, rtcStatValue);
        }
        for (const trackStats of senders.values()) {
            yield (0, Adapter_1.castStats)("sender", trackStats);
        }
        for (const trackStats of receivers.values()) {
            yield (0, Adapter_1.castStats)("receiver", trackStats);
        }
    }
}
exports.Chrome86Adapter = Chrome86Adapter;

},{"../utils/logger":31,"./Adapter":12}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultAdapter = void 0;
const Adapter_1 = require("./Adapter");
const logger_1 = require("../utils/logger");
const logger = (0, logger_1.createLogger)("DefaultAdapter");
class DefaultAdapter {
    /*eslint-disable @typescript-eslint/no-explicit-any */
    *adapt(rtcStats) {
        if (!rtcStats || !rtcStats.values || typeof rtcStats.values !== 'function') {
            logger.warn(`not rtcStats object is provided to the adapter: `, rtcStats);
            return;
        }
        for (const rtcStatValue of rtcStats.values()) {
            const rawType = rtcStatValue.type;
            if (!rawType || typeof rawType !== 'string')
                continue;
            yield (0, Adapter_1.castStats)(rawType, rtcStatValue);
        }
    }
}
exports.DefaultAdapter = DefaultAdapter;

},{"../utils/logger":31,"./Adapter":12}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Firefox94Adapter = void 0;
const Adapter_1 = require("./Adapter");
const logger_1 = require("../utils/logger");
const logger = (0, logger_1.createLogger)("Safari14Adapter");
class Firefox94Adapter {
    /*eslint-disable @typescript-eslint/no-explicit-any */
    *adapt(rtcStats) {
        if (!rtcStats || !rtcStats.values || typeof rtcStats.values !== 'function') {
            logger.warn(`not rtcStats object is provided to the adapter: `, rtcStats);
            return;
        }
        for (const rtcStatValue of rtcStats.values()) {
            const rawType = rtcStatValue.type;
            if (!rtcStatValue)
                continue;
            if (!rawType || typeof rawType !== 'string')
                continue;
            if (rawType === "inbound-rtp" ||
                rawType === "outbound-rtp" ||
                rawType === "remote-inbound-rtp" ||
                rawType === "remote-outbound-rtp") {
                if (rtcStatValue.mediaType && !rtcStatValue.kind) {
                    rtcStatValue.kind = rtcStatValue.mediaType;
                    delete rtcStatValue.mediaType;
                }
            }
            yield (0, Adapter_1.castStats)(rawType, rtcStatValue);
        }
    }
}
exports.Firefox94Adapter = Firefox94Adapter;

},{"../utils/logger":31,"./Adapter":12}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Safari14Adapter = void 0;
const Adapter_1 = require("./Adapter");
const logger_1 = require("../utils/logger");
const logger = (0, logger_1.createLogger)("Safari14Adapter");
class Safari14Adapter {
    /*eslint-disable @typescript-eslint/no-explicit-any */
    *adapt(rtcStats) {
        if (!rtcStats || !rtcStats.values || typeof rtcStats.values !== 'function') {
            logger.warn(`not rtcStats object is provided to the adapter: `, rtcStats);
            return;
        }
        const tracks = new Map();
        for (const rtcStatValue of rtcStats.values()) {
            if (rtcStatValue && rtcStatValue.type === "track") {
                tracks.set(rtcStatValue.id, rtcStatValue);
            }
        }
        const senders = new Map();
        const receivers = new Map();
        for (let rtcStatValue of rtcStats.values()) {
            const rawType = rtcStatValue.type;
            if (!rtcStatValue)
                continue;
            if (!rawType || typeof rawType !== 'string')
                continue;
            if (rawType === "track")
                continue;
            if (rawType === "inbound-rtp" || rawType === "outbound-rtp") {
                if (rtcStatValue.trackId) {
                    const trackStats = tracks.get(rtcStatValue.trackId);
                    if (trackStats) {
                        rtcStatValue = {
                            ...trackStats,
                            ...rtcStatValue,
                        };
                        if (rawType === "outbound-rtp") {
                            senders.set(trackStats.id, trackStats);
                        }
                        else if (rawType === "inbound-rtp") {
                            receivers.set(trackStats.id, trackStats);
                        }
                    }
                }
                if (rawType === "inbound-rtp" && rtcStatValue.trackId && !rtcStatValue.receiverId) {
                    rtcStatValue.receiverId = rtcStatValue.trackId;
                }
                if (rawType === "outbound-rtp" && rtcStatValue.trackId && !rtcStatValue.senderId) {
                    rtcStatValue.senderId = rtcStatValue.trackId;
                }
            }
            yield (0, Adapter_1.castStats)(rawType, rtcStatValue);
        }
        for (const trackStats of senders.values()) {
            yield (0, Adapter_1.castStats)("sender", trackStats);
        }
        for (const trackStats of receivers.values()) {
            yield (0, Adapter_1.castStats)("receiver", trackStats);
        }
    }
}
exports.Safari14Adapter = Safari14Adapter;

},{"../utils/logger":31,"./Adapter":12}],17:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCodec = void 0;
const FacadedCodec_1 = require("./FacadedCodec");
const JsonCodec_1 = require("./JsonCodec");
const ProtobufCodec_1 = require("./ProtobufCodec");
const TextCodec_1 = require("./TextCodec");
const schemas_1 = require("@observertc/schemas");
const protobufjs = __importStar(require("protobufjs/light"));
function createCodec(providedConfig) {
    const config = providedConfig !== null && providedConfig !== void 0 ? providedConfig : "json";
    if (config === "json") {
        const strCodec = JsonCodec_1.JsonCodec.create();
        const textCodec = TextCodec_1.TextCodec.create();
        const result = FacadedCodec_1.FacadedCodec.wrap(strCodec).then(textCodec);
        return result;
    }
    if (config === "protobuf") {
        const root = protobufjs.Root.fromJSON(schemas_1.ProtobufSamplesJson);
        const messageSchema = root.lookupType("org.observertc.schemas.protobuf.Samples");
        const result = ProtobufCodec_1.ProtobufCodec.create({
            validate: false,
            messageSchema,
        });
        return result;
    }
    throw new Error(`Unrecognized format config: ${config}`);
}
exports.createCodec = createCodec;

},{"./FacadedCodec":18,"./JsonCodec":19,"./ProtobufCodec":20,"./TextCodec":21,"@observertc/schemas":33,"protobufjs/light":90}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FacadedCodec = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
class FacadedCodec {
    constructor(firstEncoder) {
        this._codec = firstEncoder;
    }
    /*eslint-disable @typescript-eslint/no-explicit-any */
    static wrap(codec) {
        const facadedCodec = new FacadedCodec(codec);
        return facadedCodec;
    }
    encode(data) {
        return this._codec.encode(data);
    }
    decode(data) {
        return this._codec.decode(data);
    }
    then(nextCodec) {
        const actualCodec = this._codec;
        return FacadedCodec.wrap({
            encode(data) {
                const encodedValue = actualCodec.encode(data);
                return nextCodec.encode(encodedValue);
            },
            decode(data) {
                const decodedValue = nextCodec.decode(data);
                return actualCodec.decode(decodedValue);
            }
        });
    }
}
exports.FacadedCodec = FacadedCodec;

},{}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonCodec = void 0;
const supplyDefaultConfig = () => {
    const result = {};
    return result;
};
/* eslint-disable @typescript-eslint/no-explicit-any */
class JsonCodec {
    constructor(config) {
        this._config = config;
    }
    static create(config) {
        const defaultConfig = supplyDefaultConfig();
        const appliedConfig = Object.assign(defaultConfig, config);
        return new JsonCodec(appliedConfig);
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    encode(data) {
        if (this._config.space) {
            return JSON.stringify(data, undefined, this._config.space);
        }
        return JSON.stringify(data);
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    decode(data) {
        return JSON.parse(data);
    }
}
exports.JsonCodec = JsonCodec;

},{}],20:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtobufCodec = void 0;
const schemas_1 = require("@observertc/schemas");
const protobufjs = __importStar(require("protobufjs/light"));
const supplyDefaultConfig = () => {
    const root = protobufjs.Root.fromJSON(schemas_1.ProtobufSamplesJson);
    const messageSchema = root.lookupType("org.observertc.schemas.protobuf.Samples");
    const result = {
        validate: false,
        messageSchema,
    };
    return result;
};
/* eslint-disable @typescript-eslint/no-explicit-any */
class ProtobufCodec {
    constructor(config) {
        this._config = config;
    }
    static create(config) {
        const defaultConfig = supplyDefaultConfig();
        const appliedConfig = Object.assign(defaultConfig, config);
        return new ProtobufCodec(appliedConfig);
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    encode(data) {
        if (this._config.validate) {
            const errMsg = this._config.messageSchema.verify(data);
            if (errMsg)
                throw Error(errMsg);
        }
        const message = this._config.messageSchema.create(data);
        const buffer = this._config.messageSchema.encode(message).finish();
        return buffer;
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    decode(data) {
        const message = this._config.messageSchema.decode(data);
        const result = this._config.messageSchema.toObject(message);
        return result;
    }
}
exports.ProtobufCodec = ProtobufCodec;

},{"@observertc/schemas":33,"protobufjs/light":90}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextCodec = void 0;
const defaultConfig = {};
class TextCodec {
    constructor(config) {
        this._config = config;
        this._encoder = new TextEncoder();
        this._decoder = new TextDecoder();
    }
    static create(config) {
        const appliedConfig = Object.assign(defaultConfig, config);
        return new TextCodec(appliedConfig);
    }
    encode(data) {
        return this._encoder.encode(data);
    }
    decode(data) {
        return this._decoder.decode(data);
    }
}
exports.TextCodec = TextCodec;

},{}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PeerConnectionEntryImpl = void 0;
const StatsVisitor_1 = require("../utils/StatsVisitor");
const hash_1 = require("../utils/hash");
class PeerConnectionEntryImpl {
    constructor(config) {
        this._ssrcsToInboundRtpPair = new Map();
        this._ssrcsToOutboundRtpPair = new Map();
        this._codecs = new Map();
        this._inboundRtps = new Map();
        this._outboundRtps = new Map();
        this._remoteInboundRtps = new Map();
        this._remoteOutboundRtps = new Map();
        this._mediaSources = new Map();
        this._contributingSources = new Map();
        this._dataChannels = new Map();
        this._transceivers = new Map();
        this._senders = new Map();
        this._receivers = new Map();
        this._transports = new Map();
        this._sctpTransports = new Map();
        this._iceCandidatePairs = new Map();
        this._localCandidates = new Map();
        this._remoteCandidates = new Map();
        this._certificates = new Map();
        this._iceServers = new Map();
        this.Visitor = class extends StatsVisitor_1.StatsVisitor {
            constructor(outer) {
                super();
                this.touched = false;
                this.created = Date.now();
                this._pc = outer;
            }
            visit(statsEntry) {
                super.visit(statsEntry);
                this.touched = true;
            }
            visitCodec(stats) {
                const pc = this._pc;
                const entries = pc._codecs;
                const entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (entry) {
                    entry.touched = this.created;
                    if (entry.hashCode === hashCode) {
                        return;
                    }
                    entry.hashCode = hashCode;
                    entry.updated = this.created;
                    entry.stats = stats;
                    return;
                }
                const newEntry = {
                    id: stats.id,
                    getPeerConnection: () => {
                        return pc;
                    },
                    stats,
                    created: this.created,
                    updated: this.created,
                    touched: this.created,
                    hashCode,
                    getTransport: () => {
                        const transportId = newEntry.stats.transportId;
                        return pc._transports.get(transportId);
                    },
                };
                entries.set(stats.id, newEntry);
            }
            visitMediaSource(stats) {
                const pc = this._pc;
                const entries = pc._mediaSources;
                const entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (entry) {
                    entry.touched = this.created;
                    if (entry.hashCode === hashCode) {
                        return;
                    }
                    entry.updated = this.created;
                    entry.stats = stats;
                    return;
                }
                const newEntry = {
                    id: stats.id,
                    getPeerConnection: () => {
                        return pc;
                    },
                    stats,
                    hashCode,
                    touched: this.created,
                    created: this.created,
                    updated: this.created,
                };
                entries.set(stats.id, newEntry);
            }
            visitInboundRtp(stats) {
                const pc = this._pc;
                const entries = pc._inboundRtps;
                const entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (!entry) {
                    const ssrcsToInboundRtpPairs = this._pc._ssrcsToInboundRtpPair;
                    const remoteOutboundRtps = this._pc._remoteOutboundRtps;
                    const newEntry = {
                        id: stats.id,
                        getPeerConnection: () => {
                            return pc;
                        },
                        stats,
                        hashCode,
                        touched: this.created,
                        created: this.created,
                        updated: this.created,
                        getSsrc: () => {
                            return newEntry.stats.ssrc;
                        },
                        getTrackId: () => {
                            var _a;
                            const { stats: receiverStats } = (_a = newEntry.getReceiver()) !== null && _a !== void 0 ? _a : {};
                            return receiverStats === null || receiverStats === void 0 ? void 0 : receiverStats.trackIdentifier;
                        },
                        getReceiver: () => {
                            const receiverId = newEntry.stats.receiverId;
                            return pc._receivers.get(receiverId);
                        },
                        getCodec: () => {
                            const codecId = newEntry.stats.codecId;
                            if (!codecId)
                                return undefined;
                            return pc._codecs.get(codecId);
                        },
                        getTransport: () => {
                            const transportId = newEntry.stats.transportId;
                            if (!transportId)
                                return undefined;
                            return pc._transports.get(transportId);
                        },
                        getRemoteOutboundRtp: () => {
                            const ssrc = newEntry.getSsrc();
                            if (!ssrc)
                                return undefined;
                            const inboundRtpPair = ssrcsToInboundRtpPairs.get(ssrc);
                            if (!inboundRtpPair || !inboundRtpPair.remoteOutboundRtpId)
                                return undefined;
                            return remoteOutboundRtps.get(inboundRtpPair.remoteOutboundRtpId);
                        }
                    };
                    entries.set(stats.id, newEntry);
                    const ssrc = newEntry.getSsrc();
                    if (ssrc) {
                        const ssrcsToInboundRtpPair = this._pc._ssrcsToInboundRtpPair;
                        let inboundRtpPair = ssrcsToInboundRtpPair.get(ssrc);
                        if (!inboundRtpPair) {
                            inboundRtpPair = {};
                            ssrcsToInboundRtpPair.set(ssrc, inboundRtpPair);
                        }
                        inboundRtpPair.inboundRtpId = newEntry.stats.id;
                    }
                }
                else {
                    entry.touched = this.created;
                    if (entry.hashCode !== hashCode) {
                        entry.updated = this.created;
                        entry.stats = stats;
                    }
                }
            }
            visitOutboundRtp(stats) {
                const pc = this._pc;
                const entries = pc._outboundRtps;
                let entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (!entry) {
                    const ssrcsToOutboundRtpPairs = this._pc._ssrcsToOutboundRtpPair;
                    const remoteInboundRtps = this._pc._remoteInboundRtps;
                    const newEntry = {
                        id: stats.id,
                        getPeerConnection: () => {
                            return pc;
                        },
                        stats,
                        hashCode,
                        touched: this.created,
                        created: this.created,
                        updated: this.created,
                        getSsrc: () => {
                            return newEntry.stats.ssrc;
                        },
                        getTrackId: () => {
                            var _a, _b;
                            const { stats: senderStats } = (_a = newEntry.getSender()) !== null && _a !== void 0 ? _a : {};
                            if (senderStats === null || senderStats === void 0 ? void 0 : senderStats.trackIdentifier) {
                                return senderStats.trackIdentifier;
                            }
                            const { stats: mediaSourceStats } = (_b = newEntry.getMediaSource()) !== null && _b !== void 0 ? _b : {};
                            return mediaSourceStats === null || mediaSourceStats === void 0 ? void 0 : mediaSourceStats.trackIdentifier;
                        },
                        getSender: () => {
                            const senderId = newEntry.stats.senderId;
                            if (!senderId)
                                return undefined;
                            return pc._senders.get(senderId);
                        },
                        getCodec: () => {
                            const codecId = newEntry.stats.codecId;
                            if (!codecId)
                                return undefined;
                            return pc._codecs.get(codecId);
                        },
                        getTransport: () => {
                            const transportId = newEntry.stats.transportId;
                            if (!transportId)
                                return undefined;
                            return pc._transports.get(transportId);
                        },
                        getMediaSource: () => {
                            const mediaSourceId = newEntry.stats.mediaSourceId;
                            if (!mediaSourceId)
                                return undefined;
                            return pc._mediaSources.get(mediaSourceId);
                        },
                        getRemoteInboundRtp: () => {
                            const ssrc = newEntry.getSsrc();
                            if (!ssrc)
                                return undefined;
                            const outboundRtpPair = ssrcsToOutboundRtpPairs.get(ssrc);
                            if (!outboundRtpPair || !outboundRtpPair.remoteInboundRtpId)
                                return undefined;
                            return remoteInboundRtps.get(outboundRtpPair.remoteInboundRtpId);
                        }
                    };
                    entries.set(stats.id, newEntry);
                    entry = newEntry;
                }
                else {
                    entry.touched = this.created;
                    if (entry.hashCode !== hashCode) {
                        entry.updated = this.created;
                        entry.stats = stats;
                    }
                }
                const ssrc = entry.getSsrc();
                if (ssrc) {
                    const ssrcsToOutboundRtpPair = this._pc._ssrcsToOutboundRtpPair;
                    let outboundRtpPair = ssrcsToOutboundRtpPair.get(ssrc);
                    if (!outboundRtpPair) {
                        outboundRtpPair = {};
                        ssrcsToOutboundRtpPair.set(ssrc, outboundRtpPair);
                    }
                    outboundRtpPair.outboundRtpId = entry.stats.id;
                }
            }
            visitRemoteInboundRtp(stats) {
                const pc = this._pc;
                const entries = pc._remoteInboundRtps;
                const entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (!entry) {
                    const ssrcsToOutboundRtpPair = this._pc._ssrcsToOutboundRtpPair;
                    const outboundRtps = this._pc._outboundRtps;
                    const newEntry = {
                        id: stats.id,
                        getPeerConnection: () => {
                            return pc;
                        },
                        stats,
                        hashCode,
                        touched: this.created,
                        created: this.created,
                        updated: this.created,
                        getSsrc: () => {
                            return newEntry.stats.ssrc;
                        },
                        getCodec: () => {
                            const codecId = newEntry.stats.codecId;
                            if (!codecId)
                                return undefined;
                            return pc._codecs.get(codecId);
                        },
                        getTransport: () => {
                            const transportId = newEntry.stats.transportId;
                            if (!transportId)
                                return undefined;
                            return pc._transports.get(transportId);
                        },
                        getOutboundRtp: () => {
                            const ssrc = newEntry.getSsrc();
                            if (!ssrc)
                                return undefined;
                            const outboundRtpPair = ssrcsToOutboundRtpPair.get(ssrc);
                            if (!outboundRtpPair || !outboundRtpPair.outboundRtpId)
                                return undefined;
                            return outboundRtps.get(outboundRtpPair.outboundRtpId);
                        }
                    };
                    entries.set(stats.id, newEntry);
                    const ssrc = newEntry.getSsrc();
                    if (ssrc) {
                        const ssrcsToOutboundRtpPair = this._pc._ssrcsToOutboundRtpPair;
                        let outboundRtpPair = ssrcsToOutboundRtpPair.get(ssrc);
                        if (!outboundRtpPair) {
                            outboundRtpPair = {};
                            ssrcsToOutboundRtpPair.set(ssrc, outboundRtpPair);
                        }
                        outboundRtpPair.remoteInboundRtpId = newEntry.stats.id;
                    }
                }
                else {
                    entry.touched = this.created;
                    if (entry.hashCode !== hashCode) {
                        entry.updated = this.created;
                        entry.stats = stats;
                    }
                }
            }
            visitRemoteOutboundRtp(stats) {
                const pc = this._pc;
                const entries = pc._remoteOutboundRtps;
                const entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (!entry) {
                    const ssrcsToInboundRtpPair = this._pc._ssrcsToInboundRtpPair;
                    const inboundRtps = this._pc._inboundRtps;
                    const newEntry = {
                        id: stats.id,
                        getPeerConnection: () => {
                            return pc;
                        },
                        stats,
                        hashCode,
                        touched: this.created,
                        created: this.created,
                        updated: this.created,
                        getSsrc: () => {
                            return newEntry.stats.ssrc;
                        },
                        getCodec: () => {
                            const codecId = newEntry.stats.codecId;
                            if (!codecId)
                                return undefined;
                            return pc._codecs.get(codecId);
                        },
                        getTransport: () => {
                            const transportId = newEntry.stats.transportId;
                            if (!transportId)
                                return undefined;
                            return pc._transports.get(transportId);
                        },
                        getInboundRtp: () => {
                            const ssrc = newEntry.getSsrc();
                            if (!ssrc)
                                return undefined;
                            const inboundRtpPair = ssrcsToInboundRtpPair.get(ssrc);
                            if (!inboundRtpPair || !inboundRtpPair.inboundRtpId)
                                return undefined;
                            return inboundRtps.get(inboundRtpPair.inboundRtpId);
                        }
                    };
                    entries.set(stats.id, newEntry);
                    const ssrc = newEntry.getSsrc();
                    if (ssrc) {
                        let inboundRtpPair = ssrcsToInboundRtpPair.get(ssrc);
                        if (!inboundRtpPair) {
                            inboundRtpPair = {};
                            ssrcsToInboundRtpPair.set(ssrc, inboundRtpPair);
                        }
                        inboundRtpPair.remoteOutboundRtpId = newEntry.stats.id;
                    }
                }
                else {
                    entry.touched = this.created;
                    if (hashCode !== entry.hashCode) {
                        entry.updated = this.created;
                        entry.stats = stats;
                    }
                }
            }
            visitContributingSource(stats) {
                const pc = this._pc;
                const entries = pc._contributingSources;
                const entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (entry) {
                    entry.touched = this.created;
                    if (entry.hashCode === hashCode) {
                        return;
                    }
                    entry.updated = this.created;
                    entry.stats = stats;
                    return;
                }
                const newEntry = {
                    id: stats.id,
                    getPeerConnection: () => {
                        return pc;
                    },
                    stats,
                    hashCode,
                    touched: this.created,
                    created: this.created,
                    updated: this.created,
                    getInboundRtp: () => {
                        const inboundRtpId = newEntry.stats.inboundRtpStreamId;
                        return pc._inboundRtps.get(inboundRtpId);
                    }
                };
                entries.set(stats.id, newEntry);
            }
            visitPeerConnection(stats) {
                const pc = this._pc;
                pc._stats = stats;
                pc._updated = this.created;
            }
            visitDataChannel(stats) {
                const pc = this._pc;
                const entries = pc._dataChannels;
                const entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (entry) {
                    entry.touched = this.created;
                    if (entry.hashCode === hashCode) {
                        return;
                    }
                    entry.updated = this.created;
                    entry.stats = stats;
                    return;
                }
                const newEntry = {
                    id: stats.id,
                    getPeerConnection: () => {
                        return pc;
                    },
                    stats,
                    hashCode,
                    touched: this.created,
                    created: this.created,
                    updated: this.created,
                };
                entries.set(stats.id, newEntry);
            }
            visitTransceiver(stats) {
                const pc = this._pc;
                const entries = pc._transceivers;
                const entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (entry) {
                    entry.touched = this.created;
                    if (entry.hashCode === hashCode) {
                        return;
                    }
                    entry.updated = this.created;
                    entry.stats = stats;
                    return;
                }
                const newEntry = {
                    id: stats.id,
                    getPeerConnection: () => {
                        return pc;
                    },
                    stats,
                    hashCode,
                    touched: this.created,
                    created: this.created,
                    updated: this.created,
                    getSender: () => {
                        const senderId = newEntry.stats.senderId;
                        return pc._senders.get(senderId);
                    },
                    getReceiver: () => {
                        const receiverId = newEntry.stats.senderId;
                        return pc._receivers.get(receiverId);
                    },
                };
                entries.set(stats.id, newEntry);
            }
            visitSender(stats) {
                const pc = this._pc;
                const entries = pc._senders;
                const entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (entry) {
                    entry.touched = this.created;
                    if (entry.hashCode === hashCode) {
                        return;
                    }
                    entry.updated = this.created;
                    entry.stats = stats;
                    return;
                }
                const newEntry = {
                    id: stats.id,
                    getPeerConnection: () => {
                        return pc;
                    },
                    stats,
                    hashCode,
                    touched: this.created,
                    created: this.created,
                    updated: this.created,
                    getMediaSource: () => {
                        const mediaSourceId = newEntry.stats.mediaSourceId;
                        if (!mediaSourceId)
                            return undefined;
                        return pc._mediaSources.get(mediaSourceId);
                    }
                };
                entries.set(stats.id, newEntry);
            }
            visitReceiver(stats) {
                const pc = this._pc;
                const entries = pc._receivers;
                const entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (entry) {
                    entry.touched = this.created;
                    if (entry.hashCode === hashCode) {
                        return;
                    }
                    entry.updated = this.created;
                    entry.stats = stats;
                    return;
                }
                const newEntry = {
                    id: stats.id,
                    getPeerConnection: () => {
                        return pc;
                    },
                    stats,
                    hashCode,
                    touched: this.created,
                    created: this.created,
                    updated: this.created,
                };
                entries.set(stats.id, newEntry);
            }
            visitTransport(stats) {
                const pc = this._pc;
                const entries = pc._transports;
                const entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (entry) {
                    entry.touched = this.created;
                    if (entry.hashCode === hashCode) {
                        return;
                    }
                    entry.updated = this.created;
                    entry.stats = stats;
                    return;
                }
                const newEntry = {
                    id: stats.id,
                    getPeerConnection: () => {
                        return pc;
                    },
                    stats,
                    hashCode,
                    touched: this.created,
                    created: this.created,
                    updated: this.created,
                    getSelectedIceCandidatePair: () => {
                        const candidatePairId = newEntry.stats.selectedCandidatePairId;
                        if (!candidatePairId)
                            return undefined;
                        return pc._iceCandidatePairs.get(candidatePairId);
                    },
                    getLocalCertificate: () => {
                        const certificateId = newEntry.stats.localCertificateId;
                        if (!certificateId)
                            return undefined;
                        return pc._certificates.get(certificateId);
                    },
                    getRemoteCertificate: () => {
                        const certificateId = newEntry.stats.remoteCertificateId;
                        if (!certificateId)
                            return undefined;
                        return pc._certificates.get(certificateId);
                    },
                    getRtcpTransport: () => {
                        const rtcpTransportId = newEntry.stats.rtcpTransportStatsId;
                        if (!rtcpTransportId)
                            return undefined;
                        return pc._transports.get(rtcpTransportId);
                    },
                };
                entries.set(stats.id, newEntry);
            }
            visitSctpTransport(stats) {
                const pc = this._pc;
                const entries = pc._sctpTransports;
                const entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (entry) {
                    entry.touched = this.created;
                    if (entry.hashCode === hashCode) {
                        return;
                    }
                    entry.updated = this.created;
                    entry.stats = stats;
                    return;
                }
                const newEntry = {
                    id: stats.id,
                    getPeerConnection: () => {
                        return pc;
                    },
                    stats,
                    hashCode,
                    touched: this.created,
                    created: this.created,
                    updated: this.created,
                    getTransport: () => {
                        const transportId = newEntry.stats.transportId;
                        if (!transportId)
                            return undefined;
                        return pc._transports.get(transportId);
                    }
                };
                entries.set(stats.id, newEntry);
            }
            visitIceCandidatePair(stats) {
                const pc = this._pc;
                const entries = pc._iceCandidatePairs;
                const entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (entry) {
                    entry.touched = this.created;
                    if (entry.hashCode === hashCode) {
                        return;
                    }
                    entry.updated = this.created;
                    entry.stats = stats;
                    return;
                }
                const newEntry = {
                    id: stats.id,
                    getPeerConnection: () => {
                        return pc;
                    },
                    stats,
                    hashCode,
                    touched: this.created,
                    created: this.created,
                    updated: this.created,
                    getTransport: () => {
                        const transportId = newEntry.stats.transportId;
                        if (!transportId)
                            return undefined;
                        return pc._transports.get(transportId);
                    },
                    getLocalCandidate: () => {
                        const candidateId = newEntry.stats.localCandidateId;
                        if (!candidateId)
                            return undefined;
                        return pc._localCandidates.get(candidateId);
                    },
                    getRemoteCandidate: () => {
                        const candidateId = newEntry.stats.remoteCandidateId;
                        if (!candidateId)
                            return undefined;
                        return pc._remoteCandidates.get(candidateId);
                    },
                };
                entries.set(stats.id, newEntry);
            }
            visitLocalCandidate(stats) {
                const pc = this._pc;
                const entries = pc._localCandidates;
                const entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (entry) {
                    entry.touched = this.created;
                    if (entry.hashCode === hashCode) {
                        return;
                    }
                    entry.updated = this.created;
                    entry.stats = stats;
                    return;
                }
                const newEntry = {
                    id: stats.id,
                    getPeerConnection: () => {
                        return pc;
                    },
                    stats,
                    hashCode,
                    touched: this.created,
                    created: this.created,
                    updated: this.created,
                    getTransport: () => {
                        const transportId = newEntry.stats.transportId;
                        if (!transportId)
                            return undefined;
                        return pc._transports.get(transportId);
                    }
                };
                entries.set(stats.id, newEntry);
            }
            visitRemoteCandidate(stats) {
                const pc = this._pc;
                const entries = pc._remoteCandidates;
                const entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (entry) {
                    entry.touched = this.created;
                    if (entry.hashCode === hashCode) {
                        return;
                    }
                    entry.updated = this.created;
                    entry.stats = stats;
                    return;
                }
                const newEntry = {
                    id: stats.id,
                    getPeerConnection: () => {
                        return pc;
                    },
                    stats,
                    hashCode,
                    touched: this.created,
                    created: this.created,
                    updated: this.created,
                    getTransport: () => {
                        const transportId = newEntry.stats.transportId;
                        if (!transportId)
                            return undefined;
                        return pc._transports.get(transportId);
                    }
                };
                entries.set(stats.id, newEntry);
            }
            visitCertificate(stats) {
                const pc = this._pc;
                const entries = pc._certificates;
                const entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (entry) {
                    entry.touched = this.created;
                    if (entry.hashCode === hashCode) {
                        return;
                    }
                    entry.updated = this.created;
                    entry.stats = stats;
                    return;
                }
                const newEntry = {
                    id: stats.id,
                    getPeerConnection: () => {
                        return pc;
                    },
                    stats,
                    hashCode,
                    touched: this.created,
                    created: this.created,
                    updated: this.created,
                };
                entries.set(stats.id, newEntry);
            }
            visitIceServer(stats) {
                const pc = this._pc;
                const entries = pc._iceServers;
                let entry = entries.get(stats.id);
                const hashCode = (0, hash_1.hash)(stats);
                if (entry) {
                    entry.touched = this.created;
                    if (entry.hashCode === hashCode) {
                        return;
                    }
                    entry.updated = this.created;
                    entry.stats = stats;
                }
                else {
                    entry = {
                        id: stats.id,
                        getPeerConnection: () => {
                            return pc;
                        },
                        stats,
                        hashCode,
                        touched: this.created,
                        created: this.created,
                        updated: this.created,
                    };
                    entries.set(stats.id, entry);
                }
            }
        };
        this._config = config;
        const now = Date.now();
        this.created = now;
        this._updated = now;
        this._touched = now;
    }
    static create(config) {
        const result = new PeerConnectionEntryImpl(config);
        return result;
    }
    get collectorId() {
        return this._config.collectorId;
    }
    get collectorLabel() {
        return this._config.collectorLabel;
    }
    *trackIds() {
        for (const receiver of this._receivers.values()) {
            if (!receiver.stats)
                continue;
            const { trackIdentifier } = receiver.stats;
            if (!trackIdentifier)
                continue;
            yield trackIdentifier;
        }
        for (const sender of this._senders.values()) {
            if (!sender.stats)
                continue;
            const { trackIdentifier } = sender.stats;
            if (!trackIdentifier)
                continue;
            yield trackIdentifier;
        }
        for (const mediaSource of this._mediaSources.values()) {
            if (!mediaSource.stats)
                continue;
            const { trackIdentifier } = mediaSource.stats;
            if (!trackIdentifier)
                continue;
            yield trackIdentifier;
        }
    }
    receivers() {
        return this._receivers.values();
    }
    mediaSources() {
        return this._mediaSources.values();
    }
    outboundRtps() {
        return this._outboundRtps.values();
    }
    remoteInboundRtps() {
        return this._remoteInboundRtps.values();
    }
    remoteOutboundRtps() {
        return this._remoteOutboundRtps.values();
    }
    contributingSources() {
        return this._contributingSources.values();
    }
    dataChannels() {
        return this._dataChannels.values();
    }
    transceivers() {
        return this._transceivers.values();
    }
    senders() {
        return this._senders.values();
    }
    transports() {
        return this._transports.values();
    }
    sctpTransports() {
        return this._sctpTransports.values();
    }
    iceCandidatePairs() {
        return this._iceCandidatePairs.values();
    }
    localCandidates() {
        return this._localCandidates.values();
    }
    remoteCandidates() {
        return this._remoteCandidates.values();
    }
    certificates() {
        return this._certificates.values();
    }
    iceServers() {
        return this._iceServers.values();
    }
    get stats() {
        return this._stats;
    }
    get id() {
        var _a;
        return (_a = this._stats) === null || _a === void 0 ? void 0 : _a.id;
    }
    get updated() {
        return this._updated;
    }
    get touched() {
        return this._touched;
    }
    codecs() {
        return this._codecs.values();
    }
    inboundRtps() {
        return this._inboundRtps.values();
    }
    update(statsEntry) {
        const visitor = new this.Visitor(this);
        visitor.visit(statsEntry);
        if (visitor.touched) {
            this._touched = visitor.created;
        }
    }
    _getEntryMaps() {
        const result = [
            this._codecs,
            this._inboundRtps,
            this._outboundRtps,
            this._remoteInboundRtps,
            this._remoteOutboundRtps,
            this._mediaSources,
            this._contributingSources,
            this._dataChannels,
            this._transceivers,
            this._senders,
            this._receivers,
            this._transports,
            this._sctpTransports,
            this._iceCandidatePairs,
            this._localCandidates,
            this._remoteCandidates,
            this._certificates,
            this._iceServers
        ];
        return result;
    }
    trim(expirationThresholdInMs) {
        const maps = this._getEntryMaps();
        for (const map of maps) {
            const toRemove = [];
            for (const statsEntry of map.values()) {
                if (statsEntry.touched < expirationThresholdInMs) {
                    toRemove.push(statsEntry.id);
                }
            }
            for (const statsEntryId of toRemove) {
                map.delete(statsEntryId);
            }
        }
    }
    clear() {
        const maps = this._getEntryMaps();
        for (const map of maps) {
            map.clear();
        }
    }
}
exports.PeerConnectionEntryImpl = PeerConnectionEntryImpl;

},{"../utils/StatsVisitor":27,"../utils/hash":30}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatsStorage = void 0;
const PeerConnectionEntryImpl_1 = require("./PeerConnectionEntryImpl");
const logger_1 = require("../utils/logger");
const logger = (0, logger_1.createLogger)("StatsStorage");
class StatsStorage {
    constructor() {
        this._peerConnections = new Map();
    }
    accept(collectorId, statsEntry) {
        const pcEntry = this._peerConnections.get(collectorId);
        if (!pcEntry) {
            logger.warn(`PeerConnectionEntry is not registered for collectorId ${collectorId}`);
            return;
        }
        pcEntry.update(statsEntry);
    }
    trim(expirationThresholdInMs) {
        for (const pcEntry of this._peerConnections.values()) {
            pcEntry.trim(expirationThresholdInMs);
        }
    }
    clear() {
        for (const pcEntry of this._peerConnections.values()) {
            pcEntry.clear();
        }
    }
    register(collectorId, collectorLabel) {
        const pcEntry = PeerConnectionEntryImpl_1.PeerConnectionEntryImpl.create({
            collectorId,
            collectorLabel,
        });
        this._peerConnections.set(collectorId, pcEntry);
    }
    unregister(collectorId) {
        if (!this._peerConnections.delete(collectorId)) {
            logger.warn(`Peer Connection Entry does not exist for collectorId ${collectorId}`);
        }
    }
    *peerConnections() {
        for (const pcEntry of this._peerConnections.values()) {
            yield pcEntry;
        }
    }
    *receivers() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.receivers()) {
                yield entry;
            }
        }
    }
    *mediaSources() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.mediaSources()) {
                yield entry;
            }
        }
    }
    *outboundRtps() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.outboundRtps()) {
                yield entry;
            }
        }
    }
    *remoteInboundRtps() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.remoteInboundRtps()) {
                yield entry;
            }
        }
    }
    *remoteOutboundRtps() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.remoteOutboundRtps()) {
                yield entry;
            }
        }
    }
    *contributingSources() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.contributingSources()) {
                yield entry;
            }
        }
    }
    *dataChannels() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.dataChannels()) {
                yield entry;
            }
        }
    }
    *transceivers() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.transceivers()) {
                yield entry;
            }
        }
    }
    *senders() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.senders()) {
                yield entry;
            }
        }
    }
    *transports() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.transports()) {
                yield entry;
            }
        }
    }
    *sctpTransports() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.sctpTransports()) {
                yield entry;
            }
        }
    }
    *iceCandidatePairs() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.iceCandidatePairs()) {
                yield entry;
            }
        }
    }
    *localCandidates() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.localCandidates()) {
                yield entry;
            }
        }
    }
    *remoteCandidates() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.remoteCandidates()) {
                yield entry;
            }
        }
    }
    *certificates() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.certificates()) {
                yield entry;
            }
        }
    }
    *iceServers() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.iceServers()) {
                yield entry;
            }
        }
    }
    *codecs() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.codecs()) {
                yield entry;
            }
        }
    }
    *inboundRtps() {
        for (const pcEntry of this._peerConnections.values()) {
            for (const entry of pcEntry.inboundRtps()) {
                yield entry;
            }
        }
    }
}
exports.StatsStorage = StatsStorage;

},{"../utils/logger":31,"./PeerConnectionEntryImpl":22}],24:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientMonitor = void 0;
exports.ClientMonitor = __importStar(require("./ClientMonitor"));

},{"./ClientMonitor":5}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebsocketTransport = void 0;
const events_1 = require("events");
const logger_1 = require("../utils/logger");
const logger = (0, logger_1.createLogger)("WebsocketTransport");
const supplyDefaultConfig = () => {
    const defaultConfig = {
        urls: ["cannot be this"],
        maxRetries: 3
    };
    return defaultConfig;
};
const ON_RECEIVED_EVENT_NAME = "onReceived";
class WebsocketTransport {
    constructor(config) {
        this._closed = false;
        this._emitter = new events_1.EventEmitter();
        this._sendingCounter = 0;
        if (typeof WebSocket === 'undefined') {
            throw new Error(`No Websocket class has found in global namespace`);
        }
        this._config = config;
    }
    static create(config) {
        const appliedConfig = Object.assign(supplyDefaultConfig(), config);
        const result = new WebsocketTransport(appliedConfig);
        logger.debug(`Created`, appliedConfig);
        return result;
    }
    onReceived(listener) {
        this._emitter.on(ON_RECEIVED_EVENT_NAME, listener);
        return this;
    }
    offReceived(listener) {
        this._emitter.off(ON_RECEIVED_EVENT_NAME, listener);
        return this;
    }
    get closed() {
        return this._closed;
    }
    get connected() {
        return !!this._ws;
    }
    /**
     * Closes the WebSocket connection or connection attempt, if any. If the connection is already
     * CLOSED, this method does nothing
     */
    close() {
        if (this._closed) {
            logger.warn(`Attempted to close twice`);
            return;
        }
        try {
            if (this._ws) {
                this._ws.close();
            }
            if (this._cancelTimer) {
                this._cancelTimer();
            }
            this._sent = undefined;
        }
        finally {
            this._closed = true;
            logger.info(`Closed`);
        }
    }
    /**
     * Enqueue specified data to be transmitted to the server over the WebSocket connection
     */
    async send(data) {
        if (this._closed) {
            throw new Error(`Failed to send data on an already closed transport`);
        }
        const id = ++this._sendingCounter;
        const clear = () => {
            if (this._sendingCounter === id) {
                this._sent = undefined;
            }
        };
        let prerequisite;
        if (this._sent) {
            prerequisite = this._sent;
        }
        else if (!this._ws) {
            prerequisite = this._connect();
        }
        else {
            prerequisite = Promise.resolve();
        }
        this._sent = prerequisite.then(async () => {
            clear();
            if (!this._ws) {
                this.close();
                return;
            }
            this._ws.send(data);
        }).catch(() => {
            clear();
            if (!this._closed) {
                this.close();
            }
        });
        return this._sent;
    }
    async _connect() {
        if (this._closed) {
            throw new Error(`Failed to connect to an already closed transport`);
        }
        if (this._ws) {
            logger.info(`Already connected`);
            return;
        }
        const result = await this._createWebsocket();
        result.addEventListener("message", data => {
            this._emitter.emit(ON_RECEIVED_EVENT_NAME, data);
        });
        result.addEventListener("close", () => {
            this._ws = undefined;
            if (!this._closed) {
                this.close();
            }
        });
        result.addEventListener("error", err => {
            this._ws = undefined;
            logger.warn(`Error occurred in transport`, err);
            if (!this._closed) {
                this.close();
            }
        });
        this._ws = result;
    }
    async _createWebsocket(tried = 0) {
        if (this._closed) {
            throw new Error(`The transport is already closed`);
        }
        const { urls, maxRetries, protocols } = this._config;
        const canRetry = tried < maxRetries * urls.length;
        const url = urls[tried % urls.length];
        return await new Promise((resolve, reject) => {
            const ws = new WebSocket(url, protocols);
            if (ws.readyState === WebSocket.OPEN) {
                resolve(ws);
            }
            else {
                // promise can be resolved or rejected only once, so no problem
                ws.addEventListener("close", reject);
                ws.addEventListener("error", reject);
                ws.addEventListener("open", () => resolve(ws));
            }
        }).catch(async () => {
            if (canRetry) {
                // print the error out anyhow
                logger.info(`Connection to ${url} is failed. Tried: ${tried}`);
                await this._waitBeforeReconnect(tried + 1);
                // if the transport is closed during waiting, 
                // the call to connect again is going to be rejected
                return await this._createWebsocket(tried + 1);
            }
            throw new Error(`Cannot connect to ${urls.join(", ")}.`);
        });
    }
    async _waitBeforeReconnect(executed) {
        const base = executed + 1;
        const max = 1 / base;
        const random = Math.random();
        const exp = 1 + Math.max(0.1, Math.min(random, max));
        const timeout = Math.floor(Math.min(Math.pow(base, exp), 60) * 1000);
        return new Promise((resolve) => {
            const timer = setTimeout(() => {
                this._cancelTimer = undefined;
                resolve();
            }, timeout);
            this._cancelTimer = () => {
                clearTimeout(timer);
                this._cancelTimer = undefined;
            };
            logger.info(`Enforced waiting before reconnect is ${timeout}ms`);
        });
    }
}
exports.WebsocketTransport = WebsocketTransport;

},{"../utils/logger":31,"events":1}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaDevices = void 0;
const EMPTY_ARRAY = [];
class MediaDevices {
    constructor() {
        this._mediaDevices = new Map();
        this._indexes = new Map();
    }
    add(mediaDevice) {
        if (!mediaDevice.id)
            return;
        const mediaDeviceId = mediaDevice.id;
        this._mediaDevices.set(mediaDeviceId, mediaDevice);
        if (!mediaDevice.kind) {
            return;
        }
        const index = mediaDevice.kind;
        const keys = this._indexes.get(index) || [];
        keys.push(mediaDeviceId);
        this._indexes.set(index, keys);
    }
    remove(mediaDeviceId) {
        const mediaDevice = this._mediaDevices.get(mediaDeviceId);
        if (!mediaDevice)
            return;
        this._mediaDevices.delete(mediaDeviceId);
        if (!mediaDevice.kind)
            return;
        const keys = this._indexes.get(mediaDevice.kind);
        if (!keys)
            return;
        const newKeys = keys.filter(key => key !== mediaDeviceId);
        this._indexes.set(mediaDevice.kind, newKeys);
    }
    values(index) {
        if (!index) {
            return this._mediaDevices.values();
        }
        const keys = this._indexes.get(index);
        if (!keys) {
            return EMPTY_ARRAY.values();
        }
        const mediaDevices = [];
        for (const key of keys) {
            const mediaDevice = this._mediaDevices.get(key);
            if (mediaDevice)
                mediaDevices.push(mediaDevice);
        }
        return mediaDevices.values();
    }
}
exports.MediaDevices = MediaDevices;

},{}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatsVisitor = void 0;
const schemas_1 = require("@observertc/schemas");
const logger_1 = require("./logger");
const logger = (0, logger_1.createLogger)(`StatsVisitor`);
class StatsVisitor {
    visit(statsEntry) {
        const [statsType, statsValue] = statsEntry;
        try {
            switch (statsType) {
                case schemas_1.W3CStats.StatsType.codec:
                    this.visitCodec(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.inboundRtp:
                    this.visitInboundRtp(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.outboundRtp:
                    this.visitOutboundRtp(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.remoteInboundRtp:
                    this.visitRemoteInboundRtp(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.remoteOutboundRtp:
                    this.visitRemoteOutboundRtp(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.mediaSource:
                    this.visitMediaSource(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.csrc:
                    this.visitContributingSource(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.peerConnection:
                    this.visitPeerConnection(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.dataChannel:
                    this.visitDataChannel(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.transceiver:
                    this.visitTransceiver(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.sender:
                    this.visitSender(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.receiver:
                    this.visitReceiver(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.transport:
                    this.visitTransport(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.sctpTransport:
                    this.visitSctpTransport(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.candidatePair:
                    this.visitIceCandidatePair(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.localCandidate:
                    this.visitLocalCandidate(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.remoteCandidate:
                    this.visitRemoteCandidate(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.certificate:
                    this.visitCertificate(statsValue);
                    break;
                case schemas_1.W3CStats.StatsType.iceServer:
                    this.visitIceServer(statsValue);
                    break;
                default:
                    break;
            }
            /*eslint-disable @typescript-eslint/no-explicit-any */
        }
        catch (err) {
            logger.warn(err);
        }
    }
}
exports.StatsVisitor = StatsVisitor;

},{"./logger":31,"@observertc/schemas":33}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Timer = void 0;
const uuid_1 = require("uuid");
const logger_1 = require("./logger");
const logger = (0, logger_1.createLogger)(`Timer`);
class ActionVisitor {
    visit(action) {
        switch (action.type) {
            case "collect":
                this.visitCollectTypeAction(action);
                break;
            case "sample":
                this.visitSampleTypeAction(action);
                break;
            case "send":
                this.visitSendTypeAction(action);
                break;
        }
    }
}
class Timer {
    constructor() {
        this._collecting = new Map();
        this._sending = new Map();
        this._sampling = new Map();
    }
    add(action) {
        const id = (0, uuid_1.v4)();
        const now = Date.now();
        const storedAction = {
            ...action,
            id,
            nextInvokeInMs: now + action.fixedDelayInMs,
            invoked: 0,
        };
        /*eslint-disable @typescript-eslint/no-this-alias */
        const timer = this;
        const visitor = new class extends ActionVisitor {
            /*eslint-disable @typescript-eslint/no-unused-vars*/
            visitCollectTypeAction(_action) {
                timer._collecting.set(id, storedAction);
            }
            /*eslint-disable @typescript-eslint/no-unused-vars*/
            visitSampleTypeAction(_action) {
                timer._sampling.set(id, storedAction);
            }
            /*eslint-disable @typescript-eslint/no-unused-vars*/
            visitSendTypeAction(_action) {
                timer._sending.set(id, storedAction);
            }
        };
        visitor.visit(storedAction);
        if (!this._timer) {
            this._timer = setTimeout(this._invoke.bind(this), 0);
        }
        return id;
    }
    remove(id) {
        let deleted = false;
        this._iterateInOrder(map => {
            deleted = deleted || map.delete(id);
        });
        if (!deleted) {
            logger.warn(`Cannot remove a not existing action`);
        }
    }
    clear() {
        if (this._timer) {
            clearTimeout(this._timer);
            this._timer = undefined;
        }
        this._collecting.clear();
        this._sampling.clear();
        this._sending.clear();
    }
    _invoke() {
        const now = Date.now();
        let next = now + 60000;
        let remainingActionsNum = 0;
        this._iterateInOrder(map => {
            const actions = Array.from(map.values());
            for (const action of actions) {
                let stretchInMs = 0;
                const remainingTimeInMs = action.nextInvokeInMs - now;
                if (10 < remainingTimeInMs) {
                    next = Math.min(next, action.nextInvokeInMs);
                    ++remainingActionsNum;
                    continue;
                }
                else if (0 < remainingTimeInMs) {
                    stretchInMs = remainingTimeInMs;
                }
                try {
                    action.process();
                    /*eslint-disable @typescript-eslint/no-explicit-any*/
                }
                catch (err) {
                    logger.warn(`Error occurred while executing timer action (${action.context})`);
                }
                action.nextInvokeInMs = now + action.fixedDelayInMs + stretchInMs;
                next = Math.min(next, action.nextInvokeInMs);
                ++action.invoked;
                if (action.maxInvoke && action.maxInvoke <= action.invoked) {
                    map.delete(action.id);
                }
                else {
                    ++remainingActionsNum;
                }
            }
        });
        if (remainingActionsNum < 1) {
            this._timer = undefined;
            return;
        }
        const delayInMs = next - now;
        this._timer = setTimeout(this._invoke.bind(this), delayInMs);
    }
    _iterateInOrder(consumer) {
        for (const map of [this._collecting, this._sampling, this._sending]) {
            consumer(map);
        }
    }
}
exports.Timer = Timer;

},{"./logger":31,"uuid":120}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NULL_UUID = exports.makeForwardDeltaObj = exports.makePrefixedObj = void 0;
/*eslint-disable @typescript-eslint/ban-types*/
/*eslint-disable @typescript-eslint/no-explicit-any*/
function makePrefixedObj(obj, prefix, camelCase) {
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
        const newKey = camelCase ? key.charAt(0).toUpperCase() + key.slice(1) : key;
        result[`${prefix}${newKey}`] = value;
    }
    return result;
}
exports.makePrefixedObj = makePrefixedObj;
/*eslint-disable @typescript-eslint/no-explicit-any */
function makeForwardDeltaObj(left, right) {
    if (left === undefined || right === undefined) {
        if (left === undefined && right === undefined)
            return undefined;
        if (left === undefined)
            return right;
        return undefined;
    }
    if (left === null || right === null) {
        if (left === null && right === null)
            return undefined;
        if (left === null)
            return right;
        return undefined;
    }
    const type = typeof left;
    if (type !== typeof right) {
        throw new Error(`Cannot make a delta obj between different type of object (${type}, ${typeof right}), sorry!`);
    }
    if (type === "function") {
        throw new Error(`Cannot make a delta obj on functions?!`);
    }
    if (Array.isArray(left) || Array.isArray(right)) {
        throw new Error(`Cannot make a delta obj between arrays, sorry!`);
    }
    if (type === "object") {
        /*eslint-disable @typescript-eslint/no-explicit-any */
        const result = {};
        for (const keyA of Object.keys(left)) {
            const deltaValue = makeForwardDeltaObj(left[keyA], right[keyA]);
            if (deltaValue === undefined)
                continue;
            result[keyA] = deltaValue;
        }
        for (const keyB of Object.keys(right)) {
            if (result[keyB] !== undefined)
                continue;
            const deltaValue = makeForwardDeltaObj(left[keyB], right[keyB]);
            if (deltaValue === undefined)
                continue;
            result[keyB] = deltaValue;
        }
        return result;
    }
    if (left === right)
        return undefined;
    return right;
}
exports.makeForwardDeltaObj = makeForwardDeltaObj;
exports.NULL_UUID = "00000000-0000-0000-0000-000000000000";

},{}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hash = void 0;
const js_sha256_1 = require("js-sha256");
/*eslint-disable @typescript-eslint/no-explicit-any */
function hash(obj) {
    const digester = js_sha256_1.sha256.create();
    if (obj === undefined) {
        digester.update("undefined");
        return digester.hex();
    }
    if (obj === null) {
        digester.update("undefined");
        return digester.hex();
    }
    const type = typeof obj;
    if (type === "function") {
        digester.update("function");
        return digester.hex();
    }
    if (type === "object") {
        for (const [key, value] of Object.entries(obj)) {
            const valueHash = hash(value);
            digester.update(key + valueHash);
        }
        return digester.hex();
    }
    switch (type) {
        case "bigint":
            digester.update(obj.toString());
            break;
        case "boolean":
            digester.update(obj.toString());
            break;
        case "number":
            digester.update(obj.toString());
            break;
        case "string":
            digester.update(obj);
            break;
        case "undefined":
            digester.update("undefined");
            break;
        case "symbol":
            digester.update(obj.toString());
            break;
    }
    return digester.hex();
}
exports.hash = hash;

},{"js-sha256":88}],31:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setLevel = exports.createLogger = void 0;
const Logger = __importStar(require("loglevel"));
const initLogger = (prefix) => {
    // eslint-disable-next-line no-underscore-dangle
    const _logger = Logger.getLogger(prefix);
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    _logger.methodFactory = (methodName, logLevel, loggerName) => {
        const originalFactory = Logger.methodFactory, rawMethod = originalFactory(methodName, logLevel, loggerName);
        // eslint-disable-next-line @typescript-eslint/explicit-function-return-type,func-names
        return function (...params) {
            rawMethod(`${prefix} ${new Date().toUTCString()}`, ...params);
        };
    };
    return _logger;
};
let actualLevel = "info";
const loggers = new Map();
const createLogger = (moduleName) => {
    const logger = initLogger(`ObserveRTC::${moduleName}`);
    logger.setLevel(actualLevel);
    loggers.set(moduleName, logger);
    return logger;
};
exports.createLogger = createLogger;
const setLevel = (level) => {
    for (const logger of loggers.values()) {
        logger.setLevel(level);
    }
    actualLevel = level;
};
exports.setLevel = setLevel;

},{"loglevel":89}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkUuid = exports.isValidUuid = void 0;
function isValidUuid(str) {
    const regexp = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return regexp.test(str);
}
exports.isValidUuid = isValidUuid;
function checkUuid(str, context) {
    if (!isValidUuid(str)) {
        throw new Error(`Invalid Uuid ${str}. Context: ${context}`);
    }
}
exports.checkUuid = checkUuid;

},{}],33:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.version = exports.W3CStats = exports.ProtobufSamplesV3Json = exports.ProtobufSamplesV3 = exports.ProtobufSamplesJson = exports.ProtobufSamples = exports.AvroSamples = exports.AvroSFUTransportReport = exports.AvroSfuSctpStreamReport = exports.AvroSfuOutboundRtpPadReport = exports.AvroSfuMetaReport = exports.AvroSfuInboundRtpPadReport = exports.AvroSfuExtensionReport = exports.AvroSfuEventReport = exports.AvroReport = exports.AvroOutboundVideoTrackReport = exports.AvroOutboundAudioTrackReport = exports.AvroObserverEventReport = exports.AvroInboundVideoTrackReport = exports.AvroInboundAudioTrackReport = exports.AvroClientTransportReport = exports.AvroClientExtensionReport = exports.AvroClientDataChannelReport = exports.AvroCallMetaReport = exports.AvroCallEventReport = void 0;
var CallEventReportAvsc_1 = require("./reports/CallEventReportAvsc");
Object.defineProperty(exports, "AvroCallEventReport", { enumerable: true, get: function () { return CallEventReportAvsc_1.schema; } });
__exportStar(require("./reports/CallEventReport"), exports);
var CallMetaReportAvsc_1 = require("./reports/CallMetaReportAvsc");
Object.defineProperty(exports, "AvroCallMetaReport", { enumerable: true, get: function () { return CallMetaReportAvsc_1.schema; } });
__exportStar(require("./reports/CallMetaReport"), exports);
var ClientDataChannelReportAvsc_1 = require("./reports/ClientDataChannelReportAvsc");
Object.defineProperty(exports, "AvroClientDataChannelReport", { enumerable: true, get: function () { return ClientDataChannelReportAvsc_1.schema; } });
__exportStar(require("./reports/ClientDataChannelReport"), exports);
var ClientExtensionReportAvsc_1 = require("./reports/ClientExtensionReportAvsc");
Object.defineProperty(exports, "AvroClientExtensionReport", { enumerable: true, get: function () { return ClientExtensionReportAvsc_1.schema; } });
__exportStar(require("./reports/ClientExtensionReport"), exports);
var ClientTransportReportAvsc_1 = require("./reports/ClientTransportReportAvsc");
Object.defineProperty(exports, "AvroClientTransportReport", { enumerable: true, get: function () { return ClientTransportReportAvsc_1.schema; } });
__exportStar(require("./reports/ClientTransportReport"), exports);
var InboundAudioTrackReportAvsc_1 = require("./reports/InboundAudioTrackReportAvsc");
Object.defineProperty(exports, "AvroInboundAudioTrackReport", { enumerable: true, get: function () { return InboundAudioTrackReportAvsc_1.schema; } });
__exportStar(require("./reports/InboundAudioTrackReport"), exports);
var InboundVideoTrackReportAvsc_1 = require("./reports/InboundVideoTrackReportAvsc");
Object.defineProperty(exports, "AvroInboundVideoTrackReport", { enumerable: true, get: function () { return InboundVideoTrackReportAvsc_1.schema; } });
__exportStar(require("./reports/InboundVideoTrackReport"), exports);
var ObserverEventReportAvsc_1 = require("./reports/ObserverEventReportAvsc");
Object.defineProperty(exports, "AvroObserverEventReport", { enumerable: true, get: function () { return ObserverEventReportAvsc_1.schema; } });
__exportStar(require("./reports/ObserverEventReport"), exports);
var OutboundAudioTrackReportAvsc_1 = require("./reports/OutboundAudioTrackReportAvsc");
Object.defineProperty(exports, "AvroOutboundAudioTrackReport", { enumerable: true, get: function () { return OutboundAudioTrackReportAvsc_1.schema; } });
__exportStar(require("./reports/OutboundAudioTrackReport"), exports);
var OutboundVideoTrackReportAvsc_1 = require("./reports/OutboundVideoTrackReportAvsc");
Object.defineProperty(exports, "AvroOutboundVideoTrackReport", { enumerable: true, get: function () { return OutboundVideoTrackReportAvsc_1.schema; } });
__exportStar(require("./reports/OutboundVideoTrackReport"), exports);
var ReportAvsc_1 = require("./reports/ReportAvsc");
Object.defineProperty(exports, "AvroReport", { enumerable: true, get: function () { return ReportAvsc_1.schema; } });
__exportStar(require("./reports/Report"), exports);
var SfuEventReportAvsc_1 = require("./reports/SfuEventReportAvsc");
Object.defineProperty(exports, "AvroSfuEventReport", { enumerable: true, get: function () { return SfuEventReportAvsc_1.schema; } });
__exportStar(require("./reports/SfuEventReport"), exports);
var SfuExtensionReportAvsc_1 = require("./reports/SfuExtensionReportAvsc");
Object.defineProperty(exports, "AvroSfuExtensionReport", { enumerable: true, get: function () { return SfuExtensionReportAvsc_1.schema; } });
__exportStar(require("./reports/SfuExtensionReport"), exports);
var SfuInboundRtpPadReportAvsc_1 = require("./reports/SfuInboundRtpPadReportAvsc");
Object.defineProperty(exports, "AvroSfuInboundRtpPadReport", { enumerable: true, get: function () { return SfuInboundRtpPadReportAvsc_1.schema; } });
__exportStar(require("./reports/SfuInboundRtpPadReport"), exports);
var SfuMetaReportAvsc_1 = require("./reports/SfuMetaReportAvsc");
Object.defineProperty(exports, "AvroSfuMetaReport", { enumerable: true, get: function () { return SfuMetaReportAvsc_1.schema; } });
__exportStar(require("./reports/SfuMetaReport"), exports);
var SfuOutboundRtpPadReportAvsc_1 = require("./reports/SfuOutboundRtpPadReportAvsc");
Object.defineProperty(exports, "AvroSfuOutboundRtpPadReport", { enumerable: true, get: function () { return SfuOutboundRtpPadReportAvsc_1.schema; } });
__exportStar(require("./reports/SfuOutboundRtpPadReport"), exports);
var SfuSctpStreamReportAvsc_1 = require("./reports/SfuSctpStreamReportAvsc");
Object.defineProperty(exports, "AvroSfuSctpStreamReport", { enumerable: true, get: function () { return SfuSctpStreamReportAvsc_1.schema; } });
__exportStar(require("./reports/SfuSctpStreamReport"), exports);
var SFUTransportReportAvsc_1 = require("./reports/SFUTransportReportAvsc");
Object.defineProperty(exports, "AvroSFUTransportReport", { enumerable: true, get: function () { return SFUTransportReportAvsc_1.schema; } });
__exportStar(require("./reports/SFUTransportReport"), exports);
var SamplesAvsc_1 = require("./samples/SamplesAvsc");
Object.defineProperty(exports, "AvroSamples", { enumerable: true, get: function () { return SamplesAvsc_1.schema; } });
__exportStar(require("./samples/Samples"), exports);
var ProtobufSamples_1 = require("./samples/ProtobufSamples");
Object.defineProperty(exports, "ProtobufSamples", { enumerable: true, get: function () { return ProtobufSamples_1.schema; } });
var ProtobufSamplesJson_1 = require("./samples/ProtobufSamplesJson");
Object.defineProperty(exports, "ProtobufSamplesJson", { enumerable: true, get: function () { return ProtobufSamplesJson_1.jsonDescriptor; } });
var ProtobufSamplesV3_1 = require("./samples/ProtobufSamplesV3");
Object.defineProperty(exports, "ProtobufSamplesV3", { enumerable: true, get: function () { return ProtobufSamplesV3_1.schema; } });
var ProtobufSamplesV3Json_1 = require("./samples/ProtobufSamplesV3Json");
Object.defineProperty(exports, "ProtobufSamplesV3Json", { enumerable: true, get: function () { return ProtobufSamplesV3Json_1.jsonDescriptor; } });
exports.W3CStats = __importStar(require("./w3c/W3cStatsIdentifiers"));
exports.version = "2.0.0-beta.59";

},{"./reports/CallEventReport":34,"./reports/CallEventReportAvsc":35,"./reports/CallMetaReport":36,"./reports/CallMetaReportAvsc":37,"./reports/ClientDataChannelReport":38,"./reports/ClientDataChannelReportAvsc":39,"./reports/ClientExtensionReport":40,"./reports/ClientExtensionReportAvsc":41,"./reports/ClientTransportReport":42,"./reports/ClientTransportReportAvsc":43,"./reports/InboundAudioTrackReport":44,"./reports/InboundAudioTrackReportAvsc":45,"./reports/InboundVideoTrackReport":46,"./reports/InboundVideoTrackReportAvsc":47,"./reports/ObserverEventReport":48,"./reports/ObserverEventReportAvsc":49,"./reports/OutboundAudioTrackReport":50,"./reports/OutboundAudioTrackReportAvsc":51,"./reports/OutboundVideoTrackReport":52,"./reports/OutboundVideoTrackReportAvsc":53,"./reports/Report":54,"./reports/ReportAvsc":55,"./reports/SFUTransportReport":56,"./reports/SFUTransportReportAvsc":57,"./reports/SfuEventReport":58,"./reports/SfuEventReportAvsc":59,"./reports/SfuExtensionReport":60,"./reports/SfuExtensionReportAvsc":61,"./reports/SfuInboundRtpPadReport":62,"./reports/SfuInboundRtpPadReportAvsc":63,"./reports/SfuMetaReport":64,"./reports/SfuMetaReportAvsc":65,"./reports/SfuOutboundRtpPadReport":66,"./reports/SfuOutboundRtpPadReportAvsc":67,"./reports/SfuSctpStreamReport":68,"./reports/SfuSctpStreamReportAvsc":69,"./samples/ProtobufSamples":70,"./samples/ProtobufSamplesJson":71,"./samples/ProtobufSamplesV3":72,"./samples/ProtobufSamplesV3Json":73,"./samples/Samples":74,"./samples/SamplesAvsc":75,"./w3c/W3cStatsIdentifiers":76}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "CallEventReport",
    "namespace": "org.observertc.schemas.reports.reports",
    "doc": "Observer created reports related to events (call started, call ended, client joined, etc...) indicated by the incoming samples.",
    "fields": [
        {
            "name": "serviceId",
            "doc": "The unique identifier of the service",
            "type": "string"
        },
        {
            "name": "mediaUnitId",
            "doc": "The media unit id the report belongs to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "marker",
            "doc": "The marker the originated sample is reported with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "timestamp",
            "doc": "The timestamp when the corresponded data is generated for the report (UTC Epoch in ms)",
            "type": "long"
        },
        {
            "name": "callId",
            "doc": "The generated unique identifier of the call",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "roomId",
            "doc": "webrtc app provided room id",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clientId",
            "doc": "The generated unique identifier of the client",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "userId",
            "doc": "webrtc app provided user identifier",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "peerConnectionId",
            "doc": "The unique identifier of the peer connection",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "mediaTrackId",
            "doc": "The unique identifier of the media track",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "SSRC",
            "doc": "The SSRC identifier of the RTP stream a trackId belongs to",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "sampleTimestamp",
            "doc": "The timestamp of the sample the event related to",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "sampleSeq",
            "doc": "The sequence number of the sample the event may related to",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "name",
            "doc": "The name of the event. Possible values are: CALL_STARTED, CALL_ENDED, CLIENT_JOINED, CLIENT_LEFT, PEER_CONNECTION_OPENED, PEER_CONNECTION_CLOSED, MEDIA_TRACK_ADDED, MEDIA_TRACK_REMOVED",
            "type": "string"
        },
        {
            "name": "message",
            "doc": "the human readable message of the event",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "value",
            "doc": "the value of the event",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "attachments",
            "doc": "attachment the event may created with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        }
    ]
};

},{}],36:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "CallMetaReport",
    "namespace": "org.observertc.schemas.reports",
    "doc": "Metadata belongs to a call and can be useful",
    "fields": [
        {
            "name": "serviceId",
            "doc": "The unique identifier of the service",
            "type": "string"
        },
        {
            "name": "mediaUnitId",
            "doc": "The media unit id the report belongs to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "marker",
            "doc": "The marker the originated sample is reported with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "timestamp",
            "doc": "The timestamp when the corresponded data is generated for the report (UTC Epoch in ms)",
            "type": "long"
        },
        {
            "name": "callId",
            "doc": "The generated unique identifier of the call",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "roomId",
            "doc": "webrtc app provided room id",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clientId",
            "doc": "The generated unique identifier of the client",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "userId",
            "doc": "webrtc app provided user identifier",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "peerConnectionId",
            "doc": "The unique identifier of the peer connection",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sampleTimestamp",
            "doc": "The timestamp of the sample the event related to",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "sampleSeq",
            "doc": "The sequence number of the sample the event may related to",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "type",
            "doc": "The type of the meta data. Possible values are: CERTIFICATE, CODEC, ICE_LOCAL_CANDIDATE, ICE_REMOTE_CANDIDATE, ICE_SERVER, MEDIA_CONSTRAINT, MEDIA_DEVICE, MEDIA_SOURCE, USER_MEDIA_ERROR, LOCAL_SDP",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "payload",
            "doc": "The payload for the metadata reported for the peeer connection",
            "type": [
                "null",
                "string"
            ],
            "default": null
        }
    ]
};

},{}],38:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "ClientDataChannelReport",
    "namespace": "org.observertc.schemas.reports",
    "doc": "A Report created for PeerConnection Data Channel.",
    "fields": [
        {
            "name": "serviceId",
            "doc": "The unique identifier of the service",
            "type": "string"
        },
        {
            "name": "mediaUnitId",
            "doc": "The media unit id the report belongs to",
            "type": "string"
        },
        {
            "name": "marker",
            "doc": "The marker the originated sample is reported with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "timestamp",
            "doc": "The timestamp when the corresponded data is generated for the report (UTC Epoch in ms)",
            "type": "long"
        },
        {
            "name": "callId",
            "doc": "The generated unique identifier of the call",
            "type": "string"
        },
        {
            "name": "roomId",
            "doc": "webrtc app provided room id",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clientId",
            "doc": "The generated unique identifier of the client",
            "type": "string"
        },
        {
            "name": "userId",
            "doc": "webrtc app provided user identifier",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "peerConnectionId",
            "doc": "The unique identifier of the peer connection",
            "type": "string"
        },
        {
            "name": "peerConnectionLabel",
            "doc": "The webrtc app provided label for the peer connection",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sampleSeq",
            "doc": "The sequence number of the sample the report is generated from",
            "type": "int"
        },
        {
            "name": "label",
            "doc": "The label of the data channel",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "protocol",
            "doc": "The protocol used for the data channel",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "state",
            "doc": "The state of the data channel",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "messagesSent",
            "doc": "Represents the total number of API message events sent",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "bytesSent",
            "doc": "Represents the total number of payload bytes sent on the corresponded data channel",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "messagesReceived",
            "doc": "Represents the total number of API message events received on the corresponded data channel",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "bytesReceived",
            "doc": "Represents the total number of payload bytes received on the corresponded data channel",
            "type": [
                "null",
                "long"
            ],
            "default": null
        }
    ]
};

},{}],40:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "ClientExtensionReport",
    "namespace": "org.observertc.schemas.reports",
    "doc": "A Report created for Extended provided arbitrary data.",
    "fields": [
        {
            "name": "serviceId",
            "doc": "The unique identifier of the service",
            "type": "string"
        },
        {
            "name": "mediaUnitId",
            "doc": "The media unit id the report belongs to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "marker",
            "doc": "The marker the originated sample is reported with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "timestamp",
            "doc": "The timestamp when the corresponded data is generated for the report (UTC Epoch in ms)",
            "type": "long"
        },
        {
            "name": "callId",
            "doc": "The generated unique identifier of the call",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "roomId",
            "doc": "webrtc app provided room id",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clientId",
            "doc": "The generated unique identifier of the client",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "userId",
            "doc": "webrtc app provided user identifier",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "peerConnectionId",
            "doc": "The unique identifier of the peer connection",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sampleSeq",
            "doc": "The sequence number of the sample the event may related to",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "extensionType",
            "doc": "The name of the event",
            "type": "string"
        },
        {
            "name": "payload",
            "doc": "the human readable message of the event",
            "type": [
                "null",
                "string"
            ],
            "default": null
        }
    ]
};

},{}],42:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "ClientTransportReport",
    "namespace": "org.observertc.schemas.reports",
    "doc": "A Report created for Client PeerConnection Transport. It is a combination of Transport report, sender, receiver, local, remote and candidate pair of ICE together with the used certificates",
    "fields": [
        {
            "name": "serviceId",
            "doc": "The unique identifier of the service",
            "type": "string"
        },
        {
            "name": "mediaUnitId",
            "doc": "The media unit id the report belongs to",
            "type": "string"
        },
        {
            "name": "marker",
            "doc": "The marker the originated sample is reported with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "timestamp",
            "doc": "The timestamp when the corresponded data is generated for the report (UTC Epoch in ms)",
            "type": "long"
        },
        {
            "name": "callId",
            "doc": "The generated unique identifier of the call",
            "type": "string"
        },
        {
            "name": "roomId",
            "doc": "webrtc app provided room id",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clientId",
            "doc": "The generated unique identifier of the client",
            "type": "string"
        },
        {
            "name": "userId",
            "doc": "webrtc app provided user identifier",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "peerConnectionId",
            "doc": "The unique identifier of the peer connection",
            "type": "string"
        },
        {
            "name": "label",
            "doc": "The webrtc app provided label the peer connection is marked with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "packetsSent",
            "doc": "Represents the total number of packets sent on the corresponded transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsReceived",
            "doc": "Represents the total number of packets received on the corresponded transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "bytesSent",
            "doc": "Represents the total amount of bytes sent on the corresponded transport",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "bytesReceived",
            "doc": "Represents the total amount of bytes received on the corresponded transport",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "iceRole",
            "doc": "Represent the current role of ICE under DTLS Transport",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "iceLocalUsernameFragment",
            "doc": "Represent the current local username fragment used in message validation procedures for ICE under DTLS Transport",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "dtlsState",
            "doc": "Represents the current state of DTLS for the peer connection transport layer",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "iceTransportState",
            "doc": "Represents the current transport state (RTCIceTransportState) of ICE for the peer connection transport layer",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "tlsVersion",
            "doc": "Represents the version number of the TLS used in the corresponded transport",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "dtlsCipher",
            "doc": "Represents the name of the DTLS cipher used in the corresponded transport",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "srtpCipher",
            "doc": "Represents the name of the SRTP cipher used in the corresponded transport",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "tlsGroup",
            "doc": "Represents the name of the IANA TLS Supported Groups used in the corresponded transport",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "selectedCandidatePairChanges",
            "doc": "The total number of candidate pair changes over the peer connection",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "localAddress",
            "doc": "The address of the candidate (IPv4, IPv6, FQDN)",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "localPort",
            "doc": "The locally used port to communicate with the remote peer",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "localProtocol",
            "doc": "The protocol used by the local endpoint for the corresponded transport",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "localCandidateType",
            "doc": "The type of the ICE candidate used at the local endpoint on the corresponded transport",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "localCandidateICEServerUrl",
            "doc": "The url of the ICE server used by the local endpoint on the corresponded transport",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "localCandidateRelayProtocol",
            "doc": "The relay protocol of the ICE candidate used by the local endpoint on the corresponded transport",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "remoteAddress",
            "doc": "The address of the candidate (IPv4, IPv6, FQDN)",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "remotePort",
            "doc": "The remotely used port to communicate with the remote peer",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "remoteProtocol",
            "doc": "The protocol used by the remote endpoint for the corresponded transport",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "remoteCandidateType",
            "doc": "The type of the ICE candidate used at the remote endpoint on the corresponded transport",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "remoteCandidateICEServerUrl",
            "doc": "The url of the ICE server used by the remote endpoint on the corresponded transport",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "remoteCandidateRelayProtocol",
            "doc": "The relay protocol of the ICE candidate used by the remote endpoint on the corresponded transport",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "candidatePairState",
            "doc": "The state of ICE Candidate Pairs (RTCStatsIceCandidatePairState) on the corresponded transport",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "candidatePairPacketsSent",
            "doc": "The total number of packets sent using the last selected candidate pair over the corresponded transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "candidatePairPacketsReceived",
            "doc": "The total number of packets received using the last selected candidate pair over the corresponded transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "candidatePairBytesSent",
            "doc": "The total number of bytes sent using the last selected candidate pair over the corresponded transport",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "candidatePairBytesReceived",
            "doc": "The total number of bytes received using the last selected candidate pair over the corresponded transport",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "candidatePairLastPacketSentTimestamp",
            "doc": "Represents the timestamp at which the last packet was sent on the selected candidate pair, excluding STUN packets over the corresponded transport (UTC Epoch in ms)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "candidatePairLastPacketReceivedTimestamp",
            "doc": "Represents the timestamp at which the last packet was received on the selected candidate pair, excluding STUN packets over the corresponded transport (UTC Epoch in ms)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "candidatePairFirstRequestTimestamp",
            "doc": "Represents the timestamp at which the first STUN request was sent on this particular candidate pair over the corresponded transport (UTC Epoch in ms)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "candidatePairLastRequestTimestamp",
            "doc": "Represents the timestamp at which the last STUN request was sent on this particular candidate pair over the corresponded transport (UTC Epoch in ms)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "candidatePairLastResponseTimestamp",
            "doc": "Represents the timestamp at which the last STUN response was received on this particular candidate pair over the corresponded transport (UTC Epoch in ms)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "candidatePairTotalRoundTripTime",
            "doc": "Represents the sum of all round trip time measurements in seconds since the beginning of the session, based on STUN connectivity check over the corresponded transport",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "candidatePairCurrentRoundTripTime",
            "doc": "Represents the last round trip time measurements in seconds based on STUN connectivity check over the corresponded transport",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "candidatePairAvailableOutgoingBitrate",
            "doc": "The sum of the underlying cc algorithm provided outgoing bitrate for the RTP streams over the corresponded transport",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "candidatePairAvailableIncomingBitrate",
            "doc": "The sum of the underlying cc algorithm provided incoming bitrate for the RTP streams over the corresponded transport",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "candidatePairCircuitBreakerTriggerCount",
            "doc": "The total number of circuit breaker triggered over the corresponded transport using the selected candidate pair",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "candidatePairRequestsReceived",
            "doc": "Represents the total number of connectivity check requests received on the selected candidate pair using the corresponded transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "candidatePairRequestsSent",
            "doc": "Represents the total number of connectivity check requests sent on the selected candidate pair using the corresponded transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "candidatePairResponsesReceived",
            "doc": "Represents the total number of connectivity check responses received on the selected candidate pair using the corresponded transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "candidatePairResponsesSent",
            "doc": "Represents the total number of connectivity check responses sent on the selected candidate pair using the corresponded transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "candidatePairRetransmissionReceived",
            "doc": "Represents the total number of connectivity check retransmission received on the selected candidate pair using the corresponded transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "candidatePairRetransmissionSent",
            "doc": "Represents the total number of connectivity check retransmission sent on the selected candidate pair using the corresponded transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "candidatePairConsentRequestsSent",
            "doc": "Represents the total number of consent requests sent on the selected candidate pair using the corresponded transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "candidatePairConsentExpiredTimestamp",
            "doc": "Represents the timestamp at which the latest valid STUN binding response expired on the selected candidate pair using the corresponded transport",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "candidatePairBytesDiscardedOnSend",
            "doc": "Total amount of bytes for this candidate pair that have been discarded due to socket errors on the selected candidate pair using the corresponded transport",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "candidatePairPacketsDiscardedOnSend",
            "doc": "Total amount of packets for this candidate pair that have been discarded due to socket errors on the selected candidate pair using the corresponded transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "candidatePairRequestBytesSent",
            "doc": "Total number of bytes sent for connectivity checks on the selected candidate pair using the corresponded transport",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "candidatePairConsentRequestBytesSent",
            "doc": "Total number of bytes sent for consent requests on the selected candidate pair using the corresponded transport",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "candidatePairResponseBytesSent",
            "doc": "Total number of bytes sent for connectivity check responses on the selected candidate pair using the corresponded transport",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "sctpSmoothedRoundTripTime",
            "doc": "The latest smoothed round-trip time value, corresponding to spinfo_srtt defined in [RFC6458] but converted to seconds. ",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "sctpCongestionWindow",
            "doc": "The latest congestion window, corresponding to spinfo_cwnd.",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "sctpReceiverWindow",
            "doc": "The latest receiver window, corresponding to sstat_rwnd.",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "sctpMtu",
            "doc": "The latest maximum transmission unit, corresponding to spinfo_mtu.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "sctpUnackData",
            "doc": "The number of unacknowledged DATA chunks, corresponding to sstat_unackdata.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        }
    ]
};

},{}],44:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "InboundAudioTrackReport",
    "namespace": "org.observertc.schemas.reports",
    "doc": "A Report created for Inbound Audio Tracks. A combination of Codec metadata carrying inbound and remote outbound RTP stats measurements",
    "fields": [
        {
            "name": "serviceId",
            "doc": "The unique identifier of the service",
            "type": "string"
        },
        {
            "name": "mediaUnitId",
            "doc": "The media unit id the report belongs to",
            "type": "string"
        },
        {
            "name": "marker",
            "doc": "The marker the originated sample is reported with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "timestamp",
            "doc": "The timestamp when the corresponded data is generated for the report (UTC Epoch in ms)",
            "type": "long"
        },
        {
            "name": "callId",
            "doc": "The generated unique identifier of the call",
            "type": "string"
        },
        {
            "name": "roomId",
            "doc": "webrtc app provided room id",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clientId",
            "doc": "The generated unique identifier of the client",
            "type": "string"
        },
        {
            "name": "userId",
            "doc": "webrtc app provided user identifier",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "peerConnectionId",
            "doc": "The unique identifier of the peer connection",
            "type": "string"
        },
        {
            "name": "label",
            "doc": "The webrtc app provided label the peer connection is labeled with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "trackId",
            "doc": "The id of the track",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sfuStreamId",
            "doc": "The id of the Sfu stream the media from",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sfuSinkId",
            "doc": "The id of the sink the Sfu streamed the media out",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "remoteTrackId",
            "doc": "The id of the remote track this inbound track is originated from",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "remoteUserId",
            "doc": "The webrtc app provided user id the track belongs to, or if the webrtc app did not provided the observer tried to match it",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "remoteClientId",
            "doc": "The observer matched remote client Id",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "remotePeerConnectionId",
            "doc": "The observer matched remote Peer Connection Id",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sampleSeq",
            "doc": "The sequence number of the sample the report is generated from",
            "type": "int"
        },
        {
            "name": "ssrc",
            "doc": "The RTP SSRC field",
            "type": "long"
        },
        {
            "name": "packetsReceived",
            "doc": "The total number of packets received on the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsLost",
            "doc": "The total number of bytes received on the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "jitter",
            "doc": "The corresponded synchronization source reported jitter",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "packetsDiscarded",
            "doc": "The total number of packets missed the playout point and therefore discarded by the jitterbuffer",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsRepaired",
            "doc": "The total number of packets repaired by either FEC or due to retransmission on the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstPacketsLost",
            "doc": "The total number of packets lost in burst (RFC6958)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstPacketsDiscarded",
            "doc": "The total number of packets discarded in burst (RFC6958)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstLossCount",
            "doc": "The total number of burst happened causes burstPacketsLost on the corresponding synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstDiscardCount",
            "doc": "The total number of burst happened causes burstPacketsDiscarded on the corresponding synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstLossRate",
            "doc": "The fraction of RTP packets lost during bursts proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "burstDiscardRate",
            "doc": "The fraction of RTP packets discarded during bursts proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "gapLossRate",
            "doc": "The fraction of RTP packets lost during gap proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "gapDiscardRate",
            "doc": "The fraction of RTP packets discarded during gap proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "voiceActivityFlag",
            "doc": "Indicate if the last RTP packet received contained voice activity based on the presence of the V bit in the extension header",
            "type": [
                "null",
                "boolean"
            ],
            "default": null
        },
        {
            "name": "lastPacketReceivedTimestamp",
            "doc": "Represents the timestamp at which the last packet was received on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "averageRtcpInterval",
            "doc": "The average RTCP interval between two consecutive compound RTCP packets sent for the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "headerBytesReceived",
            "doc": "Total number of RTP header and padding bytes received over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "fecPacketsReceived",
            "doc": "Total number of FEC packets received over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "fecPacketsDiscarded",
            "doc": "Total number of FEC packets discarded over the corresponding synchronization source (ssrc) due to 1) late arrive; 2) the target RTP packet has already been repaired.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "bytesReceived",
            "doc": "Total number of bytes received over the corresponding synchronization source (ssrc) due to 1) late arrive; 2) the target RTP packet has already been repaired.",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "packetsFailedDecryption",
            "doc": "Total number of packets received and failed to decrypt over the corresponding synchronization source (ssrc) due to 1) late arrive; 2) the target RTP packet has already been repaired.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsDuplicated",
            "doc": "Total number of packets identified as duplicated over the corresponding synchronization source (ssrc).",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "perDscpPacketsReceived",
            "doc": "The total number of DSCP flagged RTP packets received over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "nackCount",
            "doc": "Count the total number of Negative ACKnowledgement (NACK) packets sent and belongs to the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "totalProcessingDelay",
            "doc": "The total processing delay in seconds spend on buffering RTP packets from received up until packets are decoded",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "estimatedPlayoutTimestamp",
            "doc": "The estimated playout time of the corresponded synchronization source",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "jitterBufferDelay",
            "doc": "The total time of RTP packets spent in jitterbuffer waiting for frame completion due to network uncertenity.",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "jitterBufferEmittedCount",
            "doc": "The total number of audio samples or video frames that have come out of the jitter buffer on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "decoderImplementation",
            "doc": "Indicate the name of the decoder implementation library",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "packetsSent",
            "doc": "Total number of RTP packets sent at the remote endpoint to this endpoint on this synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "bytesSent",
            "doc": "Total number of payload bytes sent at the remote endpoint to this endpoint on this synchronization source",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "remoteTimestamp",
            "doc": "The timestamp corresnponds to the time in UTC Epoch the remote endpoint reported the statistics belong to the sender side and correspond to the synchronization source (ssrc)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "reportsSent",
            "doc": "The number of SR reports the remote endpoint sent corresponded to synchronization source (ssrc) this report belongs to",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "ended",
            "doc": "Flag represents if the receiver ended the media stream track or not.",
            "type": [
                "null",
                "boolean"
            ],
            "default": null
        },
        {
            "name": "payloadType",
            "doc": "The type of the payload the RTP packet SSRC belongs to",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "mimeType",
            "doc": "the MIME type of the codec (e.g.: video/vp8)",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clockRate",
            "doc": "The negotiated clock rate the RTP timestamp is generated of",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "channels",
            "doc": "The number of channels for audio is used (in stereo it is 2, otherwise it is most likely null)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "sdpFmtpLine",
            "doc": "The a=fmtp line in the SDP corresponding to the codec",
            "type": [
                "null",
                "string"
            ],
            "default": null
        }
    ]
};

},{}],46:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "InboundVideoTrackReport",
    "namespace": "org.observertc.schemas.reports",
    "doc": "A Report created for Inbound Video Tracks. A combination of Codec metadata carrying inbound and remote outbound RTP stats measurements",
    "fields": [
        {
            "name": "serviceId",
            "doc": "The unique identifier of the service",
            "type": "string"
        },
        {
            "name": "mediaUnitId",
            "doc": "The media unit id the report belongs to",
            "type": "string"
        },
        {
            "name": "marker",
            "doc": "The marker the originated sample is reported with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "timestamp",
            "doc": "The timestamp when the corresponded data is generated for the report (UTC Epoch in ms)",
            "type": "long"
        },
        {
            "name": "callId",
            "doc": "The generated unique identifier of the call",
            "type": "string"
        },
        {
            "name": "roomId",
            "doc": "webrtc app provided room id",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clientId",
            "doc": "The generated unique identifier of the client",
            "type": "string"
        },
        {
            "name": "userId",
            "doc": "webrtc app provided user identifier",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "peerConnectionId",
            "doc": "The unique identifier of the peer connection",
            "type": "string"
        },
        {
            "name": "label",
            "doc": "The webrtc app provided label the peer connection is labeled with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "trackId",
            "doc": "The id of the track",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sfuStreamId",
            "doc": "The id of the Sfu stream the media from",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sfuSinkId",
            "doc": "The id of the sink the Sfu streamed the media out",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "remoteTrackId",
            "doc": "The id of the remote track this inbound track is originated from",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "remoteUserId",
            "doc": "The webrtc app provided user id the track belongs to, or if the webrtc app did not provided the observer tried to match it",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "remoteClientId",
            "doc": "The observer matched remote client Id",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "remotePeerConnectionId",
            "doc": "The observer matched remote Peer Connection Id",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sampleSeq",
            "doc": "The sequence number of the sample the report is generated from",
            "type": "int"
        },
        {
            "name": "ssrc",
            "doc": "The RTP SSRC field",
            "type": "long"
        },
        {
            "name": "packetsReceived",
            "doc": "The total number of packets received on the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsLost",
            "doc": "The total number of bytes received on the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "jitter",
            "doc": "The corresponded synchronization source reported jitter",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "packetsDiscarded",
            "doc": "The total number of packets missed the playout point and therefore discarded by the jitterbuffer",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsRepaired",
            "doc": "The total number of packets repaired by either FEC or due to retransmission on the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstPacketsLost",
            "doc": "The total number of packets lost in burst (RFC6958)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstPacketsDiscarded",
            "doc": "The total number of packets discarded in burst (RFC6958)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstLossCount",
            "doc": "The total number of burst happened causes burstPacketsLost on the corresponding synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstDiscardCount",
            "doc": "The total number of burst happened causes burstPacketsDiscarded on the corresponding synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstLossRate",
            "doc": "The fraction of RTP packets lost during bursts proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "burstDiscardRate",
            "doc": "The fraction of RTP packets discarded during bursts proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "gapLossRate",
            "doc": "The fraction of RTP packets lost during gap proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "gapDiscardRate",
            "doc": "The fraction of RTP packets discarded during gap proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "framesDropped",
            "doc": "The total number of frames dropped at decoding process on the corresponding synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "partialFramesLost",
            "doc": "The total number of partial frames lost at decoding process on the corresponding synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "fullFramesLost",
            "doc": "The total number of full frames lost at decoding process on the corresponding synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "framesDecoded",
            "doc": "Indicate the number of frames completly and without error decoded on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "keyFramesDecoded",
            "doc": "Indicate the number of keyframes received on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "frameWidth",
            "doc": "Indicate the width of the frame received on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "frameHeight",
            "doc": "Indicate the height of the frame received on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "frameBitDepth",
            "doc": "Indicate the bit depth per pixel of the last decoded frame received on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "framesPerSecond",
            "doc": "Indicate the number of decoded frames in the last second received on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "qpSum",
            "doc": "sum of QP values of frames decoded on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "totalDecodeTime",
            "doc": "The total number of seconds spent on decoding frames on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "totalInterFrameDelay",
            "doc": "The total number of inter frame delay on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "totalSquaredInterFrameDelay",
            "doc": "The total number of inter frame delay squere on the corresponded synchronization source (ssrc) Useful for variance calculation for interframe delays",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "lastPacketReceivedTimestamp",
            "doc": "Represents the timestamp at which the last packet was received on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "averageRtcpInterval",
            "doc": "The average RTCP interval between two consecutive compound RTCP packets sent for the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "headerBytesReceived",
            "doc": "Total number of RTP header and padding bytes received over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "fecPacketsReceived",
            "doc": "Total number of FEC packets received over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "fecPacketsDiscarded",
            "doc": "Total number of FEC packets discarded over the corresponding synchronization source (ssrc) due to 1) late arrive; 2) the target RTP packet has already been repaired.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "bytesReceived",
            "doc": "Total number of bytes received over the corresponding synchronization source (ssrc) due to 1) late arrive; 2) the target RTP packet has already been repaired.",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "packetsFailedDecryption",
            "doc": "Total number of packets received and failed to decrypt over the corresponding synchronization source (ssrc) due to 1) late arrive; 2) the target RTP packet has already been repaired.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsDuplicated",
            "doc": "Total number of packets identified as duplicated over the corresponding synchronization source (ssrc).",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "perDscpPacketsReceived",
            "doc": "The total number of DSCP flagged RTP packets received over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "firCount",
            "doc": "Count the total number of Full Intra Request sent by this receiver and belongs to the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "pliCount",
            "doc": "Count the total number of Picture Loss Indication sent by this receiver and belongs to the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "nackCount",
            "doc": "Count the total number of Negative ACKnowledgement (NACK) packets sent and belongs to the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "sliCount",
            "doc": "Count the total number of Slice Loss Indication sent by this receiver and belongs to the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "totalProcessingDelay",
            "doc": "The total processing delay in seconds spend on buffering RTP packets from received up until packets are decoded",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "estimatedPlayoutTimestamp",
            "doc": "The estimated playout time of the corresponded synchronization source",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "jitterBufferDelay",
            "doc": "The total time of RTP packets spent in jitterbuffer waiting for frame completion due to network uncertenity.",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "jitterBufferEmittedCount",
            "doc": "The total number of audio samples or video frames that have come out of the jitter buffer on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "framesReceived",
            "doc": "Represents the total number of complete frames received on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "decoderImplementation",
            "doc": "Indicate the name of the decoder implementation library",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "packetsSent",
            "doc": "Total number of RTP packets sent at the remote endpoint to this endpoint on this synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "bytesSent",
            "doc": "Total number of payload bytes sent at the remote endpoint to this endpoint on this synchronization source",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "remoteTimestamp",
            "doc": "The timestamp corresnponds to the time in UTC Epoch the remote endpoint reported the statistics belong to the sender side and correspond to the synchronization source (ssrc)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "reportsSent",
            "doc": "The number of SR reports the remote endpoint sent corresponded to synchronization source (ssrc) this report belongs to",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "ended",
            "doc": "Flag represents if the receiver ended the media stream track or not.",
            "type": [
                "null",
                "boolean"
            ],
            "default": null
        },
        {
            "name": "payloadType",
            "doc": "The type of the payload the RTP packet SSRC belongs to",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "mimeType",
            "doc": "the MIME type of the codec (e.g.: video/vp8)",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clockRate",
            "doc": "The negotiated clock rate the RTP timestamp is generated of",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "sdpFmtpLine",
            "doc": "The a=fmtp line in the SDP corresponding to the codec",
            "type": [
                "null",
                "string"
            ],
            "default": null
        }
    ]
};

},{}],48:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "ObserverEventReport",
    "namespace": "org.observertc.schemas.reports",
    "doc": "A report created for observer generated events",
    "fields": [
        {
            "name": "serviceId",
            "doc": "The unique identifier of the service",
            "type": "string"
        },
        {
            "name": "mediaUnitId",
            "doc": "The media unit id the report belongs to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "marker",
            "doc": "The marker the originated sample is reported with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "timestamp",
            "doc": "The timestamp when the corresponded data is generated for the report (UTC Epoch in ms)",
            "type": "long"
        },
        {
            "name": "callId",
            "doc": "The generated unique identifier of the call",
            "type": "string"
        },
        {
            "name": "roomId",
            "doc": "webrtc app provided room id",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clientId",
            "doc": "The generated unique identifier of the client",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "userId",
            "doc": "webrtc app provided user identifier",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "peerConnectionId",
            "doc": "The unique identifier of the peer connection",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sampleTimestamp",
            "doc": "The timestamp of the sample the event related to",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "sampleSeq",
            "doc": "The sequence number of the sample the event may related to",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "name",
            "doc": "The name of the event",
            "type": "string"
        },
        {
            "name": "message",
            "doc": "the human readable message of the event",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "value",
            "doc": "the value of the event",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "attachments",
            "doc": "attachment the event may created with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        }
    ]
};

},{}],50:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "OutboundAudioTrackReport",
    "namespace": "org.observertc.schemas.reports",
    "doc": "A Report created for Outbound Audio Tracks. A combination of Audio source, Codec metadata carrying outbound and remote inbound RTP stat measurements",
    "fields": [
        {
            "name": "serviceId",
            "doc": "The unique identifier of the service",
            "type": "string"
        },
        {
            "name": "mediaUnitId",
            "doc": "The media unit id the report belongs to",
            "type": "string"
        },
        {
            "name": "marker",
            "doc": "The marker the originated sample is reported with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "timestamp",
            "doc": "The timestamp when the corresponded data is generated for the report (UTC Epoch in ms)",
            "type": "long"
        },
        {
            "name": "callId",
            "doc": "The generated unique identifier of the call",
            "type": "string"
        },
        {
            "name": "roomId",
            "doc": "webrtc app provided room id",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clientId",
            "doc": "The generated unique identifier of the client",
            "type": "string"
        },
        {
            "name": "userId",
            "doc": "webrtc app provided user identifier",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "peerConnectionId",
            "doc": "The unique identifier of the peer connection",
            "type": "string"
        },
        {
            "name": "label",
            "doc": "The webrtc app provided label the peer connection is labeled with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "trackId",
            "doc": "The id of the track",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sfuStreamId",
            "doc": "The id of the Sfu stream corresponds to the outbound track",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sampleSeq",
            "doc": "The sequence number of the sample the report is generated from",
            "type": "int"
        },
        {
            "name": "ssrc",
            "doc": "The RTP SSRC field",
            "type": "long"
        },
        {
            "name": "packetsSent",
            "doc": "The total number of packets sent on the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "bytesSent",
            "doc": "The total number of bytes sent on the corresponded synchronization source",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "rid",
            "doc": " The rid encoding parameter of the corresponded synchronization source",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "lastPacketSentTimestamp",
            "doc": " the timestamp the last packet was sent. (UTC epoch in ms)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "headerBytesSent",
            "doc": "Total number of RTP header and padding bytes sent over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "packetsDiscardedOnSend",
            "doc": "Total number of RTP packets discarded at sender side over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "bytesDiscardedOnSend",
            "doc": "Total number of RTP bytes discarded at sender side over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "fecPacketsSent",
            "doc": "Total number of FEC packets sent over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "retransmittedPacketsSent",
            "doc": "Total number of retransmitted packets sent over the corresponding synchronization source (ssrc).",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "retransmittedBytesSent",
            "doc": "Total number of retransmitted bytes sent over the corresponding synchronization source (ssrc).",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "targetBitrate",
            "doc": "Reflects the current encoder target in bits per second.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "totalEncodedBytesTarget",
            "doc": "The total number of bytes of RTP coherent frames encoded completly depending on the frame size the encoder targets",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "totalSamplesSent",
            "doc": "The total number of samples sent over the corresponding synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "samplesEncodedWithSilk",
            "doc": "The total number of samples encoded by SILK portion in opus sent over the corresponding synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "samplesEncodedWithCelt",
            "doc": "The total number of samples encoded by CELT portion in opus sent over the corresponding synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "voiceActivityFlag",
            "doc": "Indicate if the last RTP packet sent contained voice activity based on the presence of the V bit in the extension header",
            "type": [
                "null",
                "boolean"
            ],
            "default": null
        },
        {
            "name": "totalPacketSendDelay",
            "doc": "The total number of delay packets buffered at the sender side in seconds over the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "averageRtcpInterval",
            "doc": "The average RTCP interval between two consecutive compound RTCP packets sent for the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "perDscpPacketsSent",
            "doc": "The total number of DSCP flagged RTP packets sent over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "nackCount",
            "doc": "Count the total number of Negative ACKnowledgement (NACK) packets received over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "encoderImplementation",
            "doc": "Indicate the name of the encoder implementation library",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "packetsReceived",
            "doc": "The total number of packets received on the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsLost",
            "doc": "The total number of bytes received on the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "jitter",
            "doc": "The corresponded synchronization source reported jitter",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "packetsDiscarded",
            "doc": "The total number of packets missed the playout point and therefore discarded by the jitterbuffer",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsRepaired",
            "doc": "The total number of packets repaired by either FEC or due to retransmission on the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstPacketsLost",
            "doc": "The total number of packets lost in burst (RFC6958)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstPacketsDiscarded",
            "doc": "The total number of packets discarded in burst (RFC6958)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstLossCount",
            "doc": "The total number of burst happened causes burstPacketsLost on the corresponding synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstDiscardCount",
            "doc": "The total number of burst happened causes burstPacketsDiscarded on the corresponding synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstLossRate",
            "doc": "The fraction of RTP packets lost during bursts proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "burstDiscardRate",
            "doc": "The fraction of RTP packets discarded during bursts proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "gapLossRate",
            "doc": "The fraction of RTP packets lost during gap proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "gapDiscardRate",
            "doc": "The fraction of RTP packets discarded during gap proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "roundTripTime",
            "doc": "RTT measurement in seconds based on (most likely) SR, and RR belongs to the corresponded synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "totalRoundTripTime",
            "doc": "The sum of RTT measurements belongs to the corresponded synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "fractionLost",
            "doc": "The receiver reported fractional lost belongs to the corresponded synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "reportsReceived",
            "doc": "The total number of RR reports received, which is the base of the remote inbound calculation on this source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "roundTripTimeMeasurements",
            "doc": "The total number of calculated RR measurements received on this source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "relayedSource",
            "doc": "True if the corresponded media source is remote, false otherwise (or null depending on browser and version)",
            "type": [
                "null",
                "boolean"
            ],
            "default": null
        },
        {
            "name": "audioLevel",
            "doc": "Represents the audio level reported by the media source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "totalAudioEnergy",
            "doc": "Represents the energy level reported by the media source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "totalSamplesDuration",
            "doc": "Represents the total duration of the audio samples the media source actually transconverted in seconds",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "echoReturnLoss",
            "doc": "Represents the echo cancellation in decibels corresponded to the media source.",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "echoReturnLossEnhancement",
            "doc": "Represents the echo cancellation in decibels added as a postprocessing by the library after the audio is catched from the emdia source.",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "ended",
            "doc": "Flag represents if the sender ended the media stream track or not.",
            "type": [
                "null",
                "boolean"
            ],
            "default": null
        },
        {
            "name": "payloadType",
            "doc": "The type of the payload the RTP packet SSRC belongs to",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "mimeType",
            "doc": "the MIME type of the codec (e.g.: video/vp8)",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clockRate",
            "doc": "The negotiated clock rate the RTP timestamp is generated of",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "channels",
            "doc": "The number of channels for audio is used (in stereo it is 2, otherwise it is most likely null)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "sdpFmtpLine",
            "doc": "The a=fmtp line in the SDP corresponding to the codec",
            "type": [
                "null",
                "string"
            ],
            "default": null
        }
    ]
};

},{}],52:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "OutboundVideoTrackReport",
    "namespace": "org.observertc.schemas.reports",
    "doc": "A Report created for Outbound Video Tracks. A combination of Video source, Codec metadata carrying outbound and remote inbound RTP stat measurements",
    "fields": [
        {
            "name": "serviceId",
            "doc": "The unique identifier of the service",
            "type": "string"
        },
        {
            "name": "mediaUnitId",
            "doc": "The media unit id the report belongs to",
            "type": "string"
        },
        {
            "name": "marker",
            "doc": "The marker the originated sample is reported with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "timestamp",
            "doc": "The timestamp when the corresponded data is generated for the report (UTC Epoch in ms)",
            "type": "long"
        },
        {
            "name": "callId",
            "doc": "The generated unique identifier of the call",
            "type": "string"
        },
        {
            "name": "roomId",
            "doc": "webrtc app provided room id",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clientId",
            "doc": "The generated unique identifier of the client",
            "type": "string"
        },
        {
            "name": "userId",
            "doc": "webrtc app provided user identifier",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "peerConnectionId",
            "doc": "The unique identifier of the peer connection",
            "type": "string"
        },
        {
            "name": "label",
            "doc": "The webrtc app provided label the peer connection is labeled with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "trackId",
            "doc": "The id of the track",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sfuStreamId",
            "doc": "The id of the Sfu stream corresponds to the outbound track",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sampleSeq",
            "doc": "The sequence number of the sample the report is generated from",
            "type": "int"
        },
        {
            "name": "ssrc",
            "doc": "The RTP SSRC field",
            "type": "long"
        },
        {
            "name": "packetsSent",
            "doc": "The total number of packets sent on the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "bytesSent",
            "doc": "The total number of bytes sent on the corresponded synchronization source",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "rid",
            "doc": " The rid encoding parameter of the corresponded synchronization source",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "lastPacketSentTimestamp",
            "doc": " the timestamp the last packet was sent. (UTC epoch in ms)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "headerBytesSent",
            "doc": "Total number of RTP header and padding bytes sent over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "packetsDiscardedOnSend",
            "doc": "Total number of RTP packets discarded at sender side over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "bytesDiscardedOnSend",
            "doc": "Total number of RTP bytes discarded at sender side over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "fecPacketsSent",
            "doc": "Total number of FEC packets sent over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "retransmittedPacketsSent",
            "doc": "Total number of retransmitted packets sent over the corresponding synchronization source (ssrc).",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "retransmittedBytesSent",
            "doc": "Total number of retransmitted bytes sent over the corresponded synchronization source (ssrc).",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "targetBitrate",
            "doc": "Reflects the current encoder target in bits per second.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "totalEncodedBytesTarget",
            "doc": "The total number of bytes of RTP coherent frames encoded completly depending on the frame size the encoder targets",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "frameWidth",
            "doc": "Represents the height of the last encoded frame sent over the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "frameHeight",
            "doc": "Represents the width of the last encoded frame sent over the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "frameBitDepth",
            "doc": "Represents the bit depth per pixel of the last encoded frame sent over the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "framesPerSecond",
            "doc": "The number of encoded frames over the last second sent over the corresponded synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "framesSent",
            "doc": "The number of frames sent over the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "hugeFramesSent",
            "doc": "The number of huge frames (2.5x greater than the average size of frame) sent over the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "framesEncoded",
            "doc": "The number of frames encoded over the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "keyFramesEncoded",
            "doc": "The number of keyframes sent over the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "framesDiscardedOnSend",
            "doc": "The number of frames discarded before sending over the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "qpSum",
            "doc": "The sum of QP values encoded by the encoder corresponded to the synchronization source",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "totalEncodeTime",
            "doc": "The sum of encoding time spent by the encoder corresponded to the synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "totalPacketSendDelay",
            "doc": "The total number of delay packets buffered at the sender side in seconds over the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "averageRtcpInterval",
            "doc": "The average RTCP interval between two consecutive compound RTCP packets sent for the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "qualityLimitationDurationCPU",
            "doc": "Time elapsed in seconds when the the corresponding synchronization source (ssrc) was in a limited state due to CPU",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "qualityLimitationDurationNone",
            "doc": "Time elapsed in seconds when the the corresponding synchronization source (ssrc) was not in a limited state",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "qualityLimitationDurationBandwidth",
            "doc": "Time elapsed in seconds when the the corresponding synchronization source (ssrc) was in a limited state becasue of bandwidth",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "qualityLimitationDurationOther",
            "doc": "Time elapsed in seconds when the the corresponding synchronization source (ssrc) was in a limited state becaue of other factor",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "qualityLimitationReason",
            "doc": "Indicate a reason for the corresponding synchronization source (ssrc) quality is limited",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "qualityLimitationResolutionChanges",
            "doc": "The number of quality limiatation changes happened for the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "perDscpPacketsSent",
            "doc": "The total number of DSCP flagged RTP packets sent over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "nackCount",
            "doc": "Count the total number of Negative ACKnowledgement (NACK) packets received over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "firCount",
            "doc": "The number of full inter requests happened over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "pliCount",
            "doc": "The number of picture loss indication happened received over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "sliCount",
            "doc": "The number of slice loss indication happened over the corresponding synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "encoderImplementation",
            "doc": "Indicate the name of the encoder implementation library",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "packetsReceived",
            "doc": "The total number of packets received on the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsLost",
            "doc": "The total number of bytes received on the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "jitter",
            "doc": "The corresponded synchronization source reported jitter",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "packetsDiscarded",
            "doc": "The total number of packets missed the playout point and therefore discarded by the jitterbuffer",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsRepaired",
            "doc": "The total number of packets repaired by either FEC or due to retransmission on the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstPacketsLost",
            "doc": "The total number of packets lost in burst (RFC6958)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstPacketsDiscarded",
            "doc": "The total number of packets discarded in burst (RFC6958)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstLossCount",
            "doc": "The total number of burst happened causes burstPacketsLost on the corresponding synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstDiscardCount",
            "doc": "The total number of burst happened causes burstPacketsDiscarded on the corresponding synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "burstLossRate",
            "doc": "The fraction of RTP packets lost during bursts proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "burstDiscardRate",
            "doc": "The fraction of RTP packets discarded during bursts proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "gapLossRate",
            "doc": "The fraction of RTP packets lost during gap proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "gapDiscardRate",
            "doc": "The fraction of RTP packets discarded during gap proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "framesDropped",
            "doc": "The number of frames dropped over the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "partialFramesLost",
            "doc": "The number of partial frames lost over the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "fullFramesLost",
            "doc": "The number of full frames lost over the corresponded synchronization source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "roundTripTime",
            "doc": "RTT measurement in seconds based on (most likely) SR, and RR belongs to the corresponded synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "totalRoundTripTime",
            "doc": "The sum of RTT measurements belongs to the corresponded synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "fractionLost",
            "doc": "The receiver reported fractional lost belongs to the corresponded synchronization source",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "reportsReceived",
            "doc": "The total number of RR reports received, which is the base of the remote inbound calculation on this source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "roundTripTimeMeasurements",
            "doc": "The total number of calculated RR measurements received on this source",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "relayedSource",
            "doc": "True if the corresponded media source is remote, false otherwise (or null depending on browser and version)",
            "type": [
                "null",
                "boolean"
            ],
            "default": null
        },
        {
            "name": "encodedFrameWidth",
            "doc": "Indicate the encoded width of the frame received on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "encodedFrameHeight",
            "doc": "Indicate the encoded height of the frame received on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "encodedFrameBitDepth",
            "doc": "Indicate the encoded bit depth per pixel of the last decoded frame received on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "encodedFramesPerSecond",
            "doc": "Indicate the encoded number of decoded frames in the last second received on the corresponded synchronization source (ssrc)",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "ended",
            "doc": "Flag represents if the sender ended the media stream track or not.",
            "type": [
                "null",
                "boolean"
            ],
            "default": null
        },
        {
            "name": "payloadType",
            "doc": "The type of the payload the RTP packet SSRC belongs to",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "mimeType",
            "doc": "the MIME type of the codec (e.g.: video/vp8)",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clockRate",
            "doc": "The negotiated clock rate the RTP timestamp is generated of",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "channels",
            "doc": "The number of channels for audio is used (in stereo it is 2, otherwise it is most likely null)",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "sdpFmtpLine",
            "doc": "The a=fmtp line in the SDP corresponding to the codec",
            "type": [
                "null",
                "string"
            ],
            "default": null
        }
    ]
};

},{}],54:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "Report",
    "namespace": "org.observertc.schemas.reports",
    "doc": "A multiplexed Report object wraps an encoded report in bytes format",
    "fields": [
        {
            "name": "type",
            "doc": "The type of the report",
            "type": "string"
        },
        {
            "name": "schemaVersion",
            "doc": "The version of the schema the payload holds",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "payload",
            "doc": "The payload of contans the actual report",
            "type": "bytes"
        }
    ]
};

},{}],56:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "SFUTransportReport",
    "namespace": "org.observertc.schemas.reports",
    "doc": "A Report created for SFU Transport layer typically created to transfer RTP/SCTP/RTX streams to another client, SFU, MCU, or processing module.",
    "fields": [
        {
            "name": "serviceId",
            "doc": "The service id the report belongs to",
            "type": "string"
        },
        {
            "name": "mediaUnitId",
            "doc": "The media unit id the report belongs to",
            "type": "string"
        },
        {
            "name": "sfuId",
            "doc": "The provided unique identifier of the SFU",
            "type": "string"
        },
        {
            "name": "marker",
            "doc": "The marker the originated sample is reported with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "timestamp",
            "doc": "The timestamp when the corresponded data is generated for the report (UTC Epoch in ms)",
            "type": "long"
        },
        {
            "name": "callId",
            "doc": "The generated unique identifier of the call",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "roomId",
            "doc": "webrtc app provided room id",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "transportId",
            "doc": "The generated unique identifier of the transport",
            "type": "string"
        },
        {
            "name": "dtlsState",
            "doc": "Represent the current value of the state attribute of the underlying RTCDtlsTransport.",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "iceState",
            "doc": "Represent the current value of the state attribute of the underlying RTCIceTransport",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sctpState",
            "doc": "Represents the the current value of the SCTP state of the transport of the SFU",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "iceRole",
            "doc": "Represent the current value of the role SFU takes place in ICE",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "localAddress",
            "doc": "The local address of the ICE candidate selected for the transport (IPv4, IPv6, FQDN)",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "localPort",
            "doc": "The local port number",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "protocol",
            "doc": "The protocol used by the transport",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "remoteAddress",
            "doc": "The remote address of the ICE candidate selected for the transport (IPv4, IPv6, FQDN)",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "remotePort",
            "doc": "The remote port number",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "rtpBytesReceived",
            "doc": "The total amount of RTP bytes received on this transport",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "rtpBytesSent",
            "doc": "The total amount of RTP bytes sent on this transport",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "rtpPacketsReceived",
            "doc": "The total amount of RTP packets received on this transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "rtpPacketsSent",
            "doc": "The total amount of RTP packets sent on this transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "rtpPacketsLost",
            "doc": "The total amount of RTP packets lost on this transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "rtxBytesReceived",
            "doc": "The total amount of RTX bytes received on this transport",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "rtxBytesSent",
            "doc": "The total amount of RTX bytes sent on this transport",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "rtxPacketsReceived",
            "doc": "The total amount of RTX packets received on this transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "rtxPacketsSent",
            "doc": "The total amount of RTX packets sent on this transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "rtxPacketsLost",
            "doc": "The total amount of RTX packets lost on this transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "rtxPacketsDiscarded",
            "doc": "The total amount of RTX packets discarded on this transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "sctpBytesReceived",
            "doc": "The total amount of SCTP bytes received on this transport",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "sctpBytesSent",
            "doc": "The total amount of SCTP bytes sent on this transport",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "sctpPacketsReceived",
            "doc": "The total amount of SCTP packets received on this transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "sctpPacketsSent",
            "doc": "The total amount of SCTP packets sent on this transport",
            "type": [
                "null",
                "int"
            ],
            "default": null
        }
    ]
};

},{}],58:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "SfuEventReport",
    "namespace": "org.observertc.schemas.reports",
    "doc": "Events happened in calls.",
    "fields": [
        {
            "name": "serviceId",
            "doc": "The service id the report belongs to",
            "type": "string"
        },
        {
            "name": "mediaUnitId",
            "doc": "The media unit id the report belongs to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "marker",
            "doc": "The marker the originated sample is reported with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "timestamp",
            "doc": "The timestamp when the corresponded data is generated for the report (UTC Epoch in ms)",
            "type": "long"
        },
        {
            "name": "sfuId",
            "doc": "The generated unique identifier of the SFU",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "callId",
            "doc": "The callId the event belongs to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "transportId",
            "doc": "SFU provided transport identifier",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "mediaStreamId",
            "doc": "Unique identifier of the SFU stream id the rtp pad belongs to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "mediaSinkId",
            "doc": "Unique identifier of the SFU stream id the rtp pad belongs to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sctpStreamId",
            "doc": "Unique identifier of the SCTP stream the event is related to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "rtpPadId",
            "doc": "Unique identifier of the Sfu Pad the event is related to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "name",
            "doc": "The name of the event. Possible values are: SFU_JOINED, SFU_LEFT, SFU_TRANSPORT_OPENED, SFU_TRANSPORT_CLOSED, SFU_RTP_STREAM_ADDED, SFU_RTP_STREAM_REMOVED",
            "type": "string"
        },
        {
            "name": "message",
            "doc": "the human readable message of the event",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "value",
            "doc": "the value of the event",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "attachments",
            "doc": "attachment the event may created with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        }
    ]
};

},{}],60:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "SfuExtensionReport",
    "namespace": "org.observertc.schemas.reports",
    "doc": "A Report created for Extended provided arbitrary data.",
    "fields": [
        {
            "name": "serviceId",
            "doc": "The service id the report belongs to",
            "type": "string"
        },
        {
            "name": "mediaUnitId",
            "doc": "The media unit id the report belongs to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "marker",
            "doc": "The marker the originated sample is reported with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "timestamp",
            "doc": "The timestamp when the corresponded data is generated for the report (UTC Epoch in ms)",
            "type": "long"
        },
        {
            "name": "sfuId",
            "doc": "The generated unique identifier of the SFU",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "extensionType",
            "doc": "The name of the event",
            "type": "string"
        },
        {
            "name": "payload",
            "doc": "the human readable message of the event",
            "type": [
                "null",
                "string"
            ],
            "default": null
        }
    ]
};

},{}],62:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "SfuInboundRtpPadReport",
    "namespace": "org.observertc.schemas.reports",
    "doc": "A Report created for RTP streams going through the SFU",
    "fields": [
        {
            "name": "serviceId",
            "doc": "The service id the report belongs to",
            "type": "string"
        },
        {
            "name": "mediaUnitId",
            "doc": "The media unit id the report belongs to",
            "type": "string"
        },
        {
            "name": "sfuId",
            "doc": "The provided unique identifier of the SFU",
            "type": "string"
        },
        {
            "name": "marker",
            "doc": "The marker the originated sample is reported with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "internal",
            "doc": "Flag indicate if the sfu rtp pad is used as an internal rtp session between SFUs",
            "type": [
                "null",
                "boolean"
            ],
            "default": null
        },
        {
            "name": "timestamp",
            "doc": "The timestamp when the corresponded data is generated for the report (UTC Epoch in ms)",
            "type": "long"
        },
        {
            "name": "transportId",
            "doc": "The id of the transport the RTP stream uses.",
            "type": "string"
        },
        {
            "name": "sfuStreamId",
            "doc": "Unique identifier of the Sfu stream the event is related to",
            "type": "string"
        },
        {
            "name": "rtpPadId",
            "doc": "The id of RTP pad.",
            "type": "string"
        },
        {
            "name": "ssrc",
            "doc": "The synchronization source id of the RTP stream",
            "type": "long"
        },
        {
            "name": "trackId",
            "doc": "The id of the track the RTP stream related to at the client side",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clientId",
            "doc": "If the track id was provided by the Sfu, the observer can fill up the information of which client it belongs to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "callId",
            "doc": "The callId the event belongs to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "mediaType",
            "doc": "the type of the media the stream carries (\"audio\" or \"video\")",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "payloadType",
            "doc": "The payload type field of the RTP header",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "mimeType",
            "doc": "The negotiated mimeType in the SDP",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clockRate",
            "doc": "The clock rate of the media source the RTP header carries",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "sdpFmtpLine",
            "doc": "The actual SDP line from the negotiation related to this RTP stream",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "rid",
            "doc": " The rid parameter of the corresponded RTP stream",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "rtxSsrc",
            "doc": "If RTX is negotiated as a separate stream, this is the SSRC of the RTX stream that is associated with this stream's ssrc. ",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "targetBitrate",
            "doc": "he bitrate the corresponded stream targets.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "voiceActivityFlag",
            "doc": "The RTP header V flag indicate of the activity of the media source by the media codec if the RTP transport ships it through",
            "type": [
                "null",
                "boolean"
            ],
            "default": null
        },
        {
            "name": "firCount",
            "doc": "The total number FIR packets sent from this endpoint to the source on the corresponded RTP stream. Only for Video streams",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "pliCount",
            "doc": "The total number of Picture Loss Indication sent on the corresponded RTP stream. Only for Video streams",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "nackCount",
            "doc": "The total number of negative acknowledgement received on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "sliCount",
            "doc": "The total number of SLI indicator sent from the endpoint on the corresponded RTP stream. Only for Audio stream",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsLost",
            "doc": "The total number of packets lost on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsReceived",
            "doc": "The total number of packets received on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsDiscarded",
            "doc": "The total number of discarded packets on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsRepaired",
            "doc": "The total number of packets repaired by either retransmission or FEC on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsFailedDecryption",
            "doc": "The total number of packets failed to be decrypted on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsDuplicated",
            "doc": "The total number of duplicated packets appeared on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "fecPacketsReceived",
            "doc": "The total number of FEC packets received on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "fecPacketsDiscarded",
            "doc": "The total number of FEC packets discarded on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "bytesReceived",
            "doc": "The total amount of payload bytes received on the corresponded RTP stream.",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "rtcpSrReceived",
            "doc": "The total number of SR reports received by the corresponded RTP stream",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "rtcpRrSent",
            "doc": "The total number of RR reports sent on the corresponded RTP stream",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "rtxPacketsReceived",
            "doc": "If rtx packets are sent or received on the same stream then this number indicates how may has been sent",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "rtxPacketsDiscarded",
            "doc": "If rtx packets are received on the same stream then this number indicates how may has been discarded",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "framesReceived",
            "doc": "The number of frames received on the corresponded RTP stream",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "framesDecoded",
            "doc": "Indicate the number of frames the Sfu has been decoded",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "keyFramesDecoded",
            "doc": "Indicate the number of keyframes the Sfu has been decoded",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "fractionLost",
            "doc": "The calculated fractionLost of the stream",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "jitter",
            "doc": "The calculated jitter of the stream",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "roundTripTime",
            "doc": "The calculated RTT of the stream",
            "type": [
                "null",
                "double"
            ],
            "default": null
        }
    ]
};

},{}],64:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "SfuMetaReport",
    "namespace": "org.observertc.schemas.reports",
    "doc": "Metadata belongs to SFUs",
    "fields": [
        {
            "name": "serviceId",
            "doc": "The service id the report belongs to",
            "type": "string"
        },
        {
            "name": "mediaUnitId",
            "doc": "The media unit id the report belongs to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "marker",
            "doc": "The marker the originated sample is reported with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "timestamp",
            "doc": "The timestamp when the corresponded data is generated for the report (UTC Epoch in ms)",
            "type": "long"
        },
        {
            "name": "sfuId",
            "doc": "The generated unique identifier of the SFU",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "callId",
            "doc": "The callId the event belongs to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "transportId",
            "doc": "SFU provided transport identifier",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "mediaStreamId",
            "doc": "Unique identifier of the SFU stream id the rtp pad belongs to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "mediaSinkId",
            "doc": "Unique identifier of the SFU stream id the rtp pad belongs to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sctpStreamId",
            "doc": "Unique identifier of the SCTP stream the event is related to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "rtpPadId",
            "doc": "Unique identifier of the Sfu Pad the event is related to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "type",
            "doc": "The type of the meta data reported for the peer connection",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "payload",
            "doc": "The payload for the metadata reported for the peeer connection",
            "type": [
                "null",
                "string"
            ],
            "default": null
        }
    ]
};

},{}],66:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "SfuOutboundRtpPadReport",
    "namespace": "org.observertc.schemas.reports",
    "doc": "A Report created for RTP streams going through the SFU",
    "fields": [
        {
            "name": "serviceId",
            "doc": "The service id the report belongs to",
            "type": "string"
        },
        {
            "name": "mediaUnitId",
            "doc": "The media unit id the report belongs to",
            "type": "string"
        },
        {
            "name": "sfuId",
            "doc": "The provided unique identifier of the SFU",
            "type": "string"
        },
        {
            "name": "marker",
            "doc": "The marker the originated sample is reported with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "internal",
            "doc": "Flag indicate if the sfu rtp pad is used as an internal rtp session between SFUs",
            "type": [
                "null",
                "boolean"
            ],
            "default": null
        },
        {
            "name": "timestamp",
            "doc": "The timestamp when the corresponded data is generated for the report (UTC Epoch in ms)",
            "type": "long"
        },
        {
            "name": "transportId",
            "doc": "The id of the transport the RTP stream uses.",
            "type": "string"
        },
        {
            "name": "sfuStreamId",
            "doc": "Unique identifier of the Sfu stream the event is related to",
            "type": "string"
        },
        {
            "name": "sfuSinkId",
            "doc": "Unique identifier of the Sfu sink the event is related to",
            "type": "string"
        },
        {
            "name": "rtpPadId",
            "doc": "The id of RTP pad.",
            "type": "string"
        },
        {
            "name": "ssrc",
            "doc": "The synchronization source id of the RTP stream",
            "type": "long"
        },
        {
            "name": "callId",
            "doc": "The callId the event belongs to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clientId",
            "doc": "If the track id was provided by the Sfu, the observer can fill up the information of which client it belongs to",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "trackId",
            "doc": "The id of the track the RTP stream related to at the client side",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "mediaType",
            "doc": "the type of the media the stream carries (\"audio\" or \"video\")",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "payloadType",
            "doc": "The payload type field of the RTP header",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "mimeType",
            "doc": "The negotiated mimeType in the SDP",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "clockRate",
            "doc": "The clock rate of the media source the RTP header carries",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "sdpFmtpLine",
            "doc": "The actual SDP line from the negotiation related to this RTP stream",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "rid",
            "doc": " The rid parameter of the corresponded RTP stream",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "rtxSsrc",
            "doc": "If RTX is negotiated as a separate stream, this is the SSRC of the RTX stream that is associated with this stream's ssrc. ",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "targetBitrate",
            "doc": "he bitrate the corresponded stream targets.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "voiceActivityFlag",
            "doc": "The RTP header V flag indicate of the activity of the media source by the media codec if the RTP transport ships it through",
            "type": [
                "null",
                "boolean"
            ],
            "default": null
        },
        {
            "name": "firCount",
            "doc": "The total number FIR packets sent from this endpoint to the source on the corresponded RTP stream. Only for Video streams",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "pliCount",
            "doc": "The total number of Picture Loss Indication sent on the corresponded RTP stream. Only for Video streams",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "nackCount",
            "doc": "The total number of negative acknowledgement received on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "sliCount",
            "doc": "The total number of SLI indicator sent from the endpoint on the corresponded RTP stream. Only for Audio stream",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsLost",
            "doc": "The total number of packets lost on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsSent",
            "doc": "The total number of packets sent on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsDiscarded",
            "doc": "The total number of discarded packets on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsRetransmitted",
            "doc": "The total number of packets retransmitted on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsFailedEncryption",
            "doc": "The total number of packets failed to be encrypted on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "packetsDuplicated",
            "doc": "The total number of duplicated packets appeared on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "fecPacketsSent",
            "doc": "The total number of FEC packets sent on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "fecPacketsDiscarded",
            "doc": "The total number of FEC packets discarded on the corresponded RTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "bytesSent",
            "doc": "The total amount of payload bytes sent on the corresponded RTP stream.",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "rtcpSrSent",
            "doc": "The total number of SR reports sent by the corresponded RTP stream",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "rtcpRrReceived",
            "doc": "The total number of RR reports received on the corresponded RTP stream",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "rtxPacketsSent",
            "doc": "If rtx packets sent on the same stream then this number indicates how may has been sent",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "rtxPacketsDiscarded",
            "doc": "If rtx packets are received on the same stream then this number indicates how may has been discarded",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "framesSent",
            "doc": "The number of frames sent on the corresponded RTP stream",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "framesEncoded",
            "doc": "Indicate the number of frames the Sfu has been encoded",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "keyFramesEncoded",
            "doc": "Indicate the number of keyframes the Sfu has been encoded on the corresponded RTP stream",
            "type": [
                "null",
                "int"
            ],
            "default": null
        }
    ]
};

},{}],68:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "SfuSctpStreamReport",
    "namespace": "org.observertc.schemas.reports",
    "doc": "A Report created for SCTP streams going through the SFU",
    "fields": [
        {
            "name": "serviceId",
            "doc": "The service id the report belongs to",
            "type": "string"
        },
        {
            "name": "mediaUnitId",
            "doc": "The media unit id the report belongs to",
            "type": "string"
        },
        {
            "name": "sfuId",
            "doc": "The provided unique identifier of the SFU",
            "type": "string"
        },
        {
            "name": "marker",
            "doc": "The marker the originated sample is reported with",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "timestamp",
            "doc": "The timestamp when the corresponded data is generated for the report (UTC Epoch in ms)",
            "type": "long"
        },
        {
            "name": "callId",
            "doc": "The generated unique identifier of the call",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "roomId",
            "doc": "webrtc app provided room id",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "transportId",
            "doc": "The id of the transport the RTP stream uses.",
            "type": "string"
        },
        {
            "name": "streamId",
            "doc": "The id of the sctp stream",
            "type": "string"
        },
        {
            "name": "label",
            "doc": "The label of the sctp stream",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "protocol",
            "doc": "The protocol used to establish an sctp stream",
            "type": [
                "null",
                "string"
            ],
            "default": null
        },
        {
            "name": "sctpSmoothedRoundTripTime",
            "doc": "The latest smoothed round-trip time value, corresponding to spinfo_srtt defined in [RFC6458] but converted to seconds. If there has been no round-trip time measurements yet, this value is undefined.",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "sctpCongestionWindow",
            "doc": "The latest congestion window, corresponding to spinfo_cwnd defined in [RFC6458].",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "sctpReceiverWindow",
            "doc": "The latest receiver window, corresponding to sstat_rwnd defined in [RFC6458].",
            "type": [
                "null",
                "double"
            ],
            "default": null
        },
        {
            "name": "sctpMtu",
            "doc": "The latest maximum transmission unit, corresponding to spinfo_mtu defined in [RFC6458].",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "sctpUnackData",
            "doc": "The number of unacknowledged DATA chunks, corresponding to sstat_unackdata defined in [RFC6458].",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "messageReceived",
            "doc": "The number of message received on the corresponded SCTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "messageSent",
            "doc": "The number of message sent on the corresponded SCTP stream.",
            "type": [
                "null",
                "int"
            ],
            "default": null
        },
        {
            "name": "bytesReceived",
            "doc": "The number of bytes received on the corresponded SCTP stream.",
            "type": [
                "null",
                "long"
            ],
            "default": null
        },
        {
            "name": "bytesSent",
            "doc": "The number of bytes sent on the corresponded SCTP stream.",
            "type": [
                "null",
                "long"
            ],
            "default": null
        }
    ]
};

},{}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = `
syntax = "proto2";

package org.observertc.schemas.protobuf;

message Samples {
	message SamplesMeta {
		optional string schemaVersion = 1;
	}
	message ControlFlags {
		optional bool close = 1;
	}
	message ClientSample {
		message Engine {
			optional string name = 1;
			optional string version = 2;
		}
		message Platform {
			optional string model = 1;
			optional string type = 2;
			optional string vendor = 3;
		}
		message Browser {
			optional string name = 1;
			optional string version = 2;
		}
		message OperationSystem {
			optional string name = 1;
			optional string version = 2;
			optional string versionName = 3;
		}
		message MediaDevice {
			optional string id = 1;
			optional string kind = 2;
			optional string label = 3;
		}
		message ExtensionStat {
			required string payload = 1;
			required string type = 2;
		}
		message PeerConnectionTransport {
			required string peerConnectionId = 1;
			optional int64 bytesReceived = 2;
			optional int64 bytesSent = 3;
			optional double candidatePairAvailableIncomingBitrate = 4;
			optional double candidatePairAvailableOutgoingBitrate = 5;
			optional int64 candidatePairBytesDiscardedOnSend = 6;
			optional int64 candidatePairBytesReceived = 7;
			optional int64 candidatePairBytesSent = 8;
			optional int32 candidatePairCircuitBreakerTriggerCount = 9;
			optional int64 candidatePairConsentExpiredTimestamp = 10;
			optional int64 candidatePairConsentRequestBytesSent = 11;
			optional int32 candidatePairConsentRequestsSent = 12;
			optional double candidatePairCurrentRoundTripTime = 13;
			optional int64 candidatePairFirstRequestTimestamp = 14;
			optional int64 candidatePairLastPacketReceivedTimestamp = 15;
			optional int64 candidatePairLastPacketSentTimestamp = 16;
			optional int64 candidatePairLastRequestTimestamp = 17;
			optional int64 candidatePairLastResponseTimestamp = 18;
			optional int32 candidatePairPacketsDiscardedOnSend = 19;
			optional int32 candidatePairPacketsReceived = 20;
			optional int32 candidatePairPacketsSent = 21;
			optional int64 candidatePairRequestBytesSent = 22;
			optional int32 candidatePairRequestsReceived = 23;
			optional int32 candidatePairRequestsSent = 24;
			optional int64 candidatePairResponseBytesSent = 25;
			optional int32 candidatePairResponsesReceived = 26;
			optional int32 candidatePairResponsesSent = 27;
			optional int32 candidatePairRetransmissionReceived = 28;
			optional int32 candidatePairRetransmissionSent = 29;
			optional string candidatePairState = 30;
			optional double candidatePairTotalRoundTripTime = 31;
			optional int32 dataChannelsAccepted = 32;
			optional int32 dataChannelsClosed = 33;
			optional int32 dataChannelsOpened = 34;
			optional int32 dataChannelsRequested = 35;
			optional string dtlsCipher = 36;
			optional string dtlsState = 37;
			optional string iceLocalUsernameFragment = 38;
			optional string iceRole = 39;
			optional string iceState = 40;
			optional string label = 41;
			optional string localAddress = 42;
			optional string localCandidateICEServerUrl = 43;
			optional string localCandidateRelayProtocol = 44;
			optional string localCandidateType = 45;
			optional int32 localPort = 46;
			optional string localProtocol = 47;
			optional int32 packetsReceived = 48;
			optional int32 packetsSent = 49;
			optional string remoteAddress = 50;
			optional string remoteCandidateICEServerUrl = 51;
			optional string remoteCandidateRelayProtocol = 52;
			optional string remoteCandidateType = 53;
			optional int32 remotePort = 54;
			optional string remoteProtocol = 55;
			optional double sctpCongestionWindow = 56;
			optional int32 sctpMtu = 57;
			optional double sctpReceiverWindow = 58;
			optional double sctpSmoothedRoundTripTime = 59;
			optional int32 sctpUnackData = 60;
			optional int32 selectedCandidatePairChanges = 61;
			optional string srtpCipher = 62;
			optional string tlsGroup = 63;
			optional string tlsVersion = 64;
		}
		message MediaSourceStat {
			optional double audioLevel = 1;
			optional int32 bitDepth = 2;
			optional double echoReturnLoss = 3;
			optional double echoReturnLossEnhancement = 4;
			optional int32 frames = 5;
			optional double framesPerSecond = 6;
			optional int32 height = 7;
			optional string kind = 8;
			optional bool relayedSource = 9;
			optional double totalAudioEnergy = 10;
			optional double totalSamplesDuration = 11;
			optional string trackIdentifier = 12;
			optional int32 width = 13;
		}
		message MediaCodecStats {
			optional int32 channels = 1;
			optional int32 clockRate = 2;
			optional string codecType = 3;
			optional string mimeType = 4;
			optional string payloadType = 5;
			optional string sdpFmtpLine = 6;
		}
		message Certificate {
			optional string base64Certificate = 1;
			optional string fingerprint = 2;
			optional string fingerprintAlgorithm = 3;
			optional string issuerCertificateId = 4;
		}
		message InboundAudioTrack {
			required int64 ssrc = 1;
			optional double averageRtcpInterval = 2;
			optional int32 burstDiscardCount = 3;
			optional double burstDiscardRate = 4;
			optional int32 burstLossCount = 5;
			optional double burstLossRate = 6;
			optional int32 burstPacketsDiscarded = 7;
			optional int32 burstPacketsLost = 8;
			optional int64 bytesReceived = 9;
			optional int64 bytesSent = 10;
			optional int32 channels = 11;
			optional int32 clockRate = 12;
			optional int32 concealedSamples = 13;
			optional int32 concealmentEvents = 14;
			optional string decoderImplementation = 15;
			optional bool ended = 16;
			optional int64 estimatedPlayoutTimestamp = 17;
			optional int32 fecPacketsDiscarded = 18;
			optional int32 fecPacketsReceived = 19;
			optional double gapDiscardRate = 20;
			optional double gapLossRate = 21;
			optional int64 headerBytesReceived = 22;
			optional int32 insertedSamplesForDeceleration = 23;
			optional double jitter = 24;
			optional double jitterBufferDelay = 25;
			optional int32 jitterBufferEmittedCount = 26;
			optional int64 lastPacketReceivedTimestamp = 27;
			optional string mimeType = 28;
			optional int32 nackCount = 29;
			optional int32 packetsDiscarded = 30;
			optional int32 packetsDuplicated = 31;
			optional int32 packetsFailedDecryption = 32;
			optional int32 packetsLost = 33;
			optional int32 packetsReceived = 34;
			optional int32 packetsRepaired = 35;
			optional int32 packetsSent = 36;
			optional int32 payloadType = 37;
			optional string peerConnectionId = 38;
			optional int32 perDscpPacketsReceived = 39;
			optional string remoteClientId = 40;
			optional int64 remoteTimestamp = 41;
			optional int32 removedSamplesForAcceleration = 42;
			optional int32 reportsSent = 43;
			optional double roundTripTime = 44;
			optional int32 roundTripTimeMeasurements = 45;
			optional int32 samplesDecodedWithCelt = 46;
			optional int32 samplesDecodedWithSilk = 47;
			optional string sdpFmtpLine = 48;
			optional string sfuSinkId = 49;
			optional int32 silentConcealedSamples = 50;
			optional double totalProcessingDelay = 51;
			optional double totalRoundTripTime = 52;
			optional int32 totalSamplesDecoded = 53;
			optional int32 totalSamplesReceived = 54;
			optional string trackId = 55;
			optional bool voiceActivityFlag = 56;
		}
		message InboundVideoTrack {
			required int64 ssrc = 1;
			optional double averageRtcpInterval = 2;
			optional int32 burstDiscardCount = 3;
			optional double burstDiscardRate = 4;
			optional int32 burstLossCount = 5;
			optional double burstLossRate = 6;
			optional int32 burstPacketsDiscarded = 7;
			optional int32 burstPacketsLost = 8;
			optional int64 bytesReceived = 9;
			optional int64 bytesSent = 10;
			optional int32 channels = 11;
			optional int32 clockRate = 12;
			optional string decoderImplementation = 13;
			optional bool ended = 14;
			optional int64 estimatedPlayoutTimestamp = 15;
			optional int32 fecPacketsDiscarded = 16;
			optional int32 fecPacketsReceived = 17;
			optional int32 firCount = 18;
			optional int32 frameBitDepth = 19;
			optional int32 frameHeight = 20;
			optional int32 frameWidth = 21;
			optional int32 framesDecoded = 22;
			optional int32 framesDropped = 23;
			optional double framesPerSecond = 24;
			optional int32 framesReceived = 25;
			optional int32 fullFramesLost = 26;
			optional double gapDiscardRate = 27;
			optional double gapLossRate = 28;
			optional int64 headerBytesReceived = 29;
			optional double jitter = 30;
			optional double jitterBufferDelay = 31;
			optional int32 jitterBufferEmittedCount = 32;
			optional int32 keyFramesDecoded = 33;
			optional int64 lastPacketReceivedTimestamp = 34;
			optional string mimeType = 35;
			optional int32 nackCount = 36;
			optional int32 packetsDiscarded = 37;
			optional int32 packetsDuplicated = 38;
			optional int32 packetsFailedDecryption = 39;
			optional int32 packetsLost = 40;
			optional int32 packetsReceived = 41;
			optional int32 packetsRepaired = 42;
			optional int32 packetsSent = 43;
			optional int32 partialFramesLost = 44;
			optional int32 payloadType = 45;
			optional string peerConnectionId = 46;
			optional int32 perDscpPacketsReceived = 47;
			optional int32 pliCount = 48;
			optional int64 qpSum = 49;
			optional string remoteClientId = 50;
			optional int64 remoteTimestamp = 51;
			optional int32 reportsSent = 52;
			optional double roundTripTime = 53;
			optional int32 roundTripTimeMeasurements = 54;
			optional string sdpFmtpLine = 55;
			optional string sfuSinkId = 56;
			optional int32 sliCount = 57;
			optional double totalDecodeTime = 58;
			optional double totalInterFrameDelay = 59;
			optional double totalProcessingDelay = 60;
			optional double totalRoundTripTime = 61;
			optional double totalSquaredInterFrameDelay = 62;
			optional string trackId = 63;
		}
		message OutboundAudioTrack {
			required int64 ssrc = 1;
			optional double audioLevel = 2;
			optional double averageRtcpInterval = 3;
			optional int32 burstDiscardCount = 4;
			optional double burstDiscardRate = 5;
			optional int32 burstLossCount = 6;
			optional double burstLossRate = 7;
			optional int32 burstPacketsDiscarded = 8;
			optional int32 burstPacketsLost = 9;
			optional int64 bytesDiscardedOnSend = 10;
			optional int64 bytesSent = 11;
			optional int32 channels = 12;
			optional int32 clockRate = 13;
			optional double echoReturnLoss = 14;
			optional double echoReturnLossEnhancement = 15;
			optional string encoderImplementation = 16;
			optional bool ended = 17;
			optional int32 fecPacketsSent = 18;
			optional double fractionLost = 19;
			optional double gapDiscardRate = 20;
			optional double gapLossRate = 21;
			optional int64 headerBytesSent = 22;
			optional double jitter = 23;
			optional int64 lastPacketSentTimestamp = 24;
			optional string mimeType = 25;
			optional int32 nackCount = 26;
			optional int32 packetsDiscarded = 27;
			optional int32 packetsDiscardedOnSend = 28;
			optional int32 packetsLost = 29;
			optional int32 packetsReceived = 30;
			optional int32 packetsRepaired = 31;
			optional int32 packetsSent = 32;
			optional int32 payloadType = 33;
			optional string peerConnectionId = 34;
			optional int32 perDscpPacketsSent = 35;
			optional bool relayedSource = 36;
			optional int32 reportsReceived = 37;
			optional int64 retransmittedBytesSent = 38;
			optional int32 retransmittedPacketsSent = 39;
			optional string rid = 40;
			optional double roundTripTime = 41;
			optional int32 roundTripTimeMeasurements = 42;
			optional int64 rtxSsrc = 43;
			optional int32 samplesEncodedWithCelt = 44;
			optional int32 samplesEncodedWithSilk = 45;
			optional string sdpFmtpLine = 46;
			optional string sfuStreamId = 47;
			optional int32 targetBitrate = 48;
			optional double totalAudioEnergy = 49;
			optional int64 totalEncodedBytesTarget = 50;
			optional double totalPacketSendDelay = 51;
			optional double totalRoundTripTime = 52;
			optional double totalSamplesDuration = 53;
			optional int32 totalSamplesSent = 54;
			optional string trackId = 55;
			optional bool voiceActivityFlag = 56;
		}
		message OutboundVideoTrack {
			required int64 ssrc = 1;
			optional double averageRtcpInterval = 2;
			optional int32 bitDepth = 3;
			optional int32 burstDiscardCount = 4;
			optional double burstDiscardRate = 5;
			optional int32 burstLossCount = 6;
			optional double burstLossRate = 7;
			optional int32 burstPacketsDiscarded = 8;
			optional int32 burstPacketsLost = 9;
			optional int64 bytesDiscardedOnSend = 10;
			optional int64 bytesSent = 11;
			optional int32 channels = 12;
			optional int32 clockRate = 13;
			optional string encoderImplementation = 14;
			optional bool ended = 15;
			optional int32 fecPacketsSent = 16;
			optional int32 firCount = 17;
			optional double fractionLost = 18;
			optional int32 frameBitDepth = 19;
			optional int32 frameHeight = 20;
			optional int32 frameWidth = 21;
			optional int32 frames = 22;
			optional int32 framesDiscardedOnSend = 23;
			optional int32 framesDropped = 24;
			optional int32 framesEncoded = 25;
			optional double framesPerSecond = 26;
			optional int32 framesSent = 27;
			optional int32 fullFramesLost = 28;
			optional double gapDiscardRate = 29;
			optional double gapLossRate = 30;
			optional int64 headerBytesSent = 31;
			optional int32 height = 32;
			optional int32 hugeFramesSent = 33;
			optional double jitter = 34;
			optional int32 keyFramesEncoded = 35;
			optional int64 lastPacketSentTimestamp = 36;
			optional string mimeType = 37;
			optional int32 nackCount = 38;
			optional int32 packetsDiscarded = 39;
			optional int32 packetsDiscardedOnSend = 40;
			optional int32 packetsLost = 41;
			optional int32 packetsReceived = 42;
			optional int32 packetsRepaired = 43;
			optional int32 packetsSent = 44;
			optional int32 partialFramesLost = 45;
			optional int32 payloadType = 46;
			optional string peerConnectionId = 47;
			optional int32 perDscpPacketsSent = 48;
			optional int32 pliCount = 49;
			optional int64 qpSum = 50;
			optional double qualityLimitationDurationBandwidth = 51;
			optional double qualityLimitationDurationCPU = 52;
			optional double qualityLimitationDurationNone = 53;
			optional double qualityLimitationDurationOther = 54;
			optional string qualityLimitationReason = 55;
			optional int32 qualityLimitationResolutionChanges = 56;
			optional bool relayedSource = 57;
			optional int32 reportsReceived = 58;
			optional int64 retransmittedBytesSent = 59;
			optional int32 retransmittedPacketsSent = 60;
			optional string rid = 61;
			optional double roundTripTime = 62;
			optional int32 roundTripTimeMeasurements = 63;
			optional int64 rtxSsrc = 64;
			optional string sdpFmtpLine = 65;
			optional string sfuStreamId = 66;
			optional int32 sliCount = 67;
			optional int32 targetBitrate = 68;
			optional double totalEncodeTime = 69;
			optional int64 totalEncodedBytesTarget = 70;
			optional double totalPacketSendDelay = 71;
			optional double totalRoundTripTime = 72;
			optional string trackId = 73;
			optional int32 width = 74;
		}
		message IceLocalCandidate {
			optional string address = 1;
			optional string candidateType = 2;
			optional string id = 3;
			optional string peerConnectionId = 4;
			optional int32 port = 5;
			optional int64 priority = 6;
			optional string protocol = 7;
			optional string relayProtocol = 8;
			optional string url = 9;
		}
		message IceRemoteCandidate {
			optional string address = 1;
			optional string candidateType = 2;
			optional string id = 3;
			optional string peerConnectionId = 4;
			optional int32 port = 5;
			optional int64 priority = 6;
			optional string protocol = 7;
			optional string relayProtocol = 8;
			optional string url = 9;
		}
		message DataChannel {
			optional string address = 1;
			optional int64 bytesReceived = 2;
			optional int64 bytesSent = 3;
			optional int32 dataChannelIdentifier = 4;
			optional string id = 5;
			optional string label = 6;
			optional int32 messagesReceived = 7;
			optional int32 messagesSent = 8;
			optional string peerConnectionId = 9;
			optional int32 port = 10;
			optional string protocol = 11;
			optional string state = 12;
		}
		repeated Certificate certificates = 1;
		repeated MediaCodecStats codecs = 2;
		repeated DataChannel dataChannels = 3;
		repeated ExtensionStat extensionStats = 4;
		repeated IceLocalCandidate iceLocalCandidates = 5;
		repeated IceRemoteCandidate iceRemoteCandidates = 6;
		repeated string iceServers = 7;
		repeated InboundAudioTrack inboundAudioTracks = 8;
		repeated InboundVideoTrack inboundVideoTracks = 9;
		repeated string localSDPs = 10;
		repeated string mediaConstraints = 11;
		repeated MediaDevice mediaDevices = 12;
		repeated MediaSourceStat mediaSources = 13;
		repeated OutboundAudioTrack outboundAudioTracks = 14;
		repeated OutboundVideoTrack outboundVideoTracks = 15;
		repeated PeerConnectionTransport pcTransports = 16;
		repeated string userMediaErrors = 17;
		required string clientId = 18;
		required int64 timestamp = 19;
		optional Browser browser = 20;
		optional string callId = 21;
		optional Engine engine = 22;
		optional string marker = 23;
		optional OperationSystem os = 24;
		optional Platform platform = 25;
		optional string roomId = 26;
		optional int32 sampleSeq = 27;
		optional int32 timeZoneOffsetInHours = 28;
		optional string userId = 29;
	}
	message SfuSample {
		message SfuTransport {
			required string transportId = 1;
			optional string dtlsState = 2;
			optional string iceRole = 3;
			optional string iceState = 4;
			optional bool internal = 5;
			optional string localAddress = 6;
			optional int32 localPort = 7;
			optional bool noReport = 8;
			optional string protocol = 9;
			optional string remoteAddress = 10;
			optional int32 remotePort = 11;
			optional int64 rtpBytesReceived = 12;
			optional int64 rtpBytesSent = 13;
			optional int32 rtpPacketsLost = 14;
			optional int32 rtpPacketsReceived = 15;
			optional int32 rtpPacketsSent = 16;
			optional int64 rtxBytesReceived = 17;
			optional int64 rtxBytesSent = 18;
			optional int32 rtxPacketsDiscarded = 19;
			optional int32 rtxPacketsLost = 20;
			optional int32 rtxPacketsReceived = 21;
			optional int32 rtxPacketsSent = 22;
			optional int64 sctpBytesReceived = 23;
			optional int64 sctpBytesSent = 24;
			optional int32 sctpPacketsReceived = 25;
			optional int32 sctpPacketsSent = 26;
			optional string sctpState = 27;
		}
		message SfuInboundRtpPad {
			required string padId = 1;
			required int64 ssrc = 2;
			required string streamId = 3;
			required string transportId = 4;
			optional int64 bytesReceived = 5;
			optional int32 clockRate = 6;
			optional int32 fecPacketsDiscarded = 7;
			optional int32 fecPacketsReceived = 8;
			optional int32 firCount = 9;
			optional double fractionLost = 10;
			optional int32 framesDecoded = 11;
			optional int32 framesReceived = 12;
			optional bool internal = 13;
			optional double jitter = 14;
			optional int32 keyFramesDecoded = 15;
			optional string mediaType = 16;
			optional string mimeType = 17;
			optional int32 nackCount = 18;
			optional bool noReport = 19;
			optional int32 packetsDiscarded = 20;
			optional int32 packetsDuplicated = 21;
			optional int32 packetsFailedDecryption = 22;
			optional int32 packetsLost = 23;
			optional int32 packetsReceived = 24;
			optional int32 packetsRepaired = 25;
			optional int32 payloadType = 26;
			optional int32 pliCount = 27;
			optional string rid = 28;
			optional double roundTripTime = 29;
			optional int32 rtcpRrSent = 30;
			optional int32 rtcpSrReceived = 31;
			optional int32 rtxPacketsDiscarded = 32;
			optional int32 rtxPacketsReceived = 33;
			optional int64 rtxSsrc = 34;
			optional string sdpFmtpLine = 35;
			optional int32 sliCount = 36;
			optional int32 targetBitrate = 37;
			optional bool voiceActivityFlag = 38;
		}
		message SfuOutboundRtpPad {
			required string padId = 1;
			required string sinkId = 2;
			required int64 ssrc = 3;
			required string streamId = 4;
			required string transportId = 5;
			optional int64 bytesSent = 6;
			optional string callId = 7;
			optional string clientId = 8;
			optional int32 clockRate = 9;
			optional int32 fecPacketsDiscarded = 10;
			optional int32 fecPacketsSent = 11;
			optional int32 firCount = 12;
			optional double fractionLost = 13;
			optional int32 framesEncoded = 14;
			optional int32 framesSent = 15;
			optional bool internal = 16;
			optional double jitter = 17;
			optional int32 keyFramesEncoded = 18;
			optional string mediaType = 19;
			optional string mimeType = 20;
			optional int32 nackCount = 21;
			optional bool noReport = 22;
			optional int32 packetsDiscarded = 23;
			optional int32 packetsDuplicated = 24;
			optional int32 packetsFailedEncryption = 25;
			optional int32 packetsLost = 26;
			optional int32 packetsRetransmitted = 27;
			optional int32 packetsSent = 28;
			optional int32 payloadType = 29;
			optional int32 pliCount = 30;
			optional string rid = 31;
			optional double roundTripTime = 32;
			optional int32 rtcpRrReceived = 33;
			optional int32 rtcpSrSent = 34;
			optional int32 rtxPacketsDiscarded = 35;
			optional int32 rtxPacketsSent = 36;
			optional int64 rtxSsrc = 37;
			optional string sdpFmtpLine = 38;
			optional int32 sliCount = 39;
			optional int32 targetBitrate = 40;
			optional string trackId = 41;
			optional bool voiceActivityFlag = 42;
		}
		message SfuSctpChannel {
			required string channelId = 1;
			required string streamId = 2;
			required string transportId = 3;
			optional int64 bytesReceived = 4;
			optional int64 bytesSent = 5;
			optional string label = 6;
			optional int32 messageReceived = 7;
			optional int32 messageSent = 8;
			optional bool noReport = 9;
			optional string protocol = 10;
			optional double sctpCongestionWindow = 11;
			optional int32 sctpMtu = 12;
			optional double sctpReceiverWindow = 13;
			optional double sctpSmoothedRoundTripTime = 14;
			optional int32 sctpUnackData = 15;
		}
		message SfuExtensionStats {
			required string payload = 1;
			required string type = 2;
		}
		repeated SfuExtensionStats extensionStats = 1;
		repeated SfuInboundRtpPad inboundRtpPads = 2;
		repeated SfuOutboundRtpPad outboundRtpPads = 3;
		repeated SfuSctpChannel sctpChannels = 4;
		repeated SfuTransport transports = 5;
		required string sfuId = 6;
		required int64 timestamp = 7;
		optional string marker = 8;
		optional int32 timeZoneOffsetInHours = 9;
	}
	message TurnSample {
		message TurnPeerAllocation {
			required string peerId = 1;
			required string relayedAddress = 2;
			required int32 relayedPort = 3;
			required string sessionId = 4;
			required string transportProtocol = 5;
			optional string peerAddress = 6;
			optional int32 peerPort = 7;
			optional int64 receivedBytes = 8;
			optional int32 receivedPackets = 9;
			optional int32 receivingBitrate = 10;
			optional int32 sendingBitrate = 11;
			optional int64 sentBytes = 12;
			optional int32 sentPackets = 13;
		}
		message TurnSession {
			required string sessionId = 1;
			optional string clientAddress = 2;
			optional string clientId = 3;
			optional int32 clientPort = 4;
			optional int64 nonceExpirationTime = 5;
			optional string realm = 6;
			optional int64 receivedBytes = 7;
			optional int32 receivedPackets = 8;
			optional int32 receivingBitrate = 9;
			optional int32 sendingBitrate = 10;
			optional int64 sentBytes = 11;
			optional int32 sentPackets = 12;
			optional string serverAddress = 13;
			optional int32 serverPort = 14;
			optional int64 started = 15;
			optional string transportProtocol = 16;
			optional string username = 17;
		}
		repeated TurnPeerAllocation allocations = 1;
		repeated TurnSession sessions = 2;
		required string serverId = 3;
	}
	repeated ClientSample clientSamples = 1;
	repeated SfuSample sfuSamples = 2;
	repeated TurnSample turnSamples = 3;
	optional ControlFlags controlFlags = 4;
	optional SamplesMeta meta = 5;
}
`;

},{}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jsonDescriptor = void 0;
exports.jsonDescriptor = {
    "nested": {
        "org": {
            "nested": {
                "observertc": {
                    "nested": {
                        "schemas": {
                            "nested": {
                                "protobuf": {
                                    "nested": {
                                        "Samples": {
                                            "fields": {
                                                "clientSamples": {
                                                    "rule": "repeated",
                                                    "type": "ClientSample",
                                                    "id": 1
                                                },
                                                "sfuSamples": {
                                                    "rule": "repeated",
                                                    "type": "SfuSample",
                                                    "id": 2
                                                },
                                                "turnSamples": {
                                                    "rule": "repeated",
                                                    "type": "TurnSample",
                                                    "id": 3
                                                },
                                                "controlFlags": {
                                                    "type": "ControlFlags",
                                                    "id": 4
                                                },
                                                "meta": {
                                                    "type": "SamplesMeta",
                                                    "id": 5
                                                }
                                            },
                                            "nested": {
                                                "SamplesMeta": {
                                                    "fields": {
                                                        "schemaVersion": {
                                                            "type": "string",
                                                            "id": 1
                                                        }
                                                    }
                                                },
                                                "ControlFlags": {
                                                    "fields": {
                                                        "close": {
                                                            "type": "bool",
                                                            "id": 1
                                                        }
                                                    }
                                                },
                                                "ClientSample": {
                                                    "fields": {
                                                        "certificates": {
                                                            "rule": "repeated",
                                                            "type": "Certificate",
                                                            "id": 1
                                                        },
                                                        "codecs": {
                                                            "rule": "repeated",
                                                            "type": "MediaCodecStats",
                                                            "id": 2
                                                        },
                                                        "dataChannels": {
                                                            "rule": "repeated",
                                                            "type": "DataChannel",
                                                            "id": 3
                                                        },
                                                        "extensionStats": {
                                                            "rule": "repeated",
                                                            "type": "ExtensionStat",
                                                            "id": 4
                                                        },
                                                        "iceLocalCandidates": {
                                                            "rule": "repeated",
                                                            "type": "IceLocalCandidate",
                                                            "id": 5
                                                        },
                                                        "iceRemoteCandidates": {
                                                            "rule": "repeated",
                                                            "type": "IceRemoteCandidate",
                                                            "id": 6
                                                        },
                                                        "iceServers": {
                                                            "rule": "repeated",
                                                            "type": "string",
                                                            "id": 7
                                                        },
                                                        "inboundAudioTracks": {
                                                            "rule": "repeated",
                                                            "type": "InboundAudioTrack",
                                                            "id": 8
                                                        },
                                                        "inboundVideoTracks": {
                                                            "rule": "repeated",
                                                            "type": "InboundVideoTrack",
                                                            "id": 9
                                                        },
                                                        "localSDPs": {
                                                            "rule": "repeated",
                                                            "type": "string",
                                                            "id": 10
                                                        },
                                                        "mediaConstraints": {
                                                            "rule": "repeated",
                                                            "type": "string",
                                                            "id": 11
                                                        },
                                                        "mediaDevices": {
                                                            "rule": "repeated",
                                                            "type": "MediaDevice",
                                                            "id": 12
                                                        },
                                                        "mediaSources": {
                                                            "rule": "repeated",
                                                            "type": "MediaSourceStat",
                                                            "id": 13
                                                        },
                                                        "outboundAudioTracks": {
                                                            "rule": "repeated",
                                                            "type": "OutboundAudioTrack",
                                                            "id": 14
                                                        },
                                                        "outboundVideoTracks": {
                                                            "rule": "repeated",
                                                            "type": "OutboundVideoTrack",
                                                            "id": 15
                                                        },
                                                        "pcTransports": {
                                                            "rule": "repeated",
                                                            "type": "PeerConnectionTransport",
                                                            "id": 16
                                                        },
                                                        "userMediaErrors": {
                                                            "rule": "repeated",
                                                            "type": "string",
                                                            "id": 17
                                                        },
                                                        "clientId": {
                                                            "rule": "required",
                                                            "type": "string",
                                                            "id": 18
                                                        },
                                                        "timestamp": {
                                                            "rule": "required",
                                                            "type": "int64",
                                                            "id": 19
                                                        },
                                                        "browser": {
                                                            "type": "Browser",
                                                            "id": 20
                                                        },
                                                        "callId": {
                                                            "type": "string",
                                                            "id": 21
                                                        },
                                                        "engine": {
                                                            "type": "Engine",
                                                            "id": 22
                                                        },
                                                        "marker": {
                                                            "type": "string",
                                                            "id": 23
                                                        },
                                                        "os": {
                                                            "type": "OperationSystem",
                                                            "id": 24
                                                        },
                                                        "platform": {
                                                            "type": "Platform",
                                                            "id": 25
                                                        },
                                                        "roomId": {
                                                            "type": "string",
                                                            "id": 26
                                                        },
                                                        "sampleSeq": {
                                                            "type": "int32",
                                                            "id": 27
                                                        },
                                                        "timeZoneOffsetInHours": {
                                                            "type": "int32",
                                                            "id": 28
                                                        },
                                                        "userId": {
                                                            "type": "string",
                                                            "id": 29
                                                        }
                                                    },
                                                    "nested": {
                                                        "Engine": {
                                                            "fields": {
                                                                "name": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "version": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                }
                                                            }
                                                        },
                                                        "Platform": {
                                                            "fields": {
                                                                "model": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "type": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "vendor": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                }
                                                            }
                                                        },
                                                        "Browser": {
                                                            "fields": {
                                                                "name": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "version": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                }
                                                            }
                                                        },
                                                        "OperationSystem": {
                                                            "fields": {
                                                                "name": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "version": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "versionName": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                }
                                                            }
                                                        },
                                                        "MediaDevice": {
                                                            "fields": {
                                                                "id": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "kind": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "label": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                }
                                                            }
                                                        },
                                                        "ExtensionStat": {
                                                            "fields": {
                                                                "payload": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "type": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 2
                                                                }
                                                            }
                                                        },
                                                        "PeerConnectionTransport": {
                                                            "fields": {
                                                                "peerConnectionId": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "bytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 2
                                                                },
                                                                "bytesSent": {
                                                                    "type": "int64",
                                                                    "id": 3
                                                                },
                                                                "candidatePairAvailableIncomingBitrate": {
                                                                    "type": "double",
                                                                    "id": 4
                                                                },
                                                                "candidatePairAvailableOutgoingBitrate": {
                                                                    "type": "double",
                                                                    "id": 5
                                                                },
                                                                "candidatePairBytesDiscardedOnSend": {
                                                                    "type": "int64",
                                                                    "id": 6
                                                                },
                                                                "candidatePairBytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 7
                                                                },
                                                                "candidatePairBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 8
                                                                },
                                                                "candidatePairCircuitBreakerTriggerCount": {
                                                                    "type": "int32",
                                                                    "id": 9
                                                                },
                                                                "candidatePairConsentExpiredTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 10
                                                                },
                                                                "candidatePairConsentRequestBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 11
                                                                },
                                                                "candidatePairConsentRequestsSent": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "candidatePairCurrentRoundTripTime": {
                                                                    "type": "double",
                                                                    "id": 13
                                                                },
                                                                "candidatePairFirstRequestTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 14
                                                                },
                                                                "candidatePairLastPacketReceivedTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 15
                                                                },
                                                                "candidatePairLastPacketSentTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 16
                                                                },
                                                                "candidatePairLastRequestTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 17
                                                                },
                                                                "candidatePairLastResponseTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 18
                                                                },
                                                                "candidatePairPacketsDiscardedOnSend": {
                                                                    "type": "int32",
                                                                    "id": 19
                                                                },
                                                                "candidatePairPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 20
                                                                },
                                                                "candidatePairPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 21
                                                                },
                                                                "candidatePairRequestBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 22
                                                                },
                                                                "candidatePairRequestsReceived": {
                                                                    "type": "int32",
                                                                    "id": 23
                                                                },
                                                                "candidatePairRequestsSent": {
                                                                    "type": "int32",
                                                                    "id": 24
                                                                },
                                                                "candidatePairResponseBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 25
                                                                },
                                                                "candidatePairResponsesReceived": {
                                                                    "type": "int32",
                                                                    "id": 26
                                                                },
                                                                "candidatePairResponsesSent": {
                                                                    "type": "int32",
                                                                    "id": 27
                                                                },
                                                                "candidatePairRetransmissionReceived": {
                                                                    "type": "int32",
                                                                    "id": 28
                                                                },
                                                                "candidatePairRetransmissionSent": {
                                                                    "type": "int32",
                                                                    "id": 29
                                                                },
                                                                "candidatePairState": {
                                                                    "type": "string",
                                                                    "id": 30
                                                                },
                                                                "candidatePairTotalRoundTripTime": {
                                                                    "type": "double",
                                                                    "id": 31
                                                                },
                                                                "dataChannelsAccepted": {
                                                                    "type": "int32",
                                                                    "id": 32
                                                                },
                                                                "dataChannelsClosed": {
                                                                    "type": "int32",
                                                                    "id": 33
                                                                },
                                                                "dataChannelsOpened": {
                                                                    "type": "int32",
                                                                    "id": 34
                                                                },
                                                                "dataChannelsRequested": {
                                                                    "type": "int32",
                                                                    "id": 35
                                                                },
                                                                "dtlsCipher": {
                                                                    "type": "string",
                                                                    "id": 36
                                                                },
                                                                "dtlsState": {
                                                                    "type": "string",
                                                                    "id": 37
                                                                },
                                                                "iceLocalUsernameFragment": {
                                                                    "type": "string",
                                                                    "id": 38
                                                                },
                                                                "iceRole": {
                                                                    "type": "string",
                                                                    "id": 39
                                                                },
                                                                "iceState": {
                                                                    "type": "string",
                                                                    "id": 40
                                                                },
                                                                "label": {
                                                                    "type": "string",
                                                                    "id": 41
                                                                },
                                                                "localAddress": {
                                                                    "type": "string",
                                                                    "id": 42
                                                                },
                                                                "localCandidateICEServerUrl": {
                                                                    "type": "string",
                                                                    "id": 43
                                                                },
                                                                "localCandidateRelayProtocol": {
                                                                    "type": "string",
                                                                    "id": 44
                                                                },
                                                                "localCandidateType": {
                                                                    "type": "string",
                                                                    "id": 45
                                                                },
                                                                "localPort": {
                                                                    "type": "int32",
                                                                    "id": 46
                                                                },
                                                                "localProtocol": {
                                                                    "type": "string",
                                                                    "id": 47
                                                                },
                                                                "packetsReceived": {
                                                                    "type": "int32",
                                                                    "id": 48
                                                                },
                                                                "packetsSent": {
                                                                    "type": "int32",
                                                                    "id": 49
                                                                },
                                                                "remoteAddress": {
                                                                    "type": "string",
                                                                    "id": 50
                                                                },
                                                                "remoteCandidateICEServerUrl": {
                                                                    "type": "string",
                                                                    "id": 51
                                                                },
                                                                "remoteCandidateRelayProtocol": {
                                                                    "type": "string",
                                                                    "id": 52
                                                                },
                                                                "remoteCandidateType": {
                                                                    "type": "string",
                                                                    "id": 53
                                                                },
                                                                "remotePort": {
                                                                    "type": "int32",
                                                                    "id": 54
                                                                },
                                                                "remoteProtocol": {
                                                                    "type": "string",
                                                                    "id": 55
                                                                },
                                                                "sctpCongestionWindow": {
                                                                    "type": "double",
                                                                    "id": 56
                                                                },
                                                                "sctpMtu": {
                                                                    "type": "int32",
                                                                    "id": 57
                                                                },
                                                                "sctpReceiverWindow": {
                                                                    "type": "double",
                                                                    "id": 58
                                                                },
                                                                "sctpSmoothedRoundTripTime": {
                                                                    "type": "double",
                                                                    "id": 59
                                                                },
                                                                "sctpUnackData": {
                                                                    "type": "int32",
                                                                    "id": 60
                                                                },
                                                                "selectedCandidatePairChanges": {
                                                                    "type": "int32",
                                                                    "id": 61
                                                                },
                                                                "srtpCipher": {
                                                                    "type": "string",
                                                                    "id": 62
                                                                },
                                                                "tlsGroup": {
                                                                    "type": "string",
                                                                    "id": 63
                                                                },
                                                                "tlsVersion": {
                                                                    "type": "string",
                                                                    "id": 64
                                                                }
                                                            }
                                                        },
                                                        "MediaSourceStat": {
                                                            "fields": {
                                                                "audioLevel": {
                                                                    "type": "double",
                                                                    "id": 1
                                                                },
                                                                "bitDepth": {
                                                                    "type": "int32",
                                                                    "id": 2
                                                                },
                                                                "echoReturnLoss": {
                                                                    "type": "double",
                                                                    "id": 3
                                                                },
                                                                "echoReturnLossEnhancement": {
                                                                    "type": "double",
                                                                    "id": 4
                                                                },
                                                                "frames": {
                                                                    "type": "int32",
                                                                    "id": 5
                                                                },
                                                                "framesPerSecond": {
                                                                    "type": "double",
                                                                    "id": 6
                                                                },
                                                                "height": {
                                                                    "type": "int32",
                                                                    "id": 7
                                                                },
                                                                "kind": {
                                                                    "type": "string",
                                                                    "id": 8
                                                                },
                                                                "relayedSource": {
                                                                    "type": "bool",
                                                                    "id": 9
                                                                },
                                                                "totalAudioEnergy": {
                                                                    "type": "double",
                                                                    "id": 10
                                                                },
                                                                "totalSamplesDuration": {
                                                                    "type": "double",
                                                                    "id": 11
                                                                },
                                                                "trackIdentifier": {
                                                                    "type": "string",
                                                                    "id": 12
                                                                },
                                                                "width": {
                                                                    "type": "int32",
                                                                    "id": 13
                                                                }
                                                            }
                                                        },
                                                        "MediaCodecStats": {
                                                            "fields": {
                                                                "channels": {
                                                                    "type": "int32",
                                                                    "id": 1
                                                                },
                                                                "clockRate": {
                                                                    "type": "int32",
                                                                    "id": 2
                                                                },
                                                                "codecType": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                },
                                                                "mimeType": {
                                                                    "type": "string",
                                                                    "id": 4
                                                                },
                                                                "payloadType": {
                                                                    "type": "string",
                                                                    "id": 5
                                                                },
                                                                "sdpFmtpLine": {
                                                                    "type": "string",
                                                                    "id": 6
                                                                }
                                                            }
                                                        },
                                                        "Certificate": {
                                                            "fields": {
                                                                "base64Certificate": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "fingerprint": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "fingerprintAlgorithm": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                },
                                                                "issuerCertificateId": {
                                                                    "type": "string",
                                                                    "id": 4
                                                                }
                                                            }
                                                        },
                                                        "InboundAudioTrack": {
                                                            "fields": {
                                                                "ssrc": {
                                                                    "rule": "required",
                                                                    "type": "int64",
                                                                    "id": 1
                                                                },
                                                                "averageRtcpInterval": {
                                                                    "type": "double",
                                                                    "id": 2
                                                                },
                                                                "burstDiscardCount": {
                                                                    "type": "int32",
                                                                    "id": 3
                                                                },
                                                                "burstDiscardRate": {
                                                                    "type": "double",
                                                                    "id": 4
                                                                },
                                                                "burstLossCount": {
                                                                    "type": "int32",
                                                                    "id": 5
                                                                },
                                                                "burstLossRate": {
                                                                    "type": "double",
                                                                    "id": 6
                                                                },
                                                                "burstPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 7
                                                                },
                                                                "burstPacketsLost": {
                                                                    "type": "int32",
                                                                    "id": 8
                                                                },
                                                                "bytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 9
                                                                },
                                                                "bytesSent": {
                                                                    "type": "int64",
                                                                    "id": 10
                                                                },
                                                                "channels": {
                                                                    "type": "int32",
                                                                    "id": 11
                                                                },
                                                                "clockRate": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "concealedSamples": {
                                                                    "type": "int32",
                                                                    "id": 13
                                                                },
                                                                "concealmentEvents": {
                                                                    "type": "int32",
                                                                    "id": 14
                                                                },
                                                                "decoderImplementation": {
                                                                    "type": "string",
                                                                    "id": 15
                                                                },
                                                                "ended": {
                                                                    "type": "bool",
                                                                    "id": 16
                                                                },
                                                                "estimatedPlayoutTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 17
                                                                },
                                                                "fecPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 18
                                                                },
                                                                "fecPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 19
                                                                },
                                                                "gapDiscardRate": {
                                                                    "type": "double",
                                                                    "id": 20
                                                                },
                                                                "gapLossRate": {
                                                                    "type": "double",
                                                                    "id": 21
                                                                },
                                                                "headerBytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 22
                                                                },
                                                                "insertedSamplesForDeceleration": {
                                                                    "type": "int32",
                                                                    "id": 23
                                                                },
                                                                "jitter": {
                                                                    "type": "double",
                                                                    "id": 24
                                                                },
                                                                "jitterBufferDelay": {
                                                                    "type": "double",
                                                                    "id": 25
                                                                },
                                                                "jitterBufferEmittedCount": {
                                                                    "type": "int32",
                                                                    "id": 26
                                                                },
                                                                "lastPacketReceivedTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 27
                                                                },
                                                                "mimeType": {
                                                                    "type": "string",
                                                                    "id": 28
                                                                },
                                                                "nackCount": {
                                                                    "type": "int32",
                                                                    "id": 29
                                                                },
                                                                "packetsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 30
                                                                },
                                                                "packetsDuplicated": {
                                                                    "type": "int32",
                                                                    "id": 31
                                                                },
                                                                "packetsFailedDecryption": {
                                                                    "type": "int32",
                                                                    "id": 32
                                                                },
                                                                "packetsLost": {
                                                                    "type": "int32",
                                                                    "id": 33
                                                                },
                                                                "packetsReceived": {
                                                                    "type": "int32",
                                                                    "id": 34
                                                                },
                                                                "packetsRepaired": {
                                                                    "type": "int32",
                                                                    "id": 35
                                                                },
                                                                "packetsSent": {
                                                                    "type": "int32",
                                                                    "id": 36
                                                                },
                                                                "payloadType": {
                                                                    "type": "int32",
                                                                    "id": 37
                                                                },
                                                                "peerConnectionId": {
                                                                    "type": "string",
                                                                    "id": 38
                                                                },
                                                                "perDscpPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 39
                                                                },
                                                                "remoteClientId": {
                                                                    "type": "string",
                                                                    "id": 40
                                                                },
                                                                "remoteTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 41
                                                                },
                                                                "removedSamplesForAcceleration": {
                                                                    "type": "int32",
                                                                    "id": 42
                                                                },
                                                                "reportsSent": {
                                                                    "type": "int32",
                                                                    "id": 43
                                                                },
                                                                "roundTripTime": {
                                                                    "type": "double",
                                                                    "id": 44
                                                                },
                                                                "roundTripTimeMeasurements": {
                                                                    "type": "int32",
                                                                    "id": 45
                                                                },
                                                                "samplesDecodedWithCelt": {
                                                                    "type": "int32",
                                                                    "id": 46
                                                                },
                                                                "samplesDecodedWithSilk": {
                                                                    "type": "int32",
                                                                    "id": 47
                                                                },
                                                                "sdpFmtpLine": {
                                                                    "type": "string",
                                                                    "id": 48
                                                                },
                                                                "sfuSinkId": {
                                                                    "type": "string",
                                                                    "id": 49
                                                                },
                                                                "silentConcealedSamples": {
                                                                    "type": "int32",
                                                                    "id": 50
                                                                },
                                                                "totalProcessingDelay": {
                                                                    "type": "double",
                                                                    "id": 51
                                                                },
                                                                "totalRoundTripTime": {
                                                                    "type": "double",
                                                                    "id": 52
                                                                },
                                                                "totalSamplesDecoded": {
                                                                    "type": "int32",
                                                                    "id": 53
                                                                },
                                                                "totalSamplesReceived": {
                                                                    "type": "int32",
                                                                    "id": 54
                                                                },
                                                                "trackId": {
                                                                    "type": "string",
                                                                    "id": 55
                                                                },
                                                                "voiceActivityFlag": {
                                                                    "type": "bool",
                                                                    "id": 56
                                                                }
                                                            }
                                                        },
                                                        "InboundVideoTrack": {
                                                            "fields": {
                                                                "ssrc": {
                                                                    "rule": "required",
                                                                    "type": "int64",
                                                                    "id": 1
                                                                },
                                                                "averageRtcpInterval": {
                                                                    "type": "double",
                                                                    "id": 2
                                                                },
                                                                "burstDiscardCount": {
                                                                    "type": "int32",
                                                                    "id": 3
                                                                },
                                                                "burstDiscardRate": {
                                                                    "type": "double",
                                                                    "id": 4
                                                                },
                                                                "burstLossCount": {
                                                                    "type": "int32",
                                                                    "id": 5
                                                                },
                                                                "burstLossRate": {
                                                                    "type": "double",
                                                                    "id": 6
                                                                },
                                                                "burstPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 7
                                                                },
                                                                "burstPacketsLost": {
                                                                    "type": "int32",
                                                                    "id": 8
                                                                },
                                                                "bytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 9
                                                                },
                                                                "bytesSent": {
                                                                    "type": "int64",
                                                                    "id": 10
                                                                },
                                                                "channels": {
                                                                    "type": "int32",
                                                                    "id": 11
                                                                },
                                                                "clockRate": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "decoderImplementation": {
                                                                    "type": "string",
                                                                    "id": 13
                                                                },
                                                                "ended": {
                                                                    "type": "bool",
                                                                    "id": 14
                                                                },
                                                                "estimatedPlayoutTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 15
                                                                },
                                                                "fecPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 16
                                                                },
                                                                "fecPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 17
                                                                },
                                                                "firCount": {
                                                                    "type": "int32",
                                                                    "id": 18
                                                                },
                                                                "frameBitDepth": {
                                                                    "type": "int32",
                                                                    "id": 19
                                                                },
                                                                "frameHeight": {
                                                                    "type": "int32",
                                                                    "id": 20
                                                                },
                                                                "frameWidth": {
                                                                    "type": "int32",
                                                                    "id": 21
                                                                },
                                                                "framesDecoded": {
                                                                    "type": "int32",
                                                                    "id": 22
                                                                },
                                                                "framesDropped": {
                                                                    "type": "int32",
                                                                    "id": 23
                                                                },
                                                                "framesPerSecond": {
                                                                    "type": "double",
                                                                    "id": 24
                                                                },
                                                                "framesReceived": {
                                                                    "type": "int32",
                                                                    "id": 25
                                                                },
                                                                "fullFramesLost": {
                                                                    "type": "int32",
                                                                    "id": 26
                                                                },
                                                                "gapDiscardRate": {
                                                                    "type": "double",
                                                                    "id": 27
                                                                },
                                                                "gapLossRate": {
                                                                    "type": "double",
                                                                    "id": 28
                                                                },
                                                                "headerBytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 29
                                                                },
                                                                "jitter": {
                                                                    "type": "double",
                                                                    "id": 30
                                                                },
                                                                "jitterBufferDelay": {
                                                                    "type": "double",
                                                                    "id": 31
                                                                },
                                                                "jitterBufferEmittedCount": {
                                                                    "type": "int32",
                                                                    "id": 32
                                                                },
                                                                "keyFramesDecoded": {
                                                                    "type": "int32",
                                                                    "id": 33
                                                                },
                                                                "lastPacketReceivedTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 34
                                                                },
                                                                "mimeType": {
                                                                    "type": "string",
                                                                    "id": 35
                                                                },
                                                                "nackCount": {
                                                                    "type": "int32",
                                                                    "id": 36
                                                                },
                                                                "packetsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 37
                                                                },
                                                                "packetsDuplicated": {
                                                                    "type": "int32",
                                                                    "id": 38
                                                                },
                                                                "packetsFailedDecryption": {
                                                                    "type": "int32",
                                                                    "id": 39
                                                                },
                                                                "packetsLost": {
                                                                    "type": "int32",
                                                                    "id": 40
                                                                },
                                                                "packetsReceived": {
                                                                    "type": "int32",
                                                                    "id": 41
                                                                },
                                                                "packetsRepaired": {
                                                                    "type": "int32",
                                                                    "id": 42
                                                                },
                                                                "packetsSent": {
                                                                    "type": "int32",
                                                                    "id": 43
                                                                },
                                                                "partialFramesLost": {
                                                                    "type": "int32",
                                                                    "id": 44
                                                                },
                                                                "payloadType": {
                                                                    "type": "int32",
                                                                    "id": 45
                                                                },
                                                                "peerConnectionId": {
                                                                    "type": "string",
                                                                    "id": 46
                                                                },
                                                                "perDscpPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 47
                                                                },
                                                                "pliCount": {
                                                                    "type": "int32",
                                                                    "id": 48
                                                                },
                                                                "qpSum": {
                                                                    "type": "int64",
                                                                    "id": 49
                                                                },
                                                                "remoteClientId": {
                                                                    "type": "string",
                                                                    "id": 50
                                                                },
                                                                "remoteTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 51
                                                                },
                                                                "reportsSent": {
                                                                    "type": "int32",
                                                                    "id": 52
                                                                },
                                                                "roundTripTime": {
                                                                    "type": "double",
                                                                    "id": 53
                                                                },
                                                                "roundTripTimeMeasurements": {
                                                                    "type": "int32",
                                                                    "id": 54
                                                                },
                                                                "sdpFmtpLine": {
                                                                    "type": "string",
                                                                    "id": 55
                                                                },
                                                                "sfuSinkId": {
                                                                    "type": "string",
                                                                    "id": 56
                                                                },
                                                                "sliCount": {
                                                                    "type": "int32",
                                                                    "id": 57
                                                                },
                                                                "totalDecodeTime": {
                                                                    "type": "double",
                                                                    "id": 58
                                                                },
                                                                "totalInterFrameDelay": {
                                                                    "type": "double",
                                                                    "id": 59
                                                                },
                                                                "totalProcessingDelay": {
                                                                    "type": "double",
                                                                    "id": 60
                                                                },
                                                                "totalRoundTripTime": {
                                                                    "type": "double",
                                                                    "id": 61
                                                                },
                                                                "totalSquaredInterFrameDelay": {
                                                                    "type": "double",
                                                                    "id": 62
                                                                },
                                                                "trackId": {
                                                                    "type": "string",
                                                                    "id": 63
                                                                }
                                                            }
                                                        },
                                                        "OutboundAudioTrack": {
                                                            "fields": {
                                                                "ssrc": {
                                                                    "rule": "required",
                                                                    "type": "int64",
                                                                    "id": 1
                                                                },
                                                                "audioLevel": {
                                                                    "type": "double",
                                                                    "id": 2
                                                                },
                                                                "averageRtcpInterval": {
                                                                    "type": "double",
                                                                    "id": 3
                                                                },
                                                                "burstDiscardCount": {
                                                                    "type": "int32",
                                                                    "id": 4
                                                                },
                                                                "burstDiscardRate": {
                                                                    "type": "double",
                                                                    "id": 5
                                                                },
                                                                "burstLossCount": {
                                                                    "type": "int32",
                                                                    "id": 6
                                                                },
                                                                "burstLossRate": {
                                                                    "type": "double",
                                                                    "id": 7
                                                                },
                                                                "burstPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 8
                                                                },
                                                                "burstPacketsLost": {
                                                                    "type": "int32",
                                                                    "id": 9
                                                                },
                                                                "bytesDiscardedOnSend": {
                                                                    "type": "int64",
                                                                    "id": 10
                                                                },
                                                                "bytesSent": {
                                                                    "type": "int64",
                                                                    "id": 11
                                                                },
                                                                "channels": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "clockRate": {
                                                                    "type": "int32",
                                                                    "id": 13
                                                                },
                                                                "echoReturnLoss": {
                                                                    "type": "double",
                                                                    "id": 14
                                                                },
                                                                "echoReturnLossEnhancement": {
                                                                    "type": "double",
                                                                    "id": 15
                                                                },
                                                                "encoderImplementation": {
                                                                    "type": "string",
                                                                    "id": 16
                                                                },
                                                                "ended": {
                                                                    "type": "bool",
                                                                    "id": 17
                                                                },
                                                                "fecPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 18
                                                                },
                                                                "fractionLost": {
                                                                    "type": "double",
                                                                    "id": 19
                                                                },
                                                                "gapDiscardRate": {
                                                                    "type": "double",
                                                                    "id": 20
                                                                },
                                                                "gapLossRate": {
                                                                    "type": "double",
                                                                    "id": 21
                                                                },
                                                                "headerBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 22
                                                                },
                                                                "jitter": {
                                                                    "type": "double",
                                                                    "id": 23
                                                                },
                                                                "lastPacketSentTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 24
                                                                },
                                                                "mimeType": {
                                                                    "type": "string",
                                                                    "id": 25
                                                                },
                                                                "nackCount": {
                                                                    "type": "int32",
                                                                    "id": 26
                                                                },
                                                                "packetsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 27
                                                                },
                                                                "packetsDiscardedOnSend": {
                                                                    "type": "int32",
                                                                    "id": 28
                                                                },
                                                                "packetsLost": {
                                                                    "type": "int32",
                                                                    "id": 29
                                                                },
                                                                "packetsReceived": {
                                                                    "type": "int32",
                                                                    "id": 30
                                                                },
                                                                "packetsRepaired": {
                                                                    "type": "int32",
                                                                    "id": 31
                                                                },
                                                                "packetsSent": {
                                                                    "type": "int32",
                                                                    "id": 32
                                                                },
                                                                "payloadType": {
                                                                    "type": "int32",
                                                                    "id": 33
                                                                },
                                                                "peerConnectionId": {
                                                                    "type": "string",
                                                                    "id": 34
                                                                },
                                                                "perDscpPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 35
                                                                },
                                                                "relayedSource": {
                                                                    "type": "bool",
                                                                    "id": 36
                                                                },
                                                                "reportsReceived": {
                                                                    "type": "int32",
                                                                    "id": 37
                                                                },
                                                                "retransmittedBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 38
                                                                },
                                                                "retransmittedPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 39
                                                                },
                                                                "rid": {
                                                                    "type": "string",
                                                                    "id": 40
                                                                },
                                                                "roundTripTime": {
                                                                    "type": "double",
                                                                    "id": 41
                                                                },
                                                                "roundTripTimeMeasurements": {
                                                                    "type": "int32",
                                                                    "id": 42
                                                                },
                                                                "rtxSsrc": {
                                                                    "type": "int64",
                                                                    "id": 43
                                                                },
                                                                "samplesEncodedWithCelt": {
                                                                    "type": "int32",
                                                                    "id": 44
                                                                },
                                                                "samplesEncodedWithSilk": {
                                                                    "type": "int32",
                                                                    "id": 45
                                                                },
                                                                "sdpFmtpLine": {
                                                                    "type": "string",
                                                                    "id": 46
                                                                },
                                                                "sfuStreamId": {
                                                                    "type": "string",
                                                                    "id": 47
                                                                },
                                                                "targetBitrate": {
                                                                    "type": "int32",
                                                                    "id": 48
                                                                },
                                                                "totalAudioEnergy": {
                                                                    "type": "double",
                                                                    "id": 49
                                                                },
                                                                "totalEncodedBytesTarget": {
                                                                    "type": "int64",
                                                                    "id": 50
                                                                },
                                                                "totalPacketSendDelay": {
                                                                    "type": "double",
                                                                    "id": 51
                                                                },
                                                                "totalRoundTripTime": {
                                                                    "type": "double",
                                                                    "id": 52
                                                                },
                                                                "totalSamplesDuration": {
                                                                    "type": "double",
                                                                    "id": 53
                                                                },
                                                                "totalSamplesSent": {
                                                                    "type": "int32",
                                                                    "id": 54
                                                                },
                                                                "trackId": {
                                                                    "type": "string",
                                                                    "id": 55
                                                                },
                                                                "voiceActivityFlag": {
                                                                    "type": "bool",
                                                                    "id": 56
                                                                }
                                                            }
                                                        },
                                                        "OutboundVideoTrack": {
                                                            "fields": {
                                                                "ssrc": {
                                                                    "rule": "required",
                                                                    "type": "int64",
                                                                    "id": 1
                                                                },
                                                                "averageRtcpInterval": {
                                                                    "type": "double",
                                                                    "id": 2
                                                                },
                                                                "bitDepth": {
                                                                    "type": "int32",
                                                                    "id": 3
                                                                },
                                                                "burstDiscardCount": {
                                                                    "type": "int32",
                                                                    "id": 4
                                                                },
                                                                "burstDiscardRate": {
                                                                    "type": "double",
                                                                    "id": 5
                                                                },
                                                                "burstLossCount": {
                                                                    "type": "int32",
                                                                    "id": 6
                                                                },
                                                                "burstLossRate": {
                                                                    "type": "double",
                                                                    "id": 7
                                                                },
                                                                "burstPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 8
                                                                },
                                                                "burstPacketsLost": {
                                                                    "type": "int32",
                                                                    "id": 9
                                                                },
                                                                "bytesDiscardedOnSend": {
                                                                    "type": "int64",
                                                                    "id": 10
                                                                },
                                                                "bytesSent": {
                                                                    "type": "int64",
                                                                    "id": 11
                                                                },
                                                                "channels": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "clockRate": {
                                                                    "type": "int32",
                                                                    "id": 13
                                                                },
                                                                "encoderImplementation": {
                                                                    "type": "string",
                                                                    "id": 14
                                                                },
                                                                "ended": {
                                                                    "type": "bool",
                                                                    "id": 15
                                                                },
                                                                "fecPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 16
                                                                },
                                                                "firCount": {
                                                                    "type": "int32",
                                                                    "id": 17
                                                                },
                                                                "fractionLost": {
                                                                    "type": "double",
                                                                    "id": 18
                                                                },
                                                                "frameBitDepth": {
                                                                    "type": "int32",
                                                                    "id": 19
                                                                },
                                                                "frameHeight": {
                                                                    "type": "int32",
                                                                    "id": 20
                                                                },
                                                                "frameWidth": {
                                                                    "type": "int32",
                                                                    "id": 21
                                                                },
                                                                "frames": {
                                                                    "type": "int32",
                                                                    "id": 22
                                                                },
                                                                "framesDiscardedOnSend": {
                                                                    "type": "int32",
                                                                    "id": 23
                                                                },
                                                                "framesDropped": {
                                                                    "type": "int32",
                                                                    "id": 24
                                                                },
                                                                "framesEncoded": {
                                                                    "type": "int32",
                                                                    "id": 25
                                                                },
                                                                "framesPerSecond": {
                                                                    "type": "double",
                                                                    "id": 26
                                                                },
                                                                "framesSent": {
                                                                    "type": "int32",
                                                                    "id": 27
                                                                },
                                                                "fullFramesLost": {
                                                                    "type": "int32",
                                                                    "id": 28
                                                                },
                                                                "gapDiscardRate": {
                                                                    "type": "double",
                                                                    "id": 29
                                                                },
                                                                "gapLossRate": {
                                                                    "type": "double",
                                                                    "id": 30
                                                                },
                                                                "headerBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 31
                                                                },
                                                                "height": {
                                                                    "type": "int32",
                                                                    "id": 32
                                                                },
                                                                "hugeFramesSent": {
                                                                    "type": "int32",
                                                                    "id": 33
                                                                },
                                                                "jitter": {
                                                                    "type": "double",
                                                                    "id": 34
                                                                },
                                                                "keyFramesEncoded": {
                                                                    "type": "int32",
                                                                    "id": 35
                                                                },
                                                                "lastPacketSentTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 36
                                                                },
                                                                "mimeType": {
                                                                    "type": "string",
                                                                    "id": 37
                                                                },
                                                                "nackCount": {
                                                                    "type": "int32",
                                                                    "id": 38
                                                                },
                                                                "packetsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 39
                                                                },
                                                                "packetsDiscardedOnSend": {
                                                                    "type": "int32",
                                                                    "id": 40
                                                                },
                                                                "packetsLost": {
                                                                    "type": "int32",
                                                                    "id": 41
                                                                },
                                                                "packetsReceived": {
                                                                    "type": "int32",
                                                                    "id": 42
                                                                },
                                                                "packetsRepaired": {
                                                                    "type": "int32",
                                                                    "id": 43
                                                                },
                                                                "packetsSent": {
                                                                    "type": "int32",
                                                                    "id": 44
                                                                },
                                                                "partialFramesLost": {
                                                                    "type": "int32",
                                                                    "id": 45
                                                                },
                                                                "payloadType": {
                                                                    "type": "int32",
                                                                    "id": 46
                                                                },
                                                                "peerConnectionId": {
                                                                    "type": "string",
                                                                    "id": 47
                                                                },
                                                                "perDscpPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 48
                                                                },
                                                                "pliCount": {
                                                                    "type": "int32",
                                                                    "id": 49
                                                                },
                                                                "qpSum": {
                                                                    "type": "int64",
                                                                    "id": 50
                                                                },
                                                                "qualityLimitationDurationBandwidth": {
                                                                    "type": "double",
                                                                    "id": 51
                                                                },
                                                                "qualityLimitationDurationCPU": {
                                                                    "type": "double",
                                                                    "id": 52
                                                                },
                                                                "qualityLimitationDurationNone": {
                                                                    "type": "double",
                                                                    "id": 53
                                                                },
                                                                "qualityLimitationDurationOther": {
                                                                    "type": "double",
                                                                    "id": 54
                                                                },
                                                                "qualityLimitationReason": {
                                                                    "type": "string",
                                                                    "id": 55
                                                                },
                                                                "qualityLimitationResolutionChanges": {
                                                                    "type": "int32",
                                                                    "id": 56
                                                                },
                                                                "relayedSource": {
                                                                    "type": "bool",
                                                                    "id": 57
                                                                },
                                                                "reportsReceived": {
                                                                    "type": "int32",
                                                                    "id": 58
                                                                },
                                                                "retransmittedBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 59
                                                                },
                                                                "retransmittedPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 60
                                                                },
                                                                "rid": {
                                                                    "type": "string",
                                                                    "id": 61
                                                                },
                                                                "roundTripTime": {
                                                                    "type": "double",
                                                                    "id": 62
                                                                },
                                                                "roundTripTimeMeasurements": {
                                                                    "type": "int32",
                                                                    "id": 63
                                                                },
                                                                "rtxSsrc": {
                                                                    "type": "int64",
                                                                    "id": 64
                                                                },
                                                                "sdpFmtpLine": {
                                                                    "type": "string",
                                                                    "id": 65
                                                                },
                                                                "sfuStreamId": {
                                                                    "type": "string",
                                                                    "id": 66
                                                                },
                                                                "sliCount": {
                                                                    "type": "int32",
                                                                    "id": 67
                                                                },
                                                                "targetBitrate": {
                                                                    "type": "int32",
                                                                    "id": 68
                                                                },
                                                                "totalEncodeTime": {
                                                                    "type": "double",
                                                                    "id": 69
                                                                },
                                                                "totalEncodedBytesTarget": {
                                                                    "type": "int64",
                                                                    "id": 70
                                                                },
                                                                "totalPacketSendDelay": {
                                                                    "type": "double",
                                                                    "id": 71
                                                                },
                                                                "totalRoundTripTime": {
                                                                    "type": "double",
                                                                    "id": 72
                                                                },
                                                                "trackId": {
                                                                    "type": "string",
                                                                    "id": 73
                                                                },
                                                                "width": {
                                                                    "type": "int32",
                                                                    "id": 74
                                                                }
                                                            }
                                                        },
                                                        "IceLocalCandidate": {
                                                            "fields": {
                                                                "address": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "candidateType": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "id": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                },
                                                                "peerConnectionId": {
                                                                    "type": "string",
                                                                    "id": 4
                                                                },
                                                                "port": {
                                                                    "type": "int32",
                                                                    "id": 5
                                                                },
                                                                "priority": {
                                                                    "type": "int64",
                                                                    "id": 6
                                                                },
                                                                "protocol": {
                                                                    "type": "string",
                                                                    "id": 7
                                                                },
                                                                "relayProtocol": {
                                                                    "type": "string",
                                                                    "id": 8
                                                                },
                                                                "url": {
                                                                    "type": "string",
                                                                    "id": 9
                                                                }
                                                            }
                                                        },
                                                        "IceRemoteCandidate": {
                                                            "fields": {
                                                                "address": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "candidateType": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "id": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                },
                                                                "peerConnectionId": {
                                                                    "type": "string",
                                                                    "id": 4
                                                                },
                                                                "port": {
                                                                    "type": "int32",
                                                                    "id": 5
                                                                },
                                                                "priority": {
                                                                    "type": "int64",
                                                                    "id": 6
                                                                },
                                                                "protocol": {
                                                                    "type": "string",
                                                                    "id": 7
                                                                },
                                                                "relayProtocol": {
                                                                    "type": "string",
                                                                    "id": 8
                                                                },
                                                                "url": {
                                                                    "type": "string",
                                                                    "id": 9
                                                                }
                                                            }
                                                        },
                                                        "DataChannel": {
                                                            "fields": {
                                                                "address": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "bytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 2
                                                                },
                                                                "bytesSent": {
                                                                    "type": "int64",
                                                                    "id": 3
                                                                },
                                                                "dataChannelIdentifier": {
                                                                    "type": "int32",
                                                                    "id": 4
                                                                },
                                                                "id": {
                                                                    "type": "string",
                                                                    "id": 5
                                                                },
                                                                "label": {
                                                                    "type": "string",
                                                                    "id": 6
                                                                },
                                                                "messagesReceived": {
                                                                    "type": "int32",
                                                                    "id": 7
                                                                },
                                                                "messagesSent": {
                                                                    "type": "int32",
                                                                    "id": 8
                                                                },
                                                                "peerConnectionId": {
                                                                    "type": "string",
                                                                    "id": 9
                                                                },
                                                                "port": {
                                                                    "type": "int32",
                                                                    "id": 10
                                                                },
                                                                "protocol": {
                                                                    "type": "string",
                                                                    "id": 11
                                                                },
                                                                "state": {
                                                                    "type": "string",
                                                                    "id": 12
                                                                }
                                                            }
                                                        }
                                                    }
                                                },
                                                "SfuSample": {
                                                    "fields": {
                                                        "extensionStats": {
                                                            "rule": "repeated",
                                                            "type": "SfuExtensionStats",
                                                            "id": 1
                                                        },
                                                        "inboundRtpPads": {
                                                            "rule": "repeated",
                                                            "type": "SfuInboundRtpPad",
                                                            "id": 2
                                                        },
                                                        "outboundRtpPads": {
                                                            "rule": "repeated",
                                                            "type": "SfuOutboundRtpPad",
                                                            "id": 3
                                                        },
                                                        "sctpChannels": {
                                                            "rule": "repeated",
                                                            "type": "SfuSctpChannel",
                                                            "id": 4
                                                        },
                                                        "transports": {
                                                            "rule": "repeated",
                                                            "type": "SfuTransport",
                                                            "id": 5
                                                        },
                                                        "sfuId": {
                                                            "rule": "required",
                                                            "type": "string",
                                                            "id": 6
                                                        },
                                                        "timestamp": {
                                                            "rule": "required",
                                                            "type": "int64",
                                                            "id": 7
                                                        },
                                                        "marker": {
                                                            "type": "string",
                                                            "id": 8
                                                        },
                                                        "timeZoneOffsetInHours": {
                                                            "type": "int32",
                                                            "id": 9
                                                        }
                                                    },
                                                    "nested": {
                                                        "SfuTransport": {
                                                            "fields": {
                                                                "transportId": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "dtlsState": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "iceRole": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                },
                                                                "iceState": {
                                                                    "type": "string",
                                                                    "id": 4
                                                                },
                                                                "internal": {
                                                                    "type": "bool",
                                                                    "id": 5
                                                                },
                                                                "localAddress": {
                                                                    "type": "string",
                                                                    "id": 6
                                                                },
                                                                "localPort": {
                                                                    "type": "int32",
                                                                    "id": 7
                                                                },
                                                                "noReport": {
                                                                    "type": "bool",
                                                                    "id": 8
                                                                },
                                                                "protocol": {
                                                                    "type": "string",
                                                                    "id": 9
                                                                },
                                                                "remoteAddress": {
                                                                    "type": "string",
                                                                    "id": 10
                                                                },
                                                                "remotePort": {
                                                                    "type": "int32",
                                                                    "id": 11
                                                                },
                                                                "rtpBytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 12
                                                                },
                                                                "rtpBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 13
                                                                },
                                                                "rtpPacketsLost": {
                                                                    "type": "int32",
                                                                    "id": 14
                                                                },
                                                                "rtpPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 15
                                                                },
                                                                "rtpPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 16
                                                                },
                                                                "rtxBytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 17
                                                                },
                                                                "rtxBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 18
                                                                },
                                                                "rtxPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 19
                                                                },
                                                                "rtxPacketsLost": {
                                                                    "type": "int32",
                                                                    "id": 20
                                                                },
                                                                "rtxPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 21
                                                                },
                                                                "rtxPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 22
                                                                },
                                                                "sctpBytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 23
                                                                },
                                                                "sctpBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 24
                                                                },
                                                                "sctpPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 25
                                                                },
                                                                "sctpPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 26
                                                                },
                                                                "sctpState": {
                                                                    "type": "string",
                                                                    "id": 27
                                                                }
                                                            }
                                                        },
                                                        "SfuInboundRtpPad": {
                                                            "fields": {
                                                                "padId": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "ssrc": {
                                                                    "rule": "required",
                                                                    "type": "int64",
                                                                    "id": 2
                                                                },
                                                                "streamId": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 3
                                                                },
                                                                "transportId": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 4
                                                                },
                                                                "bytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 5
                                                                },
                                                                "clockRate": {
                                                                    "type": "int32",
                                                                    "id": 6
                                                                },
                                                                "fecPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 7
                                                                },
                                                                "fecPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 8
                                                                },
                                                                "firCount": {
                                                                    "type": "int32",
                                                                    "id": 9
                                                                },
                                                                "fractionLost": {
                                                                    "type": "double",
                                                                    "id": 10
                                                                },
                                                                "framesDecoded": {
                                                                    "type": "int32",
                                                                    "id": 11
                                                                },
                                                                "framesReceived": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "internal": {
                                                                    "type": "bool",
                                                                    "id": 13
                                                                },
                                                                "jitter": {
                                                                    "type": "double",
                                                                    "id": 14
                                                                },
                                                                "keyFramesDecoded": {
                                                                    "type": "int32",
                                                                    "id": 15
                                                                },
                                                                "mediaType": {
                                                                    "type": "string",
                                                                    "id": 16
                                                                },
                                                                "mimeType": {
                                                                    "type": "string",
                                                                    "id": 17
                                                                },
                                                                "nackCount": {
                                                                    "type": "int32",
                                                                    "id": 18
                                                                },
                                                                "noReport": {
                                                                    "type": "bool",
                                                                    "id": 19
                                                                },
                                                                "packetsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 20
                                                                },
                                                                "packetsDuplicated": {
                                                                    "type": "int32",
                                                                    "id": 21
                                                                },
                                                                "packetsFailedDecryption": {
                                                                    "type": "int32",
                                                                    "id": 22
                                                                },
                                                                "packetsLost": {
                                                                    "type": "int32",
                                                                    "id": 23
                                                                },
                                                                "packetsReceived": {
                                                                    "type": "int32",
                                                                    "id": 24
                                                                },
                                                                "packetsRepaired": {
                                                                    "type": "int32",
                                                                    "id": 25
                                                                },
                                                                "payloadType": {
                                                                    "type": "int32",
                                                                    "id": 26
                                                                },
                                                                "pliCount": {
                                                                    "type": "int32",
                                                                    "id": 27
                                                                },
                                                                "rid": {
                                                                    "type": "string",
                                                                    "id": 28
                                                                },
                                                                "roundTripTime": {
                                                                    "type": "double",
                                                                    "id": 29
                                                                },
                                                                "rtcpRrSent": {
                                                                    "type": "int32",
                                                                    "id": 30
                                                                },
                                                                "rtcpSrReceived": {
                                                                    "type": "int32",
                                                                    "id": 31
                                                                },
                                                                "rtxPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 32
                                                                },
                                                                "rtxPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 33
                                                                },
                                                                "rtxSsrc": {
                                                                    "type": "int64",
                                                                    "id": 34
                                                                },
                                                                "sdpFmtpLine": {
                                                                    "type": "string",
                                                                    "id": 35
                                                                },
                                                                "sliCount": {
                                                                    "type": "int32",
                                                                    "id": 36
                                                                },
                                                                "targetBitrate": {
                                                                    "type": "int32",
                                                                    "id": 37
                                                                },
                                                                "voiceActivityFlag": {
                                                                    "type": "bool",
                                                                    "id": 38
                                                                }
                                                            }
                                                        },
                                                        "SfuOutboundRtpPad": {
                                                            "fields": {
                                                                "padId": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "sinkId": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "ssrc": {
                                                                    "rule": "required",
                                                                    "type": "int64",
                                                                    "id": 3
                                                                },
                                                                "streamId": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 4
                                                                },
                                                                "transportId": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 5
                                                                },
                                                                "bytesSent": {
                                                                    "type": "int64",
                                                                    "id": 6
                                                                },
                                                                "callId": {
                                                                    "type": "string",
                                                                    "id": 7
                                                                },
                                                                "clientId": {
                                                                    "type": "string",
                                                                    "id": 8
                                                                },
                                                                "clockRate": {
                                                                    "type": "int32",
                                                                    "id": 9
                                                                },
                                                                "fecPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 10
                                                                },
                                                                "fecPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 11
                                                                },
                                                                "firCount": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "fractionLost": {
                                                                    "type": "double",
                                                                    "id": 13
                                                                },
                                                                "framesEncoded": {
                                                                    "type": "int32",
                                                                    "id": 14
                                                                },
                                                                "framesSent": {
                                                                    "type": "int32",
                                                                    "id": 15
                                                                },
                                                                "internal": {
                                                                    "type": "bool",
                                                                    "id": 16
                                                                },
                                                                "jitter": {
                                                                    "type": "double",
                                                                    "id": 17
                                                                },
                                                                "keyFramesEncoded": {
                                                                    "type": "int32",
                                                                    "id": 18
                                                                },
                                                                "mediaType": {
                                                                    "type": "string",
                                                                    "id": 19
                                                                },
                                                                "mimeType": {
                                                                    "type": "string",
                                                                    "id": 20
                                                                },
                                                                "nackCount": {
                                                                    "type": "int32",
                                                                    "id": 21
                                                                },
                                                                "noReport": {
                                                                    "type": "bool",
                                                                    "id": 22
                                                                },
                                                                "packetsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 23
                                                                },
                                                                "packetsDuplicated": {
                                                                    "type": "int32",
                                                                    "id": 24
                                                                },
                                                                "packetsFailedEncryption": {
                                                                    "type": "int32",
                                                                    "id": 25
                                                                },
                                                                "packetsLost": {
                                                                    "type": "int32",
                                                                    "id": 26
                                                                },
                                                                "packetsRetransmitted": {
                                                                    "type": "int32",
                                                                    "id": 27
                                                                },
                                                                "packetsSent": {
                                                                    "type": "int32",
                                                                    "id": 28
                                                                },
                                                                "payloadType": {
                                                                    "type": "int32",
                                                                    "id": 29
                                                                },
                                                                "pliCount": {
                                                                    "type": "int32",
                                                                    "id": 30
                                                                },
                                                                "rid": {
                                                                    "type": "string",
                                                                    "id": 31
                                                                },
                                                                "roundTripTime": {
                                                                    "type": "double",
                                                                    "id": 32
                                                                },
                                                                "rtcpRrReceived": {
                                                                    "type": "int32",
                                                                    "id": 33
                                                                },
                                                                "rtcpSrSent": {
                                                                    "type": "int32",
                                                                    "id": 34
                                                                },
                                                                "rtxPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 35
                                                                },
                                                                "rtxPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 36
                                                                },
                                                                "rtxSsrc": {
                                                                    "type": "int64",
                                                                    "id": 37
                                                                },
                                                                "sdpFmtpLine": {
                                                                    "type": "string",
                                                                    "id": 38
                                                                },
                                                                "sliCount": {
                                                                    "type": "int32",
                                                                    "id": 39
                                                                },
                                                                "targetBitrate": {
                                                                    "type": "int32",
                                                                    "id": 40
                                                                },
                                                                "trackId": {
                                                                    "type": "string",
                                                                    "id": 41
                                                                },
                                                                "voiceActivityFlag": {
                                                                    "type": "bool",
                                                                    "id": 42
                                                                }
                                                            }
                                                        },
                                                        "SfuSctpChannel": {
                                                            "fields": {
                                                                "channelId": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "streamId": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "transportId": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 3
                                                                },
                                                                "bytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 4
                                                                },
                                                                "bytesSent": {
                                                                    "type": "int64",
                                                                    "id": 5
                                                                },
                                                                "label": {
                                                                    "type": "string",
                                                                    "id": 6
                                                                },
                                                                "messageReceived": {
                                                                    "type": "int32",
                                                                    "id": 7
                                                                },
                                                                "messageSent": {
                                                                    "type": "int32",
                                                                    "id": 8
                                                                },
                                                                "noReport": {
                                                                    "type": "bool",
                                                                    "id": 9
                                                                },
                                                                "protocol": {
                                                                    "type": "string",
                                                                    "id": 10
                                                                },
                                                                "sctpCongestionWindow": {
                                                                    "type": "double",
                                                                    "id": 11
                                                                },
                                                                "sctpMtu": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "sctpReceiverWindow": {
                                                                    "type": "double",
                                                                    "id": 13
                                                                },
                                                                "sctpSmoothedRoundTripTime": {
                                                                    "type": "double",
                                                                    "id": 14
                                                                },
                                                                "sctpUnackData": {
                                                                    "type": "int32",
                                                                    "id": 15
                                                                }
                                                            }
                                                        },
                                                        "SfuExtensionStats": {
                                                            "fields": {
                                                                "payload": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "type": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 2
                                                                }
                                                            }
                                                        }
                                                    }
                                                },
                                                "TurnSample": {
                                                    "fields": {
                                                        "allocations": {
                                                            "rule": "repeated",
                                                            "type": "TurnPeerAllocation",
                                                            "id": 1
                                                        },
                                                        "sessions": {
                                                            "rule": "repeated",
                                                            "type": "TurnSession",
                                                            "id": 2
                                                        },
                                                        "serverId": {
                                                            "rule": "required",
                                                            "type": "string",
                                                            "id": 3
                                                        }
                                                    },
                                                    "nested": {
                                                        "TurnPeerAllocation": {
                                                            "fields": {
                                                                "peerId": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "relayedAddress": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "relayedPort": {
                                                                    "rule": "required",
                                                                    "type": "int32",
                                                                    "id": 3
                                                                },
                                                                "sessionId": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 4
                                                                },
                                                                "transportProtocol": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 5
                                                                },
                                                                "peerAddress": {
                                                                    "type": "string",
                                                                    "id": 6
                                                                },
                                                                "peerPort": {
                                                                    "type": "int32",
                                                                    "id": 7
                                                                },
                                                                "receivedBytes": {
                                                                    "type": "int64",
                                                                    "id": 8
                                                                },
                                                                "receivedPackets": {
                                                                    "type": "int32",
                                                                    "id": 9
                                                                },
                                                                "receivingBitrate": {
                                                                    "type": "int32",
                                                                    "id": 10
                                                                },
                                                                "sendingBitrate": {
                                                                    "type": "int32",
                                                                    "id": 11
                                                                },
                                                                "sentBytes": {
                                                                    "type": "int64",
                                                                    "id": 12
                                                                },
                                                                "sentPackets": {
                                                                    "type": "int32",
                                                                    "id": 13
                                                                }
                                                            }
                                                        },
                                                        "TurnSession": {
                                                            "fields": {
                                                                "sessionId": {
                                                                    "rule": "required",
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "clientAddress": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "clientId": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                },
                                                                "clientPort": {
                                                                    "type": "int32",
                                                                    "id": 4
                                                                },
                                                                "nonceExpirationTime": {
                                                                    "type": "int64",
                                                                    "id": 5
                                                                },
                                                                "realm": {
                                                                    "type": "string",
                                                                    "id": 6
                                                                },
                                                                "receivedBytes": {
                                                                    "type": "int64",
                                                                    "id": 7
                                                                },
                                                                "receivedPackets": {
                                                                    "type": "int32",
                                                                    "id": 8
                                                                },
                                                                "receivingBitrate": {
                                                                    "type": "int32",
                                                                    "id": 9
                                                                },
                                                                "sendingBitrate": {
                                                                    "type": "int32",
                                                                    "id": 10
                                                                },
                                                                "sentBytes": {
                                                                    "type": "int64",
                                                                    "id": 11
                                                                },
                                                                "sentPackets": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "serverAddress": {
                                                                    "type": "string",
                                                                    "id": 13
                                                                },
                                                                "serverPort": {
                                                                    "type": "int32",
                                                                    "id": 14
                                                                },
                                                                "started": {
                                                                    "type": "int64",
                                                                    "id": 15
                                                                },
                                                                "transportProtocol": {
                                                                    "type": "string",
                                                                    "id": 16
                                                                },
                                                                "username": {
                                                                    "type": "string",
                                                                    "id": 17
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
};

},{}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = `
syntax = "proto3";

package org.observertc.schemas.protobuf;

message Samples {
	message SamplesMeta {
		string schemaVersion = 1;
	}
	message ControlFlags {
		bool close = 1;
	}
	message ClientSample {
		message Engine {
			string name = 1;
			string version = 2;
		}
		message Platform {
			string model = 1;
			string type = 2;
			string vendor = 3;
		}
		message Browser {
			string name = 1;
			string version = 2;
		}
		message OperationSystem {
			string name = 1;
			string version = 2;
			string versionName = 3;
		}
		message MediaDevice {
			string id = 1;
			string kind = 2;
			string label = 3;
		}
		message ExtensionStat {
			string payload = 1;
			string type = 2;
		}
		message PeerConnectionTransport {
			string peerConnectionId = 1;
			int64 bytesReceived = 2;
			int64 bytesSent = 3;
			double candidatePairAvailableIncomingBitrate = 4;
			double candidatePairAvailableOutgoingBitrate = 5;
			int64 candidatePairBytesDiscardedOnSend = 6;
			int64 candidatePairBytesReceived = 7;
			int64 candidatePairBytesSent = 8;
			int32 candidatePairCircuitBreakerTriggerCount = 9;
			int64 candidatePairConsentExpiredTimestamp = 10;
			int64 candidatePairConsentRequestBytesSent = 11;
			int32 candidatePairConsentRequestsSent = 12;
			double candidatePairCurrentRoundTripTime = 13;
			int64 candidatePairFirstRequestTimestamp = 14;
			int64 candidatePairLastPacketReceivedTimestamp = 15;
			int64 candidatePairLastPacketSentTimestamp = 16;
			int64 candidatePairLastRequestTimestamp = 17;
			int64 candidatePairLastResponseTimestamp = 18;
			int32 candidatePairPacketsDiscardedOnSend = 19;
			int32 candidatePairPacketsReceived = 20;
			int32 candidatePairPacketsSent = 21;
			int64 candidatePairRequestBytesSent = 22;
			int32 candidatePairRequestsReceived = 23;
			int32 candidatePairRequestsSent = 24;
			int64 candidatePairResponseBytesSent = 25;
			int32 candidatePairResponsesReceived = 26;
			int32 candidatePairResponsesSent = 27;
			int32 candidatePairRetransmissionReceived = 28;
			int32 candidatePairRetransmissionSent = 29;
			string candidatePairState = 30;
			double candidatePairTotalRoundTripTime = 31;
			int32 dataChannelsAccepted = 32;
			int32 dataChannelsClosed = 33;
			int32 dataChannelsOpened = 34;
			int32 dataChannelsRequested = 35;
			string dtlsCipher = 36;
			string dtlsState = 37;
			string iceLocalUsernameFragment = 38;
			string iceRole = 39;
			string iceState = 40;
			string label = 41;
			string localAddress = 42;
			string localCandidateICEServerUrl = 43;
			string localCandidateRelayProtocol = 44;
			string localCandidateType = 45;
			int32 localPort = 46;
			string localProtocol = 47;
			int32 packetsReceived = 48;
			int32 packetsSent = 49;
			string remoteAddress = 50;
			string remoteCandidateICEServerUrl = 51;
			string remoteCandidateRelayProtocol = 52;
			string remoteCandidateType = 53;
			int32 remotePort = 54;
			string remoteProtocol = 55;
			double sctpCongestionWindow = 56;
			int32 sctpMtu = 57;
			double sctpReceiverWindow = 58;
			double sctpSmoothedRoundTripTime = 59;
			int32 sctpUnackData = 60;
			int32 selectedCandidatePairChanges = 61;
			string srtpCipher = 62;
			string tlsGroup = 63;
			string tlsVersion = 64;
		}
		message MediaSourceStat {
			double audioLevel = 1;
			int32 bitDepth = 2;
			double echoReturnLoss = 3;
			double echoReturnLossEnhancement = 4;
			int32 frames = 5;
			double framesPerSecond = 6;
			int32 height = 7;
			string kind = 8;
			bool relayedSource = 9;
			double totalAudioEnergy = 10;
			double totalSamplesDuration = 11;
			string trackIdentifier = 12;
			int32 width = 13;
		}
		message MediaCodecStats {
			int32 channels = 1;
			int32 clockRate = 2;
			string codecType = 3;
			string mimeType = 4;
			string payloadType = 5;
			string sdpFmtpLine = 6;
		}
		message Certificate {
			string base64Certificate = 1;
			string fingerprint = 2;
			string fingerprintAlgorithm = 3;
			string issuerCertificateId = 4;
		}
		message InboundAudioTrack {
			int64 ssrc = 1;
			double averageRtcpInterval = 2;
			int32 burstDiscardCount = 3;
			double burstDiscardRate = 4;
			int32 burstLossCount = 5;
			double burstLossRate = 6;
			int32 burstPacketsDiscarded = 7;
			int32 burstPacketsLost = 8;
			int64 bytesReceived = 9;
			int64 bytesSent = 10;
			int32 channels = 11;
			int32 clockRate = 12;
			int32 concealedSamples = 13;
			int32 concealmentEvents = 14;
			string decoderImplementation = 15;
			bool ended = 16;
			int64 estimatedPlayoutTimestamp = 17;
			int32 fecPacketsDiscarded = 18;
			int32 fecPacketsReceived = 19;
			double gapDiscardRate = 20;
			double gapLossRate = 21;
			int64 headerBytesReceived = 22;
			int32 insertedSamplesForDeceleration = 23;
			double jitter = 24;
			double jitterBufferDelay = 25;
			int32 jitterBufferEmittedCount = 26;
			int64 lastPacketReceivedTimestamp = 27;
			string mimeType = 28;
			int32 nackCount = 29;
			int32 packetsDiscarded = 30;
			int32 packetsDuplicated = 31;
			int32 packetsFailedDecryption = 32;
			int32 packetsLost = 33;
			int32 packetsReceived = 34;
			int32 packetsRepaired = 35;
			int32 packetsSent = 36;
			int32 payloadType = 37;
			string peerConnectionId = 38;
			int32 perDscpPacketsReceived = 39;
			string remoteClientId = 40;
			int64 remoteTimestamp = 41;
			int32 removedSamplesForAcceleration = 42;
			int32 reportsSent = 43;
			double roundTripTime = 44;
			int32 roundTripTimeMeasurements = 45;
			int32 samplesDecodedWithCelt = 46;
			int32 samplesDecodedWithSilk = 47;
			string sdpFmtpLine = 48;
			string sfuSinkId = 49;
			int32 silentConcealedSamples = 50;
			double totalProcessingDelay = 51;
			double totalRoundTripTime = 52;
			int32 totalSamplesDecoded = 53;
			int32 totalSamplesReceived = 54;
			string trackId = 55;
			bool voiceActivityFlag = 56;
		}
		message InboundVideoTrack {
			int64 ssrc = 1;
			double averageRtcpInterval = 2;
			int32 burstDiscardCount = 3;
			double burstDiscardRate = 4;
			int32 burstLossCount = 5;
			double burstLossRate = 6;
			int32 burstPacketsDiscarded = 7;
			int32 burstPacketsLost = 8;
			int64 bytesReceived = 9;
			int64 bytesSent = 10;
			int32 channels = 11;
			int32 clockRate = 12;
			string decoderImplementation = 13;
			bool ended = 14;
			int64 estimatedPlayoutTimestamp = 15;
			int32 fecPacketsDiscarded = 16;
			int32 fecPacketsReceived = 17;
			int32 firCount = 18;
			int32 frameBitDepth = 19;
			int32 frameHeight = 20;
			int32 frameWidth = 21;
			int32 framesDecoded = 22;
			int32 framesDropped = 23;
			double framesPerSecond = 24;
			int32 framesReceived = 25;
			int32 fullFramesLost = 26;
			double gapDiscardRate = 27;
			double gapLossRate = 28;
			int64 headerBytesReceived = 29;
			double jitter = 30;
			double jitterBufferDelay = 31;
			int32 jitterBufferEmittedCount = 32;
			int32 keyFramesDecoded = 33;
			int64 lastPacketReceivedTimestamp = 34;
			string mimeType = 35;
			int32 nackCount = 36;
			int32 packetsDiscarded = 37;
			int32 packetsDuplicated = 38;
			int32 packetsFailedDecryption = 39;
			int32 packetsLost = 40;
			int32 packetsReceived = 41;
			int32 packetsRepaired = 42;
			int32 packetsSent = 43;
			int32 partialFramesLost = 44;
			int32 payloadType = 45;
			string peerConnectionId = 46;
			int32 perDscpPacketsReceived = 47;
			int32 pliCount = 48;
			int64 qpSum = 49;
			string remoteClientId = 50;
			int64 remoteTimestamp = 51;
			int32 reportsSent = 52;
			double roundTripTime = 53;
			int32 roundTripTimeMeasurements = 54;
			string sdpFmtpLine = 55;
			string sfuSinkId = 56;
			int32 sliCount = 57;
			double totalDecodeTime = 58;
			double totalInterFrameDelay = 59;
			double totalProcessingDelay = 60;
			double totalRoundTripTime = 61;
			double totalSquaredInterFrameDelay = 62;
			string trackId = 63;
		}
		message OutboundAudioTrack {
			int64 ssrc = 1;
			double audioLevel = 2;
			double averageRtcpInterval = 3;
			int32 burstDiscardCount = 4;
			double burstDiscardRate = 5;
			int32 burstLossCount = 6;
			double burstLossRate = 7;
			int32 burstPacketsDiscarded = 8;
			int32 burstPacketsLost = 9;
			int64 bytesDiscardedOnSend = 10;
			int64 bytesSent = 11;
			int32 channels = 12;
			int32 clockRate = 13;
			double echoReturnLoss = 14;
			double echoReturnLossEnhancement = 15;
			string encoderImplementation = 16;
			bool ended = 17;
			int32 fecPacketsSent = 18;
			double fractionLost = 19;
			double gapDiscardRate = 20;
			double gapLossRate = 21;
			int64 headerBytesSent = 22;
			double jitter = 23;
			int64 lastPacketSentTimestamp = 24;
			string mimeType = 25;
			int32 nackCount = 26;
			int32 packetsDiscarded = 27;
			int32 packetsDiscardedOnSend = 28;
			int32 packetsLost = 29;
			int32 packetsReceived = 30;
			int32 packetsRepaired = 31;
			int32 packetsSent = 32;
			int32 payloadType = 33;
			string peerConnectionId = 34;
			int32 perDscpPacketsSent = 35;
			bool relayedSource = 36;
			int32 reportsReceived = 37;
			int64 retransmittedBytesSent = 38;
			int32 retransmittedPacketsSent = 39;
			string rid = 40;
			double roundTripTime = 41;
			int32 roundTripTimeMeasurements = 42;
			int64 rtxSsrc = 43;
			int32 samplesEncodedWithCelt = 44;
			int32 samplesEncodedWithSilk = 45;
			string sdpFmtpLine = 46;
			string sfuStreamId = 47;
			int32 targetBitrate = 48;
			double totalAudioEnergy = 49;
			int64 totalEncodedBytesTarget = 50;
			double totalPacketSendDelay = 51;
			double totalRoundTripTime = 52;
			double totalSamplesDuration = 53;
			int32 totalSamplesSent = 54;
			string trackId = 55;
			bool voiceActivityFlag = 56;
		}
		message OutboundVideoTrack {
			int64 ssrc = 1;
			double averageRtcpInterval = 2;
			int32 bitDepth = 3;
			int32 burstDiscardCount = 4;
			double burstDiscardRate = 5;
			int32 burstLossCount = 6;
			double burstLossRate = 7;
			int32 burstPacketsDiscarded = 8;
			int32 burstPacketsLost = 9;
			int64 bytesDiscardedOnSend = 10;
			int64 bytesSent = 11;
			int32 channels = 12;
			int32 clockRate = 13;
			string encoderImplementation = 14;
			bool ended = 15;
			int32 fecPacketsSent = 16;
			int32 firCount = 17;
			double fractionLost = 18;
			int32 frameBitDepth = 19;
			int32 frameHeight = 20;
			int32 frameWidth = 21;
			int32 frames = 22;
			int32 framesDiscardedOnSend = 23;
			int32 framesDropped = 24;
			int32 framesEncoded = 25;
			double framesPerSecond = 26;
			int32 framesSent = 27;
			int32 fullFramesLost = 28;
			double gapDiscardRate = 29;
			double gapLossRate = 30;
			int64 headerBytesSent = 31;
			int32 height = 32;
			int32 hugeFramesSent = 33;
			double jitter = 34;
			int32 keyFramesEncoded = 35;
			int64 lastPacketSentTimestamp = 36;
			string mimeType = 37;
			int32 nackCount = 38;
			int32 packetsDiscarded = 39;
			int32 packetsDiscardedOnSend = 40;
			int32 packetsLost = 41;
			int32 packetsReceived = 42;
			int32 packetsRepaired = 43;
			int32 packetsSent = 44;
			int32 partialFramesLost = 45;
			int32 payloadType = 46;
			string peerConnectionId = 47;
			int32 perDscpPacketsSent = 48;
			int32 pliCount = 49;
			int64 qpSum = 50;
			double qualityLimitationDurationBandwidth = 51;
			double qualityLimitationDurationCPU = 52;
			double qualityLimitationDurationNone = 53;
			double qualityLimitationDurationOther = 54;
			string qualityLimitationReason = 55;
			int32 qualityLimitationResolutionChanges = 56;
			bool relayedSource = 57;
			int32 reportsReceived = 58;
			int64 retransmittedBytesSent = 59;
			int32 retransmittedPacketsSent = 60;
			string rid = 61;
			double roundTripTime = 62;
			int32 roundTripTimeMeasurements = 63;
			int64 rtxSsrc = 64;
			string sdpFmtpLine = 65;
			string sfuStreamId = 66;
			int32 sliCount = 67;
			int32 targetBitrate = 68;
			double totalEncodeTime = 69;
			int64 totalEncodedBytesTarget = 70;
			double totalPacketSendDelay = 71;
			double totalRoundTripTime = 72;
			string trackId = 73;
			int32 width = 74;
		}
		message IceLocalCandidate {
			string address = 1;
			string candidateType = 2;
			string id = 3;
			string peerConnectionId = 4;
			int32 port = 5;
			int64 priority = 6;
			string protocol = 7;
			string relayProtocol = 8;
			string url = 9;
		}
		message IceRemoteCandidate {
			string address = 1;
			string candidateType = 2;
			string id = 3;
			string peerConnectionId = 4;
			int32 port = 5;
			int64 priority = 6;
			string protocol = 7;
			string relayProtocol = 8;
			string url = 9;
		}
		message DataChannel {
			string address = 1;
			int64 bytesReceived = 2;
			int64 bytesSent = 3;
			int32 dataChannelIdentifier = 4;
			string id = 5;
			string label = 6;
			int32 messagesReceived = 7;
			int32 messagesSent = 8;
			string peerConnectionId = 9;
			int32 port = 10;
			string protocol = 11;
			string state = 12;
		}
		repeated Certificate certificates = 1;
		repeated MediaCodecStats codecs = 2;
		repeated DataChannel dataChannels = 3;
		repeated ExtensionStat extensionStats = 4;
		repeated IceLocalCandidate iceLocalCandidates = 5;
		repeated IceRemoteCandidate iceRemoteCandidates = 6;
		repeated string iceServers = 7;
		repeated InboundAudioTrack inboundAudioTracks = 8;
		repeated InboundVideoTrack inboundVideoTracks = 9;
		repeated string localSDPs = 10;
		repeated string mediaConstraints = 11;
		repeated MediaDevice mediaDevices = 12;
		repeated MediaSourceStat mediaSources = 13;
		repeated OutboundAudioTrack outboundAudioTracks = 14;
		repeated OutboundVideoTrack outboundVideoTracks = 15;
		repeated PeerConnectionTransport pcTransports = 16;
		repeated string userMediaErrors = 17;
		string clientId = 18;
		int64 timestamp = 19;
		Browser browser = 20;
		string callId = 21;
		Engine engine = 22;
		string marker = 23;
		OperationSystem os = 24;
		Platform platform = 25;
		string roomId = 26;
		int32 sampleSeq = 27;
		int32 timeZoneOffsetInHours = 28;
		string userId = 29;
	}
	message SfuSample {
		message SfuTransport {
			string transportId = 1;
			string dtlsState = 2;
			string iceRole = 3;
			string iceState = 4;
			bool internal = 5;
			string localAddress = 6;
			int32 localPort = 7;
			bool noReport = 8;
			string protocol = 9;
			string remoteAddress = 10;
			int32 remotePort = 11;
			int64 rtpBytesReceived = 12;
			int64 rtpBytesSent = 13;
			int32 rtpPacketsLost = 14;
			int32 rtpPacketsReceived = 15;
			int32 rtpPacketsSent = 16;
			int64 rtxBytesReceived = 17;
			int64 rtxBytesSent = 18;
			int32 rtxPacketsDiscarded = 19;
			int32 rtxPacketsLost = 20;
			int32 rtxPacketsReceived = 21;
			int32 rtxPacketsSent = 22;
			int64 sctpBytesReceived = 23;
			int64 sctpBytesSent = 24;
			int32 sctpPacketsReceived = 25;
			int32 sctpPacketsSent = 26;
			string sctpState = 27;
		}
		message SfuInboundRtpPad {
			string padId = 1;
			int64 ssrc = 2;
			string streamId = 3;
			string transportId = 4;
			int64 bytesReceived = 5;
			int32 clockRate = 6;
			int32 fecPacketsDiscarded = 7;
			int32 fecPacketsReceived = 8;
			int32 firCount = 9;
			double fractionLost = 10;
			int32 framesDecoded = 11;
			int32 framesReceived = 12;
			bool internal = 13;
			double jitter = 14;
			int32 keyFramesDecoded = 15;
			string mediaType = 16;
			string mimeType = 17;
			int32 nackCount = 18;
			bool noReport = 19;
			int32 packetsDiscarded = 20;
			int32 packetsDuplicated = 21;
			int32 packetsFailedDecryption = 22;
			int32 packetsLost = 23;
			int32 packetsReceived = 24;
			int32 packetsRepaired = 25;
			int32 payloadType = 26;
			int32 pliCount = 27;
			string rid = 28;
			double roundTripTime = 29;
			int32 rtcpRrSent = 30;
			int32 rtcpSrReceived = 31;
			int32 rtxPacketsDiscarded = 32;
			int32 rtxPacketsReceived = 33;
			int64 rtxSsrc = 34;
			string sdpFmtpLine = 35;
			int32 sliCount = 36;
			int32 targetBitrate = 37;
			bool voiceActivityFlag = 38;
		}
		message SfuOutboundRtpPad {
			string padId = 1;
			string sinkId = 2;
			int64 ssrc = 3;
			string streamId = 4;
			string transportId = 5;
			int64 bytesSent = 6;
			string callId = 7;
			string clientId = 8;
			int32 clockRate = 9;
			int32 fecPacketsDiscarded = 10;
			int32 fecPacketsSent = 11;
			int32 firCount = 12;
			double fractionLost = 13;
			int32 framesEncoded = 14;
			int32 framesSent = 15;
			bool internal = 16;
			double jitter = 17;
			int32 keyFramesEncoded = 18;
			string mediaType = 19;
			string mimeType = 20;
			int32 nackCount = 21;
			bool noReport = 22;
			int32 packetsDiscarded = 23;
			int32 packetsDuplicated = 24;
			int32 packetsFailedEncryption = 25;
			int32 packetsLost = 26;
			int32 packetsRetransmitted = 27;
			int32 packetsSent = 28;
			int32 payloadType = 29;
			int32 pliCount = 30;
			string rid = 31;
			double roundTripTime = 32;
			int32 rtcpRrReceived = 33;
			int32 rtcpSrSent = 34;
			int32 rtxPacketsDiscarded = 35;
			int32 rtxPacketsSent = 36;
			int64 rtxSsrc = 37;
			string sdpFmtpLine = 38;
			int32 sliCount = 39;
			int32 targetBitrate = 40;
			string trackId = 41;
			bool voiceActivityFlag = 42;
		}
		message SfuSctpChannel {
			string channelId = 1;
			string streamId = 2;
			string transportId = 3;
			int64 bytesReceived = 4;
			int64 bytesSent = 5;
			string label = 6;
			int32 messageReceived = 7;
			int32 messageSent = 8;
			bool noReport = 9;
			string protocol = 10;
			double sctpCongestionWindow = 11;
			int32 sctpMtu = 12;
			double sctpReceiverWindow = 13;
			double sctpSmoothedRoundTripTime = 14;
			int32 sctpUnackData = 15;
		}
		message SfuExtensionStats {
			string payload = 1;
			string type = 2;
		}
		repeated SfuExtensionStats extensionStats = 1;
		repeated SfuInboundRtpPad inboundRtpPads = 2;
		repeated SfuOutboundRtpPad outboundRtpPads = 3;
		repeated SfuSctpChannel sctpChannels = 4;
		repeated SfuTransport transports = 5;
		string sfuId = 6;
		int64 timestamp = 7;
		string marker = 8;
		int32 timeZoneOffsetInHours = 9;
	}
	message TurnSample {
		message TurnPeerAllocation {
			string peerId = 1;
			string relayedAddress = 2;
			int32 relayedPort = 3;
			string sessionId = 4;
			string transportProtocol = 5;
			string peerAddress = 6;
			int32 peerPort = 7;
			int64 receivedBytes = 8;
			int32 receivedPackets = 9;
			int32 receivingBitrate = 10;
			int32 sendingBitrate = 11;
			int64 sentBytes = 12;
			int32 sentPackets = 13;
		}
		message TurnSession {
			string sessionId = 1;
			string clientAddress = 2;
			string clientId = 3;
			int32 clientPort = 4;
			int64 nonceExpirationTime = 5;
			string realm = 6;
			int64 receivedBytes = 7;
			int32 receivedPackets = 8;
			int32 receivingBitrate = 9;
			int32 sendingBitrate = 10;
			int64 sentBytes = 11;
			int32 sentPackets = 12;
			string serverAddress = 13;
			int32 serverPort = 14;
			int64 started = 15;
			string transportProtocol = 16;
			string username = 17;
		}
		repeated TurnPeerAllocation allocations = 1;
		repeated TurnSession sessions = 2;
		string serverId = 3;
	}
	repeated ClientSample clientSamples = 1;
	repeated SfuSample sfuSamples = 2;
	repeated TurnSample turnSamples = 3;
	ControlFlags controlFlags = 4;
	SamplesMeta meta = 5;
}
`;

},{}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jsonDescriptor = void 0;
exports.jsonDescriptor = {
    "nested": {
        "org": {
            "nested": {
                "observertc": {
                    "nested": {
                        "schemas": {
                            "nested": {
                                "protobuf": {
                                    "nested": {
                                        "Samples": {
                                            "fields": {
                                                "clientSamples": {
                                                    "rule": "repeated",
                                                    "type": "ClientSample",
                                                    "id": 1
                                                },
                                                "sfuSamples": {
                                                    "rule": "repeated",
                                                    "type": "SfuSample",
                                                    "id": 2
                                                },
                                                "turnSamples": {
                                                    "rule": "repeated",
                                                    "type": "TurnSample",
                                                    "id": 3
                                                },
                                                "controlFlags": {
                                                    "type": "ControlFlags",
                                                    "id": 4
                                                },
                                                "meta": {
                                                    "type": "SamplesMeta",
                                                    "id": 5
                                                }
                                            },
                                            "nested": {
                                                "SamplesMeta": {
                                                    "fields": {
                                                        "schemaVersion": {
                                                            "type": "string",
                                                            "id": 1
                                                        }
                                                    }
                                                },
                                                "ControlFlags": {
                                                    "fields": {
                                                        "close": {
                                                            "type": "bool",
                                                            "id": 1
                                                        }
                                                    }
                                                },
                                                "ClientSample": {
                                                    "fields": {
                                                        "certificates": {
                                                            "rule": "repeated",
                                                            "type": "Certificate",
                                                            "id": 1
                                                        },
                                                        "codecs": {
                                                            "rule": "repeated",
                                                            "type": "MediaCodecStats",
                                                            "id": 2
                                                        },
                                                        "dataChannels": {
                                                            "rule": "repeated",
                                                            "type": "DataChannel",
                                                            "id": 3
                                                        },
                                                        "extensionStats": {
                                                            "rule": "repeated",
                                                            "type": "ExtensionStat",
                                                            "id": 4
                                                        },
                                                        "iceLocalCandidates": {
                                                            "rule": "repeated",
                                                            "type": "IceLocalCandidate",
                                                            "id": 5
                                                        },
                                                        "iceRemoteCandidates": {
                                                            "rule": "repeated",
                                                            "type": "IceRemoteCandidate",
                                                            "id": 6
                                                        },
                                                        "iceServers": {
                                                            "rule": "repeated",
                                                            "type": "string",
                                                            "id": 7
                                                        },
                                                        "inboundAudioTracks": {
                                                            "rule": "repeated",
                                                            "type": "InboundAudioTrack",
                                                            "id": 8
                                                        },
                                                        "inboundVideoTracks": {
                                                            "rule": "repeated",
                                                            "type": "InboundVideoTrack",
                                                            "id": 9
                                                        },
                                                        "localSDPs": {
                                                            "rule": "repeated",
                                                            "type": "string",
                                                            "id": 10
                                                        },
                                                        "mediaConstraints": {
                                                            "rule": "repeated",
                                                            "type": "string",
                                                            "id": 11
                                                        },
                                                        "mediaDevices": {
                                                            "rule": "repeated",
                                                            "type": "MediaDevice",
                                                            "id": 12
                                                        },
                                                        "mediaSources": {
                                                            "rule": "repeated",
                                                            "type": "MediaSourceStat",
                                                            "id": 13
                                                        },
                                                        "outboundAudioTracks": {
                                                            "rule": "repeated",
                                                            "type": "OutboundAudioTrack",
                                                            "id": 14
                                                        },
                                                        "outboundVideoTracks": {
                                                            "rule": "repeated",
                                                            "type": "OutboundVideoTrack",
                                                            "id": 15
                                                        },
                                                        "pcTransports": {
                                                            "rule": "repeated",
                                                            "type": "PeerConnectionTransport",
                                                            "id": 16
                                                        },
                                                        "userMediaErrors": {
                                                            "rule": "repeated",
                                                            "type": "string",
                                                            "id": 17
                                                        },
                                                        "clientId": {
                                                            "type": "string",
                                                            "id": 18
                                                        },
                                                        "timestamp": {
                                                            "type": "int64",
                                                            "id": 19
                                                        },
                                                        "browser": {
                                                            "type": "Browser",
                                                            "id": 20
                                                        },
                                                        "callId": {
                                                            "type": "string",
                                                            "id": 21
                                                        },
                                                        "engine": {
                                                            "type": "Engine",
                                                            "id": 22
                                                        },
                                                        "marker": {
                                                            "type": "string",
                                                            "id": 23
                                                        },
                                                        "os": {
                                                            "type": "OperationSystem",
                                                            "id": 24
                                                        },
                                                        "platform": {
                                                            "type": "Platform",
                                                            "id": 25
                                                        },
                                                        "roomId": {
                                                            "type": "string",
                                                            "id": 26
                                                        },
                                                        "sampleSeq": {
                                                            "type": "int32",
                                                            "id": 27
                                                        },
                                                        "timeZoneOffsetInHours": {
                                                            "type": "int32",
                                                            "id": 28
                                                        },
                                                        "userId": {
                                                            "type": "string",
                                                            "id": 29
                                                        }
                                                    },
                                                    "nested": {
                                                        "Engine": {
                                                            "fields": {
                                                                "name": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "version": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                }
                                                            }
                                                        },
                                                        "Platform": {
                                                            "fields": {
                                                                "model": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "type": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "vendor": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                }
                                                            }
                                                        },
                                                        "Browser": {
                                                            "fields": {
                                                                "name": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "version": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                }
                                                            }
                                                        },
                                                        "OperationSystem": {
                                                            "fields": {
                                                                "name": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "version": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "versionName": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                }
                                                            }
                                                        },
                                                        "MediaDevice": {
                                                            "fields": {
                                                                "id": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "kind": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "label": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                }
                                                            }
                                                        },
                                                        "ExtensionStat": {
                                                            "fields": {
                                                                "payload": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "type": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                }
                                                            }
                                                        },
                                                        "PeerConnectionTransport": {
                                                            "fields": {
                                                                "peerConnectionId": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "bytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 2
                                                                },
                                                                "bytesSent": {
                                                                    "type": "int64",
                                                                    "id": 3
                                                                },
                                                                "candidatePairAvailableIncomingBitrate": {
                                                                    "type": "double",
                                                                    "id": 4
                                                                },
                                                                "candidatePairAvailableOutgoingBitrate": {
                                                                    "type": "double",
                                                                    "id": 5
                                                                },
                                                                "candidatePairBytesDiscardedOnSend": {
                                                                    "type": "int64",
                                                                    "id": 6
                                                                },
                                                                "candidatePairBytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 7
                                                                },
                                                                "candidatePairBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 8
                                                                },
                                                                "candidatePairCircuitBreakerTriggerCount": {
                                                                    "type": "int32",
                                                                    "id": 9
                                                                },
                                                                "candidatePairConsentExpiredTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 10
                                                                },
                                                                "candidatePairConsentRequestBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 11
                                                                },
                                                                "candidatePairConsentRequestsSent": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "candidatePairCurrentRoundTripTime": {
                                                                    "type": "double",
                                                                    "id": 13
                                                                },
                                                                "candidatePairFirstRequestTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 14
                                                                },
                                                                "candidatePairLastPacketReceivedTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 15
                                                                },
                                                                "candidatePairLastPacketSentTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 16
                                                                },
                                                                "candidatePairLastRequestTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 17
                                                                },
                                                                "candidatePairLastResponseTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 18
                                                                },
                                                                "candidatePairPacketsDiscardedOnSend": {
                                                                    "type": "int32",
                                                                    "id": 19
                                                                },
                                                                "candidatePairPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 20
                                                                },
                                                                "candidatePairPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 21
                                                                },
                                                                "candidatePairRequestBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 22
                                                                },
                                                                "candidatePairRequestsReceived": {
                                                                    "type": "int32",
                                                                    "id": 23
                                                                },
                                                                "candidatePairRequestsSent": {
                                                                    "type": "int32",
                                                                    "id": 24
                                                                },
                                                                "candidatePairResponseBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 25
                                                                },
                                                                "candidatePairResponsesReceived": {
                                                                    "type": "int32",
                                                                    "id": 26
                                                                },
                                                                "candidatePairResponsesSent": {
                                                                    "type": "int32",
                                                                    "id": 27
                                                                },
                                                                "candidatePairRetransmissionReceived": {
                                                                    "type": "int32",
                                                                    "id": 28
                                                                },
                                                                "candidatePairRetransmissionSent": {
                                                                    "type": "int32",
                                                                    "id": 29
                                                                },
                                                                "candidatePairState": {
                                                                    "type": "string",
                                                                    "id": 30
                                                                },
                                                                "candidatePairTotalRoundTripTime": {
                                                                    "type": "double",
                                                                    "id": 31
                                                                },
                                                                "dataChannelsAccepted": {
                                                                    "type": "int32",
                                                                    "id": 32
                                                                },
                                                                "dataChannelsClosed": {
                                                                    "type": "int32",
                                                                    "id": 33
                                                                },
                                                                "dataChannelsOpened": {
                                                                    "type": "int32",
                                                                    "id": 34
                                                                },
                                                                "dataChannelsRequested": {
                                                                    "type": "int32",
                                                                    "id": 35
                                                                },
                                                                "dtlsCipher": {
                                                                    "type": "string",
                                                                    "id": 36
                                                                },
                                                                "dtlsState": {
                                                                    "type": "string",
                                                                    "id": 37
                                                                },
                                                                "iceLocalUsernameFragment": {
                                                                    "type": "string",
                                                                    "id": 38
                                                                },
                                                                "iceRole": {
                                                                    "type": "string",
                                                                    "id": 39
                                                                },
                                                                "iceState": {
                                                                    "type": "string",
                                                                    "id": 40
                                                                },
                                                                "label": {
                                                                    "type": "string",
                                                                    "id": 41
                                                                },
                                                                "localAddress": {
                                                                    "type": "string",
                                                                    "id": 42
                                                                },
                                                                "localCandidateICEServerUrl": {
                                                                    "type": "string",
                                                                    "id": 43
                                                                },
                                                                "localCandidateRelayProtocol": {
                                                                    "type": "string",
                                                                    "id": 44
                                                                },
                                                                "localCandidateType": {
                                                                    "type": "string",
                                                                    "id": 45
                                                                },
                                                                "localPort": {
                                                                    "type": "int32",
                                                                    "id": 46
                                                                },
                                                                "localProtocol": {
                                                                    "type": "string",
                                                                    "id": 47
                                                                },
                                                                "packetsReceived": {
                                                                    "type": "int32",
                                                                    "id": 48
                                                                },
                                                                "packetsSent": {
                                                                    "type": "int32",
                                                                    "id": 49
                                                                },
                                                                "remoteAddress": {
                                                                    "type": "string",
                                                                    "id": 50
                                                                },
                                                                "remoteCandidateICEServerUrl": {
                                                                    "type": "string",
                                                                    "id": 51
                                                                },
                                                                "remoteCandidateRelayProtocol": {
                                                                    "type": "string",
                                                                    "id": 52
                                                                },
                                                                "remoteCandidateType": {
                                                                    "type": "string",
                                                                    "id": 53
                                                                },
                                                                "remotePort": {
                                                                    "type": "int32",
                                                                    "id": 54
                                                                },
                                                                "remoteProtocol": {
                                                                    "type": "string",
                                                                    "id": 55
                                                                },
                                                                "sctpCongestionWindow": {
                                                                    "type": "double",
                                                                    "id": 56
                                                                },
                                                                "sctpMtu": {
                                                                    "type": "int32",
                                                                    "id": 57
                                                                },
                                                                "sctpReceiverWindow": {
                                                                    "type": "double",
                                                                    "id": 58
                                                                },
                                                                "sctpSmoothedRoundTripTime": {
                                                                    "type": "double",
                                                                    "id": 59
                                                                },
                                                                "sctpUnackData": {
                                                                    "type": "int32",
                                                                    "id": 60
                                                                },
                                                                "selectedCandidatePairChanges": {
                                                                    "type": "int32",
                                                                    "id": 61
                                                                },
                                                                "srtpCipher": {
                                                                    "type": "string",
                                                                    "id": 62
                                                                },
                                                                "tlsGroup": {
                                                                    "type": "string",
                                                                    "id": 63
                                                                },
                                                                "tlsVersion": {
                                                                    "type": "string",
                                                                    "id": 64
                                                                }
                                                            }
                                                        },
                                                        "MediaSourceStat": {
                                                            "fields": {
                                                                "audioLevel": {
                                                                    "type": "double",
                                                                    "id": 1
                                                                },
                                                                "bitDepth": {
                                                                    "type": "int32",
                                                                    "id": 2
                                                                },
                                                                "echoReturnLoss": {
                                                                    "type": "double",
                                                                    "id": 3
                                                                },
                                                                "echoReturnLossEnhancement": {
                                                                    "type": "double",
                                                                    "id": 4
                                                                },
                                                                "frames": {
                                                                    "type": "int32",
                                                                    "id": 5
                                                                },
                                                                "framesPerSecond": {
                                                                    "type": "double",
                                                                    "id": 6
                                                                },
                                                                "height": {
                                                                    "type": "int32",
                                                                    "id": 7
                                                                },
                                                                "kind": {
                                                                    "type": "string",
                                                                    "id": 8
                                                                },
                                                                "relayedSource": {
                                                                    "type": "bool",
                                                                    "id": 9
                                                                },
                                                                "totalAudioEnergy": {
                                                                    "type": "double",
                                                                    "id": 10
                                                                },
                                                                "totalSamplesDuration": {
                                                                    "type": "double",
                                                                    "id": 11
                                                                },
                                                                "trackIdentifier": {
                                                                    "type": "string",
                                                                    "id": 12
                                                                },
                                                                "width": {
                                                                    "type": "int32",
                                                                    "id": 13
                                                                }
                                                            }
                                                        },
                                                        "MediaCodecStats": {
                                                            "fields": {
                                                                "channels": {
                                                                    "type": "int32",
                                                                    "id": 1
                                                                },
                                                                "clockRate": {
                                                                    "type": "int32",
                                                                    "id": 2
                                                                },
                                                                "codecType": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                },
                                                                "mimeType": {
                                                                    "type": "string",
                                                                    "id": 4
                                                                },
                                                                "payloadType": {
                                                                    "type": "string",
                                                                    "id": 5
                                                                },
                                                                "sdpFmtpLine": {
                                                                    "type": "string",
                                                                    "id": 6
                                                                }
                                                            }
                                                        },
                                                        "Certificate": {
                                                            "fields": {
                                                                "base64Certificate": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "fingerprint": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "fingerprintAlgorithm": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                },
                                                                "issuerCertificateId": {
                                                                    "type": "string",
                                                                    "id": 4
                                                                }
                                                            }
                                                        },
                                                        "InboundAudioTrack": {
                                                            "fields": {
                                                                "ssrc": {
                                                                    "type": "int64",
                                                                    "id": 1
                                                                },
                                                                "averageRtcpInterval": {
                                                                    "type": "double",
                                                                    "id": 2
                                                                },
                                                                "burstDiscardCount": {
                                                                    "type": "int32",
                                                                    "id": 3
                                                                },
                                                                "burstDiscardRate": {
                                                                    "type": "double",
                                                                    "id": 4
                                                                },
                                                                "burstLossCount": {
                                                                    "type": "int32",
                                                                    "id": 5
                                                                },
                                                                "burstLossRate": {
                                                                    "type": "double",
                                                                    "id": 6
                                                                },
                                                                "burstPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 7
                                                                },
                                                                "burstPacketsLost": {
                                                                    "type": "int32",
                                                                    "id": 8
                                                                },
                                                                "bytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 9
                                                                },
                                                                "bytesSent": {
                                                                    "type": "int64",
                                                                    "id": 10
                                                                },
                                                                "channels": {
                                                                    "type": "int32",
                                                                    "id": 11
                                                                },
                                                                "clockRate": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "concealedSamples": {
                                                                    "type": "int32",
                                                                    "id": 13
                                                                },
                                                                "concealmentEvents": {
                                                                    "type": "int32",
                                                                    "id": 14
                                                                },
                                                                "decoderImplementation": {
                                                                    "type": "string",
                                                                    "id": 15
                                                                },
                                                                "ended": {
                                                                    "type": "bool",
                                                                    "id": 16
                                                                },
                                                                "estimatedPlayoutTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 17
                                                                },
                                                                "fecPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 18
                                                                },
                                                                "fecPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 19
                                                                },
                                                                "gapDiscardRate": {
                                                                    "type": "double",
                                                                    "id": 20
                                                                },
                                                                "gapLossRate": {
                                                                    "type": "double",
                                                                    "id": 21
                                                                },
                                                                "headerBytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 22
                                                                },
                                                                "insertedSamplesForDeceleration": {
                                                                    "type": "int32",
                                                                    "id": 23
                                                                },
                                                                "jitter": {
                                                                    "type": "double",
                                                                    "id": 24
                                                                },
                                                                "jitterBufferDelay": {
                                                                    "type": "double",
                                                                    "id": 25
                                                                },
                                                                "jitterBufferEmittedCount": {
                                                                    "type": "int32",
                                                                    "id": 26
                                                                },
                                                                "lastPacketReceivedTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 27
                                                                },
                                                                "mimeType": {
                                                                    "type": "string",
                                                                    "id": 28
                                                                },
                                                                "nackCount": {
                                                                    "type": "int32",
                                                                    "id": 29
                                                                },
                                                                "packetsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 30
                                                                },
                                                                "packetsDuplicated": {
                                                                    "type": "int32",
                                                                    "id": 31
                                                                },
                                                                "packetsFailedDecryption": {
                                                                    "type": "int32",
                                                                    "id": 32
                                                                },
                                                                "packetsLost": {
                                                                    "type": "int32",
                                                                    "id": 33
                                                                },
                                                                "packetsReceived": {
                                                                    "type": "int32",
                                                                    "id": 34
                                                                },
                                                                "packetsRepaired": {
                                                                    "type": "int32",
                                                                    "id": 35
                                                                },
                                                                "packetsSent": {
                                                                    "type": "int32",
                                                                    "id": 36
                                                                },
                                                                "payloadType": {
                                                                    "type": "int32",
                                                                    "id": 37
                                                                },
                                                                "peerConnectionId": {
                                                                    "type": "string",
                                                                    "id": 38
                                                                },
                                                                "perDscpPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 39
                                                                },
                                                                "remoteClientId": {
                                                                    "type": "string",
                                                                    "id": 40
                                                                },
                                                                "remoteTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 41
                                                                },
                                                                "removedSamplesForAcceleration": {
                                                                    "type": "int32",
                                                                    "id": 42
                                                                },
                                                                "reportsSent": {
                                                                    "type": "int32",
                                                                    "id": 43
                                                                },
                                                                "roundTripTime": {
                                                                    "type": "double",
                                                                    "id": 44
                                                                },
                                                                "roundTripTimeMeasurements": {
                                                                    "type": "int32",
                                                                    "id": 45
                                                                },
                                                                "samplesDecodedWithCelt": {
                                                                    "type": "int32",
                                                                    "id": 46
                                                                },
                                                                "samplesDecodedWithSilk": {
                                                                    "type": "int32",
                                                                    "id": 47
                                                                },
                                                                "sdpFmtpLine": {
                                                                    "type": "string",
                                                                    "id": 48
                                                                },
                                                                "sfuSinkId": {
                                                                    "type": "string",
                                                                    "id": 49
                                                                },
                                                                "silentConcealedSamples": {
                                                                    "type": "int32",
                                                                    "id": 50
                                                                },
                                                                "totalProcessingDelay": {
                                                                    "type": "double",
                                                                    "id": 51
                                                                },
                                                                "totalRoundTripTime": {
                                                                    "type": "double",
                                                                    "id": 52
                                                                },
                                                                "totalSamplesDecoded": {
                                                                    "type": "int32",
                                                                    "id": 53
                                                                },
                                                                "totalSamplesReceived": {
                                                                    "type": "int32",
                                                                    "id": 54
                                                                },
                                                                "trackId": {
                                                                    "type": "string",
                                                                    "id": 55
                                                                },
                                                                "voiceActivityFlag": {
                                                                    "type": "bool",
                                                                    "id": 56
                                                                }
                                                            }
                                                        },
                                                        "InboundVideoTrack": {
                                                            "fields": {
                                                                "ssrc": {
                                                                    "type": "int64",
                                                                    "id": 1
                                                                },
                                                                "averageRtcpInterval": {
                                                                    "type": "double",
                                                                    "id": 2
                                                                },
                                                                "burstDiscardCount": {
                                                                    "type": "int32",
                                                                    "id": 3
                                                                },
                                                                "burstDiscardRate": {
                                                                    "type": "double",
                                                                    "id": 4
                                                                },
                                                                "burstLossCount": {
                                                                    "type": "int32",
                                                                    "id": 5
                                                                },
                                                                "burstLossRate": {
                                                                    "type": "double",
                                                                    "id": 6
                                                                },
                                                                "burstPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 7
                                                                },
                                                                "burstPacketsLost": {
                                                                    "type": "int32",
                                                                    "id": 8
                                                                },
                                                                "bytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 9
                                                                },
                                                                "bytesSent": {
                                                                    "type": "int64",
                                                                    "id": 10
                                                                },
                                                                "channels": {
                                                                    "type": "int32",
                                                                    "id": 11
                                                                },
                                                                "clockRate": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "decoderImplementation": {
                                                                    "type": "string",
                                                                    "id": 13
                                                                },
                                                                "ended": {
                                                                    "type": "bool",
                                                                    "id": 14
                                                                },
                                                                "estimatedPlayoutTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 15
                                                                },
                                                                "fecPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 16
                                                                },
                                                                "fecPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 17
                                                                },
                                                                "firCount": {
                                                                    "type": "int32",
                                                                    "id": 18
                                                                },
                                                                "frameBitDepth": {
                                                                    "type": "int32",
                                                                    "id": 19
                                                                },
                                                                "frameHeight": {
                                                                    "type": "int32",
                                                                    "id": 20
                                                                },
                                                                "frameWidth": {
                                                                    "type": "int32",
                                                                    "id": 21
                                                                },
                                                                "framesDecoded": {
                                                                    "type": "int32",
                                                                    "id": 22
                                                                },
                                                                "framesDropped": {
                                                                    "type": "int32",
                                                                    "id": 23
                                                                },
                                                                "framesPerSecond": {
                                                                    "type": "double",
                                                                    "id": 24
                                                                },
                                                                "framesReceived": {
                                                                    "type": "int32",
                                                                    "id": 25
                                                                },
                                                                "fullFramesLost": {
                                                                    "type": "int32",
                                                                    "id": 26
                                                                },
                                                                "gapDiscardRate": {
                                                                    "type": "double",
                                                                    "id": 27
                                                                },
                                                                "gapLossRate": {
                                                                    "type": "double",
                                                                    "id": 28
                                                                },
                                                                "headerBytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 29
                                                                },
                                                                "jitter": {
                                                                    "type": "double",
                                                                    "id": 30
                                                                },
                                                                "jitterBufferDelay": {
                                                                    "type": "double",
                                                                    "id": 31
                                                                },
                                                                "jitterBufferEmittedCount": {
                                                                    "type": "int32",
                                                                    "id": 32
                                                                },
                                                                "keyFramesDecoded": {
                                                                    "type": "int32",
                                                                    "id": 33
                                                                },
                                                                "lastPacketReceivedTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 34
                                                                },
                                                                "mimeType": {
                                                                    "type": "string",
                                                                    "id": 35
                                                                },
                                                                "nackCount": {
                                                                    "type": "int32",
                                                                    "id": 36
                                                                },
                                                                "packetsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 37
                                                                },
                                                                "packetsDuplicated": {
                                                                    "type": "int32",
                                                                    "id": 38
                                                                },
                                                                "packetsFailedDecryption": {
                                                                    "type": "int32",
                                                                    "id": 39
                                                                },
                                                                "packetsLost": {
                                                                    "type": "int32",
                                                                    "id": 40
                                                                },
                                                                "packetsReceived": {
                                                                    "type": "int32",
                                                                    "id": 41
                                                                },
                                                                "packetsRepaired": {
                                                                    "type": "int32",
                                                                    "id": 42
                                                                },
                                                                "packetsSent": {
                                                                    "type": "int32",
                                                                    "id": 43
                                                                },
                                                                "partialFramesLost": {
                                                                    "type": "int32",
                                                                    "id": 44
                                                                },
                                                                "payloadType": {
                                                                    "type": "int32",
                                                                    "id": 45
                                                                },
                                                                "peerConnectionId": {
                                                                    "type": "string",
                                                                    "id": 46
                                                                },
                                                                "perDscpPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 47
                                                                },
                                                                "pliCount": {
                                                                    "type": "int32",
                                                                    "id": 48
                                                                },
                                                                "qpSum": {
                                                                    "type": "int64",
                                                                    "id": 49
                                                                },
                                                                "remoteClientId": {
                                                                    "type": "string",
                                                                    "id": 50
                                                                },
                                                                "remoteTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 51
                                                                },
                                                                "reportsSent": {
                                                                    "type": "int32",
                                                                    "id": 52
                                                                },
                                                                "roundTripTime": {
                                                                    "type": "double",
                                                                    "id": 53
                                                                },
                                                                "roundTripTimeMeasurements": {
                                                                    "type": "int32",
                                                                    "id": 54
                                                                },
                                                                "sdpFmtpLine": {
                                                                    "type": "string",
                                                                    "id": 55
                                                                },
                                                                "sfuSinkId": {
                                                                    "type": "string",
                                                                    "id": 56
                                                                },
                                                                "sliCount": {
                                                                    "type": "int32",
                                                                    "id": 57
                                                                },
                                                                "totalDecodeTime": {
                                                                    "type": "double",
                                                                    "id": 58
                                                                },
                                                                "totalInterFrameDelay": {
                                                                    "type": "double",
                                                                    "id": 59
                                                                },
                                                                "totalProcessingDelay": {
                                                                    "type": "double",
                                                                    "id": 60
                                                                },
                                                                "totalRoundTripTime": {
                                                                    "type": "double",
                                                                    "id": 61
                                                                },
                                                                "totalSquaredInterFrameDelay": {
                                                                    "type": "double",
                                                                    "id": 62
                                                                },
                                                                "trackId": {
                                                                    "type": "string",
                                                                    "id": 63
                                                                }
                                                            }
                                                        },
                                                        "OutboundAudioTrack": {
                                                            "fields": {
                                                                "ssrc": {
                                                                    "type": "int64",
                                                                    "id": 1
                                                                },
                                                                "audioLevel": {
                                                                    "type": "double",
                                                                    "id": 2
                                                                },
                                                                "averageRtcpInterval": {
                                                                    "type": "double",
                                                                    "id": 3
                                                                },
                                                                "burstDiscardCount": {
                                                                    "type": "int32",
                                                                    "id": 4
                                                                },
                                                                "burstDiscardRate": {
                                                                    "type": "double",
                                                                    "id": 5
                                                                },
                                                                "burstLossCount": {
                                                                    "type": "int32",
                                                                    "id": 6
                                                                },
                                                                "burstLossRate": {
                                                                    "type": "double",
                                                                    "id": 7
                                                                },
                                                                "burstPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 8
                                                                },
                                                                "burstPacketsLost": {
                                                                    "type": "int32",
                                                                    "id": 9
                                                                },
                                                                "bytesDiscardedOnSend": {
                                                                    "type": "int64",
                                                                    "id": 10
                                                                },
                                                                "bytesSent": {
                                                                    "type": "int64",
                                                                    "id": 11
                                                                },
                                                                "channels": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "clockRate": {
                                                                    "type": "int32",
                                                                    "id": 13
                                                                },
                                                                "echoReturnLoss": {
                                                                    "type": "double",
                                                                    "id": 14
                                                                },
                                                                "echoReturnLossEnhancement": {
                                                                    "type": "double",
                                                                    "id": 15
                                                                },
                                                                "encoderImplementation": {
                                                                    "type": "string",
                                                                    "id": 16
                                                                },
                                                                "ended": {
                                                                    "type": "bool",
                                                                    "id": 17
                                                                },
                                                                "fecPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 18
                                                                },
                                                                "fractionLost": {
                                                                    "type": "double",
                                                                    "id": 19
                                                                },
                                                                "gapDiscardRate": {
                                                                    "type": "double",
                                                                    "id": 20
                                                                },
                                                                "gapLossRate": {
                                                                    "type": "double",
                                                                    "id": 21
                                                                },
                                                                "headerBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 22
                                                                },
                                                                "jitter": {
                                                                    "type": "double",
                                                                    "id": 23
                                                                },
                                                                "lastPacketSentTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 24
                                                                },
                                                                "mimeType": {
                                                                    "type": "string",
                                                                    "id": 25
                                                                },
                                                                "nackCount": {
                                                                    "type": "int32",
                                                                    "id": 26
                                                                },
                                                                "packetsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 27
                                                                },
                                                                "packetsDiscardedOnSend": {
                                                                    "type": "int32",
                                                                    "id": 28
                                                                },
                                                                "packetsLost": {
                                                                    "type": "int32",
                                                                    "id": 29
                                                                },
                                                                "packetsReceived": {
                                                                    "type": "int32",
                                                                    "id": 30
                                                                },
                                                                "packetsRepaired": {
                                                                    "type": "int32",
                                                                    "id": 31
                                                                },
                                                                "packetsSent": {
                                                                    "type": "int32",
                                                                    "id": 32
                                                                },
                                                                "payloadType": {
                                                                    "type": "int32",
                                                                    "id": 33
                                                                },
                                                                "peerConnectionId": {
                                                                    "type": "string",
                                                                    "id": 34
                                                                },
                                                                "perDscpPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 35
                                                                },
                                                                "relayedSource": {
                                                                    "type": "bool",
                                                                    "id": 36
                                                                },
                                                                "reportsReceived": {
                                                                    "type": "int32",
                                                                    "id": 37
                                                                },
                                                                "retransmittedBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 38
                                                                },
                                                                "retransmittedPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 39
                                                                },
                                                                "rid": {
                                                                    "type": "string",
                                                                    "id": 40
                                                                },
                                                                "roundTripTime": {
                                                                    "type": "double",
                                                                    "id": 41
                                                                },
                                                                "roundTripTimeMeasurements": {
                                                                    "type": "int32",
                                                                    "id": 42
                                                                },
                                                                "rtxSsrc": {
                                                                    "type": "int64",
                                                                    "id": 43
                                                                },
                                                                "samplesEncodedWithCelt": {
                                                                    "type": "int32",
                                                                    "id": 44
                                                                },
                                                                "samplesEncodedWithSilk": {
                                                                    "type": "int32",
                                                                    "id": 45
                                                                },
                                                                "sdpFmtpLine": {
                                                                    "type": "string",
                                                                    "id": 46
                                                                },
                                                                "sfuStreamId": {
                                                                    "type": "string",
                                                                    "id": 47
                                                                },
                                                                "targetBitrate": {
                                                                    "type": "int32",
                                                                    "id": 48
                                                                },
                                                                "totalAudioEnergy": {
                                                                    "type": "double",
                                                                    "id": 49
                                                                },
                                                                "totalEncodedBytesTarget": {
                                                                    "type": "int64",
                                                                    "id": 50
                                                                },
                                                                "totalPacketSendDelay": {
                                                                    "type": "double",
                                                                    "id": 51
                                                                },
                                                                "totalRoundTripTime": {
                                                                    "type": "double",
                                                                    "id": 52
                                                                },
                                                                "totalSamplesDuration": {
                                                                    "type": "double",
                                                                    "id": 53
                                                                },
                                                                "totalSamplesSent": {
                                                                    "type": "int32",
                                                                    "id": 54
                                                                },
                                                                "trackId": {
                                                                    "type": "string",
                                                                    "id": 55
                                                                },
                                                                "voiceActivityFlag": {
                                                                    "type": "bool",
                                                                    "id": 56
                                                                }
                                                            }
                                                        },
                                                        "OutboundVideoTrack": {
                                                            "fields": {
                                                                "ssrc": {
                                                                    "type": "int64",
                                                                    "id": 1
                                                                },
                                                                "averageRtcpInterval": {
                                                                    "type": "double",
                                                                    "id": 2
                                                                },
                                                                "bitDepth": {
                                                                    "type": "int32",
                                                                    "id": 3
                                                                },
                                                                "burstDiscardCount": {
                                                                    "type": "int32",
                                                                    "id": 4
                                                                },
                                                                "burstDiscardRate": {
                                                                    "type": "double",
                                                                    "id": 5
                                                                },
                                                                "burstLossCount": {
                                                                    "type": "int32",
                                                                    "id": 6
                                                                },
                                                                "burstLossRate": {
                                                                    "type": "double",
                                                                    "id": 7
                                                                },
                                                                "burstPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 8
                                                                },
                                                                "burstPacketsLost": {
                                                                    "type": "int32",
                                                                    "id": 9
                                                                },
                                                                "bytesDiscardedOnSend": {
                                                                    "type": "int64",
                                                                    "id": 10
                                                                },
                                                                "bytesSent": {
                                                                    "type": "int64",
                                                                    "id": 11
                                                                },
                                                                "channels": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "clockRate": {
                                                                    "type": "int32",
                                                                    "id": 13
                                                                },
                                                                "encoderImplementation": {
                                                                    "type": "string",
                                                                    "id": 14
                                                                },
                                                                "ended": {
                                                                    "type": "bool",
                                                                    "id": 15
                                                                },
                                                                "fecPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 16
                                                                },
                                                                "firCount": {
                                                                    "type": "int32",
                                                                    "id": 17
                                                                },
                                                                "fractionLost": {
                                                                    "type": "double",
                                                                    "id": 18
                                                                },
                                                                "frameBitDepth": {
                                                                    "type": "int32",
                                                                    "id": 19
                                                                },
                                                                "frameHeight": {
                                                                    "type": "int32",
                                                                    "id": 20
                                                                },
                                                                "frameWidth": {
                                                                    "type": "int32",
                                                                    "id": 21
                                                                },
                                                                "frames": {
                                                                    "type": "int32",
                                                                    "id": 22
                                                                },
                                                                "framesDiscardedOnSend": {
                                                                    "type": "int32",
                                                                    "id": 23
                                                                },
                                                                "framesDropped": {
                                                                    "type": "int32",
                                                                    "id": 24
                                                                },
                                                                "framesEncoded": {
                                                                    "type": "int32",
                                                                    "id": 25
                                                                },
                                                                "framesPerSecond": {
                                                                    "type": "double",
                                                                    "id": 26
                                                                },
                                                                "framesSent": {
                                                                    "type": "int32",
                                                                    "id": 27
                                                                },
                                                                "fullFramesLost": {
                                                                    "type": "int32",
                                                                    "id": 28
                                                                },
                                                                "gapDiscardRate": {
                                                                    "type": "double",
                                                                    "id": 29
                                                                },
                                                                "gapLossRate": {
                                                                    "type": "double",
                                                                    "id": 30
                                                                },
                                                                "headerBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 31
                                                                },
                                                                "height": {
                                                                    "type": "int32",
                                                                    "id": 32
                                                                },
                                                                "hugeFramesSent": {
                                                                    "type": "int32",
                                                                    "id": 33
                                                                },
                                                                "jitter": {
                                                                    "type": "double",
                                                                    "id": 34
                                                                },
                                                                "keyFramesEncoded": {
                                                                    "type": "int32",
                                                                    "id": 35
                                                                },
                                                                "lastPacketSentTimestamp": {
                                                                    "type": "int64",
                                                                    "id": 36
                                                                },
                                                                "mimeType": {
                                                                    "type": "string",
                                                                    "id": 37
                                                                },
                                                                "nackCount": {
                                                                    "type": "int32",
                                                                    "id": 38
                                                                },
                                                                "packetsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 39
                                                                },
                                                                "packetsDiscardedOnSend": {
                                                                    "type": "int32",
                                                                    "id": 40
                                                                },
                                                                "packetsLost": {
                                                                    "type": "int32",
                                                                    "id": 41
                                                                },
                                                                "packetsReceived": {
                                                                    "type": "int32",
                                                                    "id": 42
                                                                },
                                                                "packetsRepaired": {
                                                                    "type": "int32",
                                                                    "id": 43
                                                                },
                                                                "packetsSent": {
                                                                    "type": "int32",
                                                                    "id": 44
                                                                },
                                                                "partialFramesLost": {
                                                                    "type": "int32",
                                                                    "id": 45
                                                                },
                                                                "payloadType": {
                                                                    "type": "int32",
                                                                    "id": 46
                                                                },
                                                                "peerConnectionId": {
                                                                    "type": "string",
                                                                    "id": 47
                                                                },
                                                                "perDscpPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 48
                                                                },
                                                                "pliCount": {
                                                                    "type": "int32",
                                                                    "id": 49
                                                                },
                                                                "qpSum": {
                                                                    "type": "int64",
                                                                    "id": 50
                                                                },
                                                                "qualityLimitationDurationBandwidth": {
                                                                    "type": "double",
                                                                    "id": 51
                                                                },
                                                                "qualityLimitationDurationCPU": {
                                                                    "type": "double",
                                                                    "id": 52
                                                                },
                                                                "qualityLimitationDurationNone": {
                                                                    "type": "double",
                                                                    "id": 53
                                                                },
                                                                "qualityLimitationDurationOther": {
                                                                    "type": "double",
                                                                    "id": 54
                                                                },
                                                                "qualityLimitationReason": {
                                                                    "type": "string",
                                                                    "id": 55
                                                                },
                                                                "qualityLimitationResolutionChanges": {
                                                                    "type": "int32",
                                                                    "id": 56
                                                                },
                                                                "relayedSource": {
                                                                    "type": "bool",
                                                                    "id": 57
                                                                },
                                                                "reportsReceived": {
                                                                    "type": "int32",
                                                                    "id": 58
                                                                },
                                                                "retransmittedBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 59
                                                                },
                                                                "retransmittedPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 60
                                                                },
                                                                "rid": {
                                                                    "type": "string",
                                                                    "id": 61
                                                                },
                                                                "roundTripTime": {
                                                                    "type": "double",
                                                                    "id": 62
                                                                },
                                                                "roundTripTimeMeasurements": {
                                                                    "type": "int32",
                                                                    "id": 63
                                                                },
                                                                "rtxSsrc": {
                                                                    "type": "int64",
                                                                    "id": 64
                                                                },
                                                                "sdpFmtpLine": {
                                                                    "type": "string",
                                                                    "id": 65
                                                                },
                                                                "sfuStreamId": {
                                                                    "type": "string",
                                                                    "id": 66
                                                                },
                                                                "sliCount": {
                                                                    "type": "int32",
                                                                    "id": 67
                                                                },
                                                                "targetBitrate": {
                                                                    "type": "int32",
                                                                    "id": 68
                                                                },
                                                                "totalEncodeTime": {
                                                                    "type": "double",
                                                                    "id": 69
                                                                },
                                                                "totalEncodedBytesTarget": {
                                                                    "type": "int64",
                                                                    "id": 70
                                                                },
                                                                "totalPacketSendDelay": {
                                                                    "type": "double",
                                                                    "id": 71
                                                                },
                                                                "totalRoundTripTime": {
                                                                    "type": "double",
                                                                    "id": 72
                                                                },
                                                                "trackId": {
                                                                    "type": "string",
                                                                    "id": 73
                                                                },
                                                                "width": {
                                                                    "type": "int32",
                                                                    "id": 74
                                                                }
                                                            }
                                                        },
                                                        "IceLocalCandidate": {
                                                            "fields": {
                                                                "address": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "candidateType": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "id": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                },
                                                                "peerConnectionId": {
                                                                    "type": "string",
                                                                    "id": 4
                                                                },
                                                                "port": {
                                                                    "type": "int32",
                                                                    "id": 5
                                                                },
                                                                "priority": {
                                                                    "type": "int64",
                                                                    "id": 6
                                                                },
                                                                "protocol": {
                                                                    "type": "string",
                                                                    "id": 7
                                                                },
                                                                "relayProtocol": {
                                                                    "type": "string",
                                                                    "id": 8
                                                                },
                                                                "url": {
                                                                    "type": "string",
                                                                    "id": 9
                                                                }
                                                            }
                                                        },
                                                        "IceRemoteCandidate": {
                                                            "fields": {
                                                                "address": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "candidateType": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "id": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                },
                                                                "peerConnectionId": {
                                                                    "type": "string",
                                                                    "id": 4
                                                                },
                                                                "port": {
                                                                    "type": "int32",
                                                                    "id": 5
                                                                },
                                                                "priority": {
                                                                    "type": "int64",
                                                                    "id": 6
                                                                },
                                                                "protocol": {
                                                                    "type": "string",
                                                                    "id": 7
                                                                },
                                                                "relayProtocol": {
                                                                    "type": "string",
                                                                    "id": 8
                                                                },
                                                                "url": {
                                                                    "type": "string",
                                                                    "id": 9
                                                                }
                                                            }
                                                        },
                                                        "DataChannel": {
                                                            "fields": {
                                                                "address": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "bytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 2
                                                                },
                                                                "bytesSent": {
                                                                    "type": "int64",
                                                                    "id": 3
                                                                },
                                                                "dataChannelIdentifier": {
                                                                    "type": "int32",
                                                                    "id": 4
                                                                },
                                                                "id": {
                                                                    "type": "string",
                                                                    "id": 5
                                                                },
                                                                "label": {
                                                                    "type": "string",
                                                                    "id": 6
                                                                },
                                                                "messagesReceived": {
                                                                    "type": "int32",
                                                                    "id": 7
                                                                },
                                                                "messagesSent": {
                                                                    "type": "int32",
                                                                    "id": 8
                                                                },
                                                                "peerConnectionId": {
                                                                    "type": "string",
                                                                    "id": 9
                                                                },
                                                                "port": {
                                                                    "type": "int32",
                                                                    "id": 10
                                                                },
                                                                "protocol": {
                                                                    "type": "string",
                                                                    "id": 11
                                                                },
                                                                "state": {
                                                                    "type": "string",
                                                                    "id": 12
                                                                }
                                                            }
                                                        }
                                                    }
                                                },
                                                "SfuSample": {
                                                    "fields": {
                                                        "extensionStats": {
                                                            "rule": "repeated",
                                                            "type": "SfuExtensionStats",
                                                            "id": 1
                                                        },
                                                        "inboundRtpPads": {
                                                            "rule": "repeated",
                                                            "type": "SfuInboundRtpPad",
                                                            "id": 2
                                                        },
                                                        "outboundRtpPads": {
                                                            "rule": "repeated",
                                                            "type": "SfuOutboundRtpPad",
                                                            "id": 3
                                                        },
                                                        "sctpChannels": {
                                                            "rule": "repeated",
                                                            "type": "SfuSctpChannel",
                                                            "id": 4
                                                        },
                                                        "transports": {
                                                            "rule": "repeated",
                                                            "type": "SfuTransport",
                                                            "id": 5
                                                        },
                                                        "sfuId": {
                                                            "type": "string",
                                                            "id": 6
                                                        },
                                                        "timestamp": {
                                                            "type": "int64",
                                                            "id": 7
                                                        },
                                                        "marker": {
                                                            "type": "string",
                                                            "id": 8
                                                        },
                                                        "timeZoneOffsetInHours": {
                                                            "type": "int32",
                                                            "id": 9
                                                        }
                                                    },
                                                    "nested": {
                                                        "SfuTransport": {
                                                            "fields": {
                                                                "transportId": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "dtlsState": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "iceRole": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                },
                                                                "iceState": {
                                                                    "type": "string",
                                                                    "id": 4
                                                                },
                                                                "internal": {
                                                                    "type": "bool",
                                                                    "id": 5
                                                                },
                                                                "localAddress": {
                                                                    "type": "string",
                                                                    "id": 6
                                                                },
                                                                "localPort": {
                                                                    "type": "int32",
                                                                    "id": 7
                                                                },
                                                                "noReport": {
                                                                    "type": "bool",
                                                                    "id": 8
                                                                },
                                                                "protocol": {
                                                                    "type": "string",
                                                                    "id": 9
                                                                },
                                                                "remoteAddress": {
                                                                    "type": "string",
                                                                    "id": 10
                                                                },
                                                                "remotePort": {
                                                                    "type": "int32",
                                                                    "id": 11
                                                                },
                                                                "rtpBytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 12
                                                                },
                                                                "rtpBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 13
                                                                },
                                                                "rtpPacketsLost": {
                                                                    "type": "int32",
                                                                    "id": 14
                                                                },
                                                                "rtpPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 15
                                                                },
                                                                "rtpPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 16
                                                                },
                                                                "rtxBytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 17
                                                                },
                                                                "rtxBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 18
                                                                },
                                                                "rtxPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 19
                                                                },
                                                                "rtxPacketsLost": {
                                                                    "type": "int32",
                                                                    "id": 20
                                                                },
                                                                "rtxPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 21
                                                                },
                                                                "rtxPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 22
                                                                },
                                                                "sctpBytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 23
                                                                },
                                                                "sctpBytesSent": {
                                                                    "type": "int64",
                                                                    "id": 24
                                                                },
                                                                "sctpPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 25
                                                                },
                                                                "sctpPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 26
                                                                },
                                                                "sctpState": {
                                                                    "type": "string",
                                                                    "id": 27
                                                                }
                                                            }
                                                        },
                                                        "SfuInboundRtpPad": {
                                                            "fields": {
                                                                "padId": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "ssrc": {
                                                                    "type": "int64",
                                                                    "id": 2
                                                                },
                                                                "streamId": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                },
                                                                "transportId": {
                                                                    "type": "string",
                                                                    "id": 4
                                                                },
                                                                "bytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 5
                                                                },
                                                                "clockRate": {
                                                                    "type": "int32",
                                                                    "id": 6
                                                                },
                                                                "fecPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 7
                                                                },
                                                                "fecPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 8
                                                                },
                                                                "firCount": {
                                                                    "type": "int32",
                                                                    "id": 9
                                                                },
                                                                "fractionLost": {
                                                                    "type": "double",
                                                                    "id": 10
                                                                },
                                                                "framesDecoded": {
                                                                    "type": "int32",
                                                                    "id": 11
                                                                },
                                                                "framesReceived": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "internal": {
                                                                    "type": "bool",
                                                                    "id": 13
                                                                },
                                                                "jitter": {
                                                                    "type": "double",
                                                                    "id": 14
                                                                },
                                                                "keyFramesDecoded": {
                                                                    "type": "int32",
                                                                    "id": 15
                                                                },
                                                                "mediaType": {
                                                                    "type": "string",
                                                                    "id": 16
                                                                },
                                                                "mimeType": {
                                                                    "type": "string",
                                                                    "id": 17
                                                                },
                                                                "nackCount": {
                                                                    "type": "int32",
                                                                    "id": 18
                                                                },
                                                                "noReport": {
                                                                    "type": "bool",
                                                                    "id": 19
                                                                },
                                                                "packetsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 20
                                                                },
                                                                "packetsDuplicated": {
                                                                    "type": "int32",
                                                                    "id": 21
                                                                },
                                                                "packetsFailedDecryption": {
                                                                    "type": "int32",
                                                                    "id": 22
                                                                },
                                                                "packetsLost": {
                                                                    "type": "int32",
                                                                    "id": 23
                                                                },
                                                                "packetsReceived": {
                                                                    "type": "int32",
                                                                    "id": 24
                                                                },
                                                                "packetsRepaired": {
                                                                    "type": "int32",
                                                                    "id": 25
                                                                },
                                                                "payloadType": {
                                                                    "type": "int32",
                                                                    "id": 26
                                                                },
                                                                "pliCount": {
                                                                    "type": "int32",
                                                                    "id": 27
                                                                },
                                                                "rid": {
                                                                    "type": "string",
                                                                    "id": 28
                                                                },
                                                                "roundTripTime": {
                                                                    "type": "double",
                                                                    "id": 29
                                                                },
                                                                "rtcpRrSent": {
                                                                    "type": "int32",
                                                                    "id": 30
                                                                },
                                                                "rtcpSrReceived": {
                                                                    "type": "int32",
                                                                    "id": 31
                                                                },
                                                                "rtxPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 32
                                                                },
                                                                "rtxPacketsReceived": {
                                                                    "type": "int32",
                                                                    "id": 33
                                                                },
                                                                "rtxSsrc": {
                                                                    "type": "int64",
                                                                    "id": 34
                                                                },
                                                                "sdpFmtpLine": {
                                                                    "type": "string",
                                                                    "id": 35
                                                                },
                                                                "sliCount": {
                                                                    "type": "int32",
                                                                    "id": 36
                                                                },
                                                                "targetBitrate": {
                                                                    "type": "int32",
                                                                    "id": 37
                                                                },
                                                                "voiceActivityFlag": {
                                                                    "type": "bool",
                                                                    "id": 38
                                                                }
                                                            }
                                                        },
                                                        "SfuOutboundRtpPad": {
                                                            "fields": {
                                                                "padId": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "sinkId": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "ssrc": {
                                                                    "type": "int64",
                                                                    "id": 3
                                                                },
                                                                "streamId": {
                                                                    "type": "string",
                                                                    "id": 4
                                                                },
                                                                "transportId": {
                                                                    "type": "string",
                                                                    "id": 5
                                                                },
                                                                "bytesSent": {
                                                                    "type": "int64",
                                                                    "id": 6
                                                                },
                                                                "callId": {
                                                                    "type": "string",
                                                                    "id": 7
                                                                },
                                                                "clientId": {
                                                                    "type": "string",
                                                                    "id": 8
                                                                },
                                                                "clockRate": {
                                                                    "type": "int32",
                                                                    "id": 9
                                                                },
                                                                "fecPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 10
                                                                },
                                                                "fecPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 11
                                                                },
                                                                "firCount": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "fractionLost": {
                                                                    "type": "double",
                                                                    "id": 13
                                                                },
                                                                "framesEncoded": {
                                                                    "type": "int32",
                                                                    "id": 14
                                                                },
                                                                "framesSent": {
                                                                    "type": "int32",
                                                                    "id": 15
                                                                },
                                                                "internal": {
                                                                    "type": "bool",
                                                                    "id": 16
                                                                },
                                                                "jitter": {
                                                                    "type": "double",
                                                                    "id": 17
                                                                },
                                                                "keyFramesEncoded": {
                                                                    "type": "int32",
                                                                    "id": 18
                                                                },
                                                                "mediaType": {
                                                                    "type": "string",
                                                                    "id": 19
                                                                },
                                                                "mimeType": {
                                                                    "type": "string",
                                                                    "id": 20
                                                                },
                                                                "nackCount": {
                                                                    "type": "int32",
                                                                    "id": 21
                                                                },
                                                                "noReport": {
                                                                    "type": "bool",
                                                                    "id": 22
                                                                },
                                                                "packetsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 23
                                                                },
                                                                "packetsDuplicated": {
                                                                    "type": "int32",
                                                                    "id": 24
                                                                },
                                                                "packetsFailedEncryption": {
                                                                    "type": "int32",
                                                                    "id": 25
                                                                },
                                                                "packetsLost": {
                                                                    "type": "int32",
                                                                    "id": 26
                                                                },
                                                                "packetsRetransmitted": {
                                                                    "type": "int32",
                                                                    "id": 27
                                                                },
                                                                "packetsSent": {
                                                                    "type": "int32",
                                                                    "id": 28
                                                                },
                                                                "payloadType": {
                                                                    "type": "int32",
                                                                    "id": 29
                                                                },
                                                                "pliCount": {
                                                                    "type": "int32",
                                                                    "id": 30
                                                                },
                                                                "rid": {
                                                                    "type": "string",
                                                                    "id": 31
                                                                },
                                                                "roundTripTime": {
                                                                    "type": "double",
                                                                    "id": 32
                                                                },
                                                                "rtcpRrReceived": {
                                                                    "type": "int32",
                                                                    "id": 33
                                                                },
                                                                "rtcpSrSent": {
                                                                    "type": "int32",
                                                                    "id": 34
                                                                },
                                                                "rtxPacketsDiscarded": {
                                                                    "type": "int32",
                                                                    "id": 35
                                                                },
                                                                "rtxPacketsSent": {
                                                                    "type": "int32",
                                                                    "id": 36
                                                                },
                                                                "rtxSsrc": {
                                                                    "type": "int64",
                                                                    "id": 37
                                                                },
                                                                "sdpFmtpLine": {
                                                                    "type": "string",
                                                                    "id": 38
                                                                },
                                                                "sliCount": {
                                                                    "type": "int32",
                                                                    "id": 39
                                                                },
                                                                "targetBitrate": {
                                                                    "type": "int32",
                                                                    "id": 40
                                                                },
                                                                "trackId": {
                                                                    "type": "string",
                                                                    "id": 41
                                                                },
                                                                "voiceActivityFlag": {
                                                                    "type": "bool",
                                                                    "id": 42
                                                                }
                                                            }
                                                        },
                                                        "SfuSctpChannel": {
                                                            "fields": {
                                                                "channelId": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "streamId": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "transportId": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                },
                                                                "bytesReceived": {
                                                                    "type": "int64",
                                                                    "id": 4
                                                                },
                                                                "bytesSent": {
                                                                    "type": "int64",
                                                                    "id": 5
                                                                },
                                                                "label": {
                                                                    "type": "string",
                                                                    "id": 6
                                                                },
                                                                "messageReceived": {
                                                                    "type": "int32",
                                                                    "id": 7
                                                                },
                                                                "messageSent": {
                                                                    "type": "int32",
                                                                    "id": 8
                                                                },
                                                                "noReport": {
                                                                    "type": "bool",
                                                                    "id": 9
                                                                },
                                                                "protocol": {
                                                                    "type": "string",
                                                                    "id": 10
                                                                },
                                                                "sctpCongestionWindow": {
                                                                    "type": "double",
                                                                    "id": 11
                                                                },
                                                                "sctpMtu": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "sctpReceiverWindow": {
                                                                    "type": "double",
                                                                    "id": 13
                                                                },
                                                                "sctpSmoothedRoundTripTime": {
                                                                    "type": "double",
                                                                    "id": 14
                                                                },
                                                                "sctpUnackData": {
                                                                    "type": "int32",
                                                                    "id": 15
                                                                }
                                                            }
                                                        },
                                                        "SfuExtensionStats": {
                                                            "fields": {
                                                                "payload": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "type": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                }
                                                            }
                                                        }
                                                    }
                                                },
                                                "TurnSample": {
                                                    "fields": {
                                                        "allocations": {
                                                            "rule": "repeated",
                                                            "type": "TurnPeerAllocation",
                                                            "id": 1
                                                        },
                                                        "sessions": {
                                                            "rule": "repeated",
                                                            "type": "TurnSession",
                                                            "id": 2
                                                        },
                                                        "serverId": {
                                                            "type": "string",
                                                            "id": 3
                                                        }
                                                    },
                                                    "nested": {
                                                        "TurnPeerAllocation": {
                                                            "fields": {
                                                                "peerId": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "relayedAddress": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "relayedPort": {
                                                                    "type": "int32",
                                                                    "id": 3
                                                                },
                                                                "sessionId": {
                                                                    "type": "string",
                                                                    "id": 4
                                                                },
                                                                "transportProtocol": {
                                                                    "type": "string",
                                                                    "id": 5
                                                                },
                                                                "peerAddress": {
                                                                    "type": "string",
                                                                    "id": 6
                                                                },
                                                                "peerPort": {
                                                                    "type": "int32",
                                                                    "id": 7
                                                                },
                                                                "receivedBytes": {
                                                                    "type": "int64",
                                                                    "id": 8
                                                                },
                                                                "receivedPackets": {
                                                                    "type": "int32",
                                                                    "id": 9
                                                                },
                                                                "receivingBitrate": {
                                                                    "type": "int32",
                                                                    "id": 10
                                                                },
                                                                "sendingBitrate": {
                                                                    "type": "int32",
                                                                    "id": 11
                                                                },
                                                                "sentBytes": {
                                                                    "type": "int64",
                                                                    "id": 12
                                                                },
                                                                "sentPackets": {
                                                                    "type": "int32",
                                                                    "id": 13
                                                                }
                                                            }
                                                        },
                                                        "TurnSession": {
                                                            "fields": {
                                                                "sessionId": {
                                                                    "type": "string",
                                                                    "id": 1
                                                                },
                                                                "clientAddress": {
                                                                    "type": "string",
                                                                    "id": 2
                                                                },
                                                                "clientId": {
                                                                    "type": "string",
                                                                    "id": 3
                                                                },
                                                                "clientPort": {
                                                                    "type": "int32",
                                                                    "id": 4
                                                                },
                                                                "nonceExpirationTime": {
                                                                    "type": "int64",
                                                                    "id": 5
                                                                },
                                                                "realm": {
                                                                    "type": "string",
                                                                    "id": 6
                                                                },
                                                                "receivedBytes": {
                                                                    "type": "int64",
                                                                    "id": 7
                                                                },
                                                                "receivedPackets": {
                                                                    "type": "int32",
                                                                    "id": 8
                                                                },
                                                                "receivingBitrate": {
                                                                    "type": "int32",
                                                                    "id": 9
                                                                },
                                                                "sendingBitrate": {
                                                                    "type": "int32",
                                                                    "id": 10
                                                                },
                                                                "sentBytes": {
                                                                    "type": "int64",
                                                                    "id": 11
                                                                },
                                                                "sentPackets": {
                                                                    "type": "int32",
                                                                    "id": 12
                                                                },
                                                                "serverAddress": {
                                                                    "type": "string",
                                                                    "id": 13
                                                                },
                                                                "serverPort": {
                                                                    "type": "int32",
                                                                    "id": 14
                                                                },
                                                                "started": {
                                                                    "type": "int64",
                                                                    "id": 15
                                                                },
                                                                "transportProtocol": {
                                                                    "type": "string",
                                                                    "id": 16
                                                                },
                                                                "username": {
                                                                    "type": "string",
                                                                    "id": 17
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
};

},{}],74:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schema = void 0;
exports.schema = {
    "type": "record",
    "name": "Samples",
    "namespace": "org.observertc.schemas.samples",
    "doc": "Observer created reports related to events (call started, call ended, client joined, etc...) indicated by the incoming samples.",
    "fields": [
        {
            "name": "meta",
            "doc": "Additional meta information about the carried payloads",
            "type": [
                "null",
                {
                    "name": "SamplesMeta",
                    "type": "record",
                    "fields": [
                        {
                            "name": "schemaVersion",
                            "type": [
                                "null",
                                "string"
                            ],
                            "doc": "Indicate the version of the schema for compatibility measures.",
                            "default": null
                        }
                    ]
                }
            ],
            "default": null
        },
        {
            "name": "controlFlags",
            "doc": "Additional control flags indicate various operation has to be performed",
            "type": [
                "null",
                {
                    "name": "ControlFlags",
                    "type": "record",
                    "fields": [
                        {
                            "name": "close",
                            "doc": "Indicate that the server should close the connection",
                            "type": [
                                "null",
                                "boolean"
                            ],
                            "default": null
                        }
                    ]
                }
            ],
            "default": null
        },
        {
            "name": "clientSamples",
            "doc": "Samples taken from the client",
            "type": [
                "null",
                {
                    "type": "array",
                    "items": {
                        "name": "ClientSample",
                        "type": "record",
                        "doc": "docs",
                        "fields": [
                            {
                                "name": "callId",
                                "doc": "If it is provided the server uses the given id to match clients in the same call. Must be a valid UUID. ",
                                "type": [
                                    "null",
                                    "string"
                                ],
                                "default": null
                            },
                            {
                                "name": "clientId",
                                "doc": "Unique id of the client providing samples. Must be a valid UUID",
                                "type": "string"
                            },
                            {
                                "name": "sampleSeq",
                                "doc": "The sequence number a source assigns to the sample. Every time the source make a sample at a client this number should be monothonically incremented.",
                                "type": [
                                    "null",
                                    "int"
                                ],
                                "default": null
                            },
                            {
                                "name": "roomId",
                                "doc": "The WebRTC app configured room id the client joined for the call.",
                                "type": [
                                    "null",
                                    "string"
                                ],
                                "default": null
                            },
                            {
                                "name": "userId",
                                "doc": "The WebRTC app configured human readable user id the client is joined.",
                                "type": [
                                    "null",
                                    "string"
                                ],
                                "default": null
                            },
                            {
                                "name": "engine",
                                "doc": "WebRTC App provided information related to the engine the client uses.",
                                "type": [
                                    "null",
                                    {
                                        "name": "Engine",
                                        "type": "record",
                                        "fields": [
                                            {
                                                "name": "name",
                                                "type": [
                                                    "null",
                                                    "string"
                                                ],
                                                "doc": "The name of the Engine",
                                                "default": null
                                            },
                                            {
                                                "name": "version",
                                                "type": [
                                                    "null",
                                                    "string"
                                                ],
                                                "doc": "The version of the engine",
                                                "default": null
                                            }
                                        ]
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "platform",
                                "doc": "WebRTC App provided information related to the platform the client uses.",
                                "type": [
                                    "null",
                                    {
                                        "name": "Platform",
                                        "type": "record",
                                        "fields": [
                                            {
                                                "name": "type",
                                                "type": [
                                                    "null",
                                                    "string"
                                                ],
                                                "doc": "The name of the platform",
                                                "default": null
                                            },
                                            {
                                                "name": "vendor",
                                                "type": [
                                                    "null",
                                                    "string"
                                                ],
                                                "doc": "The name of the vendor",
                                                "default": null
                                            },
                                            {
                                                "name": "model",
                                                "type": [
                                                    "null",
                                                    "string"
                                                ],
                                                "doc": "The name of the model",
                                                "default": null
                                            }
                                        ]
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "browser",
                                "doc": "WebRTC App provided information related to the browser the client uses.",
                                "type": [
                                    "null",
                                    {
                                        "name": "Browser",
                                        "type": "record",
                                        "fields": [
                                            {
                                                "name": "name",
                                                "type": [
                                                    "null",
                                                    "string"
                                                ],
                                                "doc": "The name of the operation system (e.g.: linux) the webrtc app uses",
                                                "default": null
                                            },
                                            {
                                                "name": "version",
                                                "type": [
                                                    "null",
                                                    "string"
                                                ],
                                                "doc": "The version of the operation system",
                                                "default": null
                                            }
                                        ]
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "os",
                                "doc": "WebRTC App provided information related to the operation system the client uses.",
                                "type": [
                                    "null",
                                    {
                                        "name": "OperationSystem",
                                        "type": "record",
                                        "fields": [
                                            {
                                                "name": "name",
                                                "type": [
                                                    "null",
                                                    "string"
                                                ],
                                                "doc": "The name of the operation system (e.g.: linux) the webrtc app uses",
                                                "default": null
                                            },
                                            {
                                                "name": "version",
                                                "type": [
                                                    "null",
                                                    "string"
                                                ],
                                                "doc": "The version of the operation system",
                                                "default": null
                                            },
                                            {
                                                "name": "versionName",
                                                "type": [
                                                    "null",
                                                    "string"
                                                ],
                                                "doc": "The name of the version of the operation system",
                                                "default": null
                                            }
                                        ]
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "mediaConstraints",
                                "doc": "The WebRTC app provided List of the media constraints the client has.",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": "string"
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "mediaDevices",
                                "doc": "The WebRTC app provided List of the media devices the client has.",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "MediaDevice",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "id",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "doc": "the provided id of the media input / output",
                                                    "default": null
                                                },
                                                {
                                                    "name": "kind",
                                                    "doc": "The media kind of the media device",
                                                    "type": [
                                                        "null",
                                                        {
                                                            "type": "enum",
                                                            "name": "InputMediaDeviceKind",
                                                            "symbols": [
                                                                "videoinput",
                                                                "audioinput",
                                                                "audiooutput"
                                                            ]
                                                        }
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "label",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "doc": "The name of the device",
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "userMediaErrors",
                                "doc": "The WebRTC app provided List of user media errors the client has.",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": "string"
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "extensionStats",
                                "doc": "The WebRTC app provided custom stats payload",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "ExtensionStat",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "type",
                                                    "type": "string",
                                                    "doc": "The type of the extension stats the custom app provides"
                                                },
                                                {
                                                    "name": "payload",
                                                    "type": "string",
                                                    "doc": "The payload of the extension stats the custom app provides"
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "iceServers",
                                "doc": "The WebRTC app provided List of ICE server the client used.",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": "string"
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "localSDPs",
                                "doc": "The local part of the Signal Description Protocol to establish connections",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": "string"
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "pcTransports",
                                "doc": "Compound object related to Peer Connection Transport Stats",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "PeerConnectionTransport",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "peerConnectionId",
                                                    "doc": "The unique identifier of the peer connection",
                                                    "type": "string"
                                                },
                                                {
                                                    "name": "label",
                                                    "doc": "The webrtc app provided label the peer connection is marked with",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "dataChannelsOpened",
                                                    "doc": "Represents the number of unique RTCDataChannels that have entered the \"open\" state during their lifetime.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "dataChannelsClosed",
                                                    "doc": "Represents the number of unique RTCDataChannels that had the \"open\" state, but now they are \"closed\"",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "dataChannelsRequested",
                                                    "doc": "Represents the number of unique RTCDataChannels successfully requested from RTCPeerConnection.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "dataChannelsAccepted",
                                                    "doc": "Represents the number of unique RTCDataChannels signaled in a ondatachannel event on the RTCPeerConnection.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsSent",
                                                    "doc": "Represents the total number of packets sent on the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsReceived",
                                                    "doc": "Represents the total number of packets received on the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "bytesSent",
                                                    "doc": "Represents the total amount of bytes sent on the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "bytesReceived",
                                                    "doc": "Represents the total amount of bytes received on the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "iceRole",
                                                    "doc": "Represent the current role of ICE under DTLS Transport",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "iceLocalUsernameFragment",
                                                    "doc": "Represent the current local username fragment used in message validation procedures for ICE under DTLS Transport",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "dtlsState",
                                                    "doc": "Represents the current state of DTLS for the peer connection transport layer",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "iceState",
                                                    "doc": "Represents the current transport state (RTCIceTransportState) of ICE for the peer connection transport layer",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "tlsVersion",
                                                    "doc": "Represents the version number of the TLS used in the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "dtlsCipher",
                                                    "doc": "Represents the name of the DTLS cipher used in the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "srtpCipher",
                                                    "doc": "Represents the name of the SRTP cipher used in the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "tlsGroup",
                                                    "doc": "Represents the name of the IANA TLS Supported Groups used in the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "selectedCandidatePairChanges",
                                                    "doc": "The total number of candidate pair changes over the peer connection",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "localAddress",
                                                    "doc": "The address of the candidate (IPv4, IPv6, FQDN)",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "localPort",
                                                    "doc": "The locally used port to communicate with the remote peer",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "localProtocol",
                                                    "doc": "The protocol used by the local endpoint for the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "localCandidateType",
                                                    "doc": "The type of the ICE candidate used at the local endpoint on the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "localCandidateICEServerUrl",
                                                    "doc": "The url of the ICE server used by the local endpoint on the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "localCandidateRelayProtocol",
                                                    "doc": "The relay protocol of the ICE candidate used by the local endpoint on the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "remoteAddress",
                                                    "doc": "The address of the candidate (IPv4, IPv6, FQDN)",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "remotePort",
                                                    "doc": "The remotely used port to communicate with the remote peer",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "remoteProtocol",
                                                    "doc": "The protocol used by the remote endpoint for the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "remoteCandidateType",
                                                    "doc": "The type of the ICE candidate used at the remote endpoint on the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "remoteCandidateICEServerUrl",
                                                    "doc": "The url of the ICE server used by the remote endpoint on the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "remoteCandidateRelayProtocol",
                                                    "doc": "The relay protocol of the ICE candidate used by the remote endpoint on the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairState",
                                                    "doc": "The state of ICE Candidate Pairs (RTCStatsIceCandidatePairState) on the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairPacketsSent",
                                                    "doc": "The total number of packets sent using the last selected candidate pair over the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairPacketsReceived",
                                                    "doc": "The total number of packets received using the last selected candidate pair over the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairBytesSent",
                                                    "doc": "The total number of bytes sent using the last selected candidate pair over the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairBytesReceived",
                                                    "doc": "The total number of bytes received using the last selected candidate pair over the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairLastPacketSentTimestamp",
                                                    "doc": "Represents the timestamp at which the last packet was sent on the selected candidate pair, excluding STUN packets over the corresponded transport (UTC Epoch in ms)",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairLastPacketReceivedTimestamp",
                                                    "doc": "Represents the timestamp at which the last packet was received on the selected candidate pair, excluding STUN packets over the corresponded transport (UTC Epoch in ms)",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairFirstRequestTimestamp",
                                                    "doc": "Represents the timestamp at which the first STUN request was sent on this particular candidate pair over the corresponded transport (UTC Epoch in ms)",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairLastRequestTimestamp",
                                                    "doc": "Represents the timestamp at which the last STUN request was sent on this particular candidate pair over the corresponded transport (UTC Epoch in ms)",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairLastResponseTimestamp",
                                                    "doc": "Represents the timestamp at which the last STUN response was received on this particular candidate pair over the corresponded transport (UTC Epoch in ms)",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairTotalRoundTripTime",
                                                    "doc": "Represents the sum of all round trip time measurements in seconds since the beginning of the session, based on STUN connectivity check over the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairCurrentRoundTripTime",
                                                    "doc": "Represents the last round trip time measurements in seconds based on STUN connectivity check over the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairAvailableOutgoingBitrate",
                                                    "doc": "The sum of the underlying cc algorithm provided outgoing bitrate for the RTP streams over the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairAvailableIncomingBitrate",
                                                    "doc": "The sum of the underlying cc algorithm provided incoming bitrate for the RTP streams over the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairCircuitBreakerTriggerCount",
                                                    "doc": "The total number of circuit breaker triggered over the corresponded transport using the selected candidate pair",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairRequestsReceived",
                                                    "doc": "Represents the total number of connectivity check requests received on the selected candidate pair using the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairRequestsSent",
                                                    "doc": "Represents the total number of connectivity check requests sent on the selected candidate pair using the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairResponsesReceived",
                                                    "doc": "Represents the total number of connectivity check responses received on the selected candidate pair using the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairResponsesSent",
                                                    "doc": "Represents the total number of connectivity check responses sent on the selected candidate pair using the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairRetransmissionReceived",
                                                    "doc": "Represents the total number of connectivity check retransmission received on the selected candidate pair using the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairRetransmissionSent",
                                                    "doc": "Represents the total number of connectivity check retransmission sent on the selected candidate pair using the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairConsentRequestsSent",
                                                    "doc": "Represents the total number of consent requests sent on the selected candidate pair using the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairConsentExpiredTimestamp",
                                                    "doc": "Represents the timestamp at which the latest valid STUN binding response expired on the selected candidate pair using the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairBytesDiscardedOnSend",
                                                    "doc": "Total amount of bytes for this candidate pair that have been discarded due to socket errors on the selected candidate pair using the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairPacketsDiscardedOnSend",
                                                    "doc": "Total amount of packets for this candidate pair that have been discarded due to socket errors on the selected candidate pair using the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairRequestBytesSent",
                                                    "doc": "Total number of bytes sent for connectivity checks on the selected candidate pair using the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairConsentRequestBytesSent",
                                                    "doc": "Total number of bytes sent for consent requests on the selected candidate pair using the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidatePairResponseBytesSent",
                                                    "doc": "Total number of bytes sent for connectivity check responses on the selected candidate pair using the corresponded transport",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sctpSmoothedRoundTripTime",
                                                    "doc": "The latest smoothed round-trip time value, corresponding to spinfo_srtt defined in [RFC6458] but converted to seconds. ",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sctpCongestionWindow",
                                                    "doc": "The latest congestion window, corresponding to spinfo_cwnd.",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sctpReceiverWindow",
                                                    "doc": "The latest receiver window, corresponding to sstat_rwnd.",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sctpMtu",
                                                    "doc": "The latest maximum transmission unit, corresponding to spinfo_mtu.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sctpUnackData",
                                                    "doc": "The number of unacknowledged DATA chunks, corresponding to sstat_unackdata.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "mediaSources",
                                "doc": "WebRTC App provided information related to the operation system the client uses.",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "MediaSourceStat",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "trackIdentifier",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "doc": "The unique identifier of the corresponded media track",
                                                    "default": null
                                                },
                                                {
                                                    "name": "kind",
                                                    "type": [
                                                        "null",
                                                        {
                                                            "type": "enum",
                                                            "name": "MediaSourceMediaKind",
                                                            "symbols": [
                                                                "audio",
                                                                "video"
                                                            ]
                                                        }
                                                    ],
                                                    "doc": "The type of the media the Mediasource produces.",
                                                    "default": null
                                                },
                                                {
                                                    "name": "relayedSource",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "doc": "Flag indicating if the media source is relayed or not, meaning the local endpoint is not the actual source of the media, but a proxy for that media.",
                                                    "default": null
                                                },
                                                {
                                                    "name": "audioLevel",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "doc": "The value is between 0..1 (linear), where 1.0 represents 0 dBov, 0 represents silence, and 0.5 represents approximately 6 dBSPL change in the sound pressure level from 0 dBov.",
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalAudioEnergy",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "doc": "The audio energy of the media source. For calculation see www.w3.org/TR/webrtc-stats/#dom-rtcaudiosourcestats-totalaudioenergy",
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalSamplesDuration",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "doc": "The duration of the audio type media source",
                                                    "default": null
                                                },
                                                {
                                                    "name": "echoReturnLoss",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "doc": "if echo cancellation is applied on the media source, then this number represents the loss calculation defined in www.itu.int/rec/T-REC-G.168-201504-I/en",
                                                    "default": null
                                                },
                                                {
                                                    "name": "echoReturnLossEnhancement",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "doc": "www.itu.int/rec/T-REC-G.168-201504-I/en",
                                                    "default": null
                                                },
                                                {
                                                    "name": "width",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "doc": "The width, in pixels, of the last frame originating from the media source",
                                                    "default": null
                                                },
                                                {
                                                    "name": "height",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "doc": "The height, in pixels, of the last frame originating from the media source",
                                                    "default": null
                                                },
                                                {
                                                    "name": "bitDepth",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "doc": "The bitDepth, in pixels, of the last frame originating from the media source",
                                                    "default": null
                                                },
                                                {
                                                    "name": "frames",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "doc": "The total number of frames originated from the media source",
                                                    "default": null
                                                },
                                                {
                                                    "name": "framesPerSecond",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "doc": " The number of frames origianted from the media source in the last second",
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "codecs",
                                "doc": "List of codec the client has",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "MediaCodecStats",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "payloadType",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "doc": "Payload type used in RTP encoding / decoding process.",
                                                    "default": null
                                                },
                                                {
                                                    "name": "codecType",
                                                    "type": [
                                                        "null",
                                                        {
                                                            "type": "enum",
                                                            "name": "CodecType",
                                                            "symbols": [
                                                                "encode",
                                                                "decode"
                                                            ]
                                                        }
                                                    ],
                                                    "doc": "Indicates the role of the codec (encode or decode)",
                                                    "default": null
                                                },
                                                {
                                                    "name": "mimeType",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "doc": "The MIME type of the media. eg.: audio/opus.",
                                                    "default": null
                                                },
                                                {
                                                    "name": "clockRate",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "doc": "the clock rate used in RTP transport to generate the timestamp for the carried frames",
                                                    "default": null
                                                },
                                                {
                                                    "name": "channels",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "doc": "Audio Only. Represnts the number of chanels an audio media source have. Only interesting if stereo is presented",
                                                    "default": null
                                                },
                                                {
                                                    "name": "sdpFmtpLine",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "doc": "The SDP line determines the codec",
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "certificates",
                                "doc": "List of certificates the client provided",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "Certificate",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "fingerprint",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "doc": " The fingerprint of the certificate.",
                                                    "default": null
                                                },
                                                {
                                                    "name": "fingerprintAlgorithm",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "doc": "The hash function used to generate the fingerprint.",
                                                    "default": null
                                                },
                                                {
                                                    "name": "base64Certificate",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "doc": "The DER encoded base-64 representation of the certificate.",
                                                    "default": null
                                                },
                                                {
                                                    "name": "issuerCertificateId",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "doc": "The id of the next certificate in the certificate chain",
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "inboundAudioTracks",
                                "doc": "List of compound measurements related to inbound audio tracks",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "InboundAudioTrack",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "trackId",
                                                    "doc": "The id of the track",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "peerConnectionId",
                                                    "doc": " The unique generated identifier of the peer connection the inbound audio track belongs to",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "remoteClientId",
                                                    "doc": "The remote clientId the source outbound track belongs to",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sfuSinkId",
                                                    "doc": "The id of the sink this track belongs to in the SFU",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "ssrc",
                                                    "doc": "The RTP SSRC field",
                                                    "type": "long"
                                                },
                                                {
                                                    "name": "packetsReceived",
                                                    "doc": "The total number of packets received on the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsLost",
                                                    "doc": "The total number of bytes received on the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "jitter",
                                                    "doc": "The corresponded synchronization source reported jitter",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsDiscarded",
                                                    "doc": "The total number of packets missed the playout point and therefore discarded by the jitterbuffer",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsRepaired",
                                                    "doc": "The total number of packets repaired by either FEC or due to retransmission on the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstPacketsLost",
                                                    "doc": "The total number of packets lost in burst (RFC6958)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstPacketsDiscarded",
                                                    "doc": "The total number of packets discarded in burst (RFC6958)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstLossCount",
                                                    "doc": "The total number of burst happened causes burstPacketsLost on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstDiscardCount",
                                                    "doc": "The total number of burst happened causes burstPacketsDiscarded on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstLossRate",
                                                    "doc": "The fraction of RTP packets lost during bursts proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstDiscardRate",
                                                    "doc": "The fraction of RTP packets discarded during bursts proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "gapLossRate",
                                                    "doc": "The fraction of RTP packets lost during gap proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "gapDiscardRate",
                                                    "doc": "The fraction of RTP packets discarded during gap proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "lastPacketReceivedTimestamp",
                                                    "doc": "Represents the timestamp at which the last packet was received on the corresponded synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "averageRtcpInterval",
                                                    "doc": "The average RTCP interval between two consecutive compound RTCP packets sent for the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "headerBytesReceived",
                                                    "doc": "Total number of RTP header and padding bytes received over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "fecPacketsReceived",
                                                    "doc": "Total number of FEC packets received over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "fecPacketsDiscarded",
                                                    "doc": "Total number of FEC packets discarded over the corresponding synchronization source (ssrc) due to 1) late arrive; 2) the target RTP packet has already been repaired.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "bytesReceived",
                                                    "doc": "Total number of bytes received over the corresponding synchronization source (ssrc) due to 1) late arrive; 2) the target RTP packet has already been repaired.",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsFailedDecryption",
                                                    "doc": "Total number of packets received and failed to decrypt over the corresponding synchronization source (ssrc) due to 1) late arrive; 2) the target RTP packet has already been repaired.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsDuplicated",
                                                    "doc": "Total number of packets identified as duplicated over the corresponding synchronization source (ssrc).",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "perDscpPacketsReceived",
                                                    "doc": "The total number of DSCP flagged RTP packets received over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "nackCount",
                                                    "doc": "Count the total number of Negative ACKnowledgement (NACK) packets sent and belongs to the corresponded synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalProcessingDelay",
                                                    "doc": "The total processing delay in seconds spend on buffering RTP packets from received up until packets are decoded",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "estimatedPlayoutTimestamp",
                                                    "doc": "The estimated playout time of the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "jitterBufferDelay",
                                                    "doc": "The total time of RTP packets spent in jitterbuffer waiting for frame completion due to network uncertenity.",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "jitterBufferEmittedCount",
                                                    "doc": "The total number of audio samples or video frames that have come out of the jitter buffer on the corresponded synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "decoderImplementation",
                                                    "doc": "Indicate the name of the decoder implementation library",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "voiceActivityFlag",
                                                    "doc": "Indicate if the last RTP packet received contained voice activity based on the presence of the V bit in the extension header",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalSamplesReceived",
                                                    "doc": "The total number of audio samples received on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalSamplesDecoded",
                                                    "doc": "The total number of samples decoded on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "samplesDecodedWithSilk",
                                                    "doc": "The total number of samples decoded with SILK on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "samplesDecodedWithCelt",
                                                    "doc": "The total number of samples decodedd with CELT on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "concealedSamples",
                                                    "doc": "The total number of samples decoded by the media decoder from the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "silentConcealedSamples",
                                                    "doc": "The total number of samples concealed from the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "concealmentEvents",
                                                    "doc": "The total number of concealed event emitted to the media codec by the corresponded jitterbuffer",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "insertedSamplesForDeceleration",
                                                    "doc": "The total number of samples inserted to decelarete the audio playout (happens when the jitterbuffer detects a shrinking buffer and need to increase the jitter buffer delay)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "removedSamplesForAcceleration",
                                                    "doc": "The total number of samples inserted to accelerate the audio playout (happens when the jitterbuffer detects a growing buffer and need to shrink the jitter buffer delay)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsSent",
                                                    "doc": "Total number of RTP packets sent at the remote endpoint to this endpoint on this synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "bytesSent",
                                                    "doc": "Total number of payload bytes sent at the remote endpoint to this endpoint on this synchronization source",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "remoteTimestamp",
                                                    "doc": "The timestamp corresnponds to the time in UTC Epoch the remote endpoint reported the statistics belong to the sender side and correspond to the synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "reportsSent",
                                                    "doc": "The number of SR reports the remote endpoint sent corresponded to synchronization source (ssrc) this report belongs to",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "roundTripTime",
                                                    "doc": "Estimated round trip time for the SR reports based on DLRR reports on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalRoundTripTime",
                                                    "doc": " Represents the cumulative sum of all round trip time measurements performed on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "roundTripTimeMeasurements",
                                                    "doc": "Represents the total number of SR reports received with DLRR reports to be able to calculate the round trip time on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "ended",
                                                    "doc": "Flag represents if the receiver ended the media stream track or not.",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "payloadType",
                                                    "doc": "The type of the payload the RTP packet SSRC belongs to",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "mimeType",
                                                    "doc": "the MIME type of the codec (e.g.: video/vp8)",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "clockRate",
                                                    "doc": "The negotiated clock rate the RTP timestamp is generated of",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "channels",
                                                    "doc": "The number of channels for audio is used (in stereo it is 2, otherwise it is most likely null)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sdpFmtpLine",
                                                    "doc": "The a=fmtp line in the SDP corresponding to the codec",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "inboundVideoTracks",
                                "doc": "List of compound measurements related to inbound video tracks",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "InboundVideoTrack",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "trackId",
                                                    "doc": "The id of the track",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "peerConnectionId",
                                                    "doc": " The unique generated identifier of the peer connection the inbound audio track belongs to",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "remoteClientId",
                                                    "doc": "The remote clientId the source outbound track belongs to",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sfuSinkId",
                                                    "doc": "The id of the sink this track belongs to in the SFU",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "ssrc",
                                                    "doc": "The RTP SSRC field",
                                                    "type": "long"
                                                },
                                                {
                                                    "name": "packetsReceived",
                                                    "doc": "The total number of packets received on the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsLost",
                                                    "doc": "The total number of bytes received on the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "jitter",
                                                    "doc": "The corresponded synchronization source reported jitter",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsDiscarded",
                                                    "doc": "The total number of packets missed the playout point and therefore discarded by the jitterbuffer",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsRepaired",
                                                    "doc": "The total number of packets repaired by either FEC or due to retransmission on the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstPacketsLost",
                                                    "doc": "The total number of packets lost in burst (RFC6958)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstPacketsDiscarded",
                                                    "doc": "The total number of packets discarded in burst (RFC6958)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstLossCount",
                                                    "doc": "The total number of burst happened causes burstPacketsLost on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstDiscardCount",
                                                    "doc": "The total number of burst happened causes burstPacketsDiscarded on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstLossRate",
                                                    "doc": "The fraction of RTP packets lost during bursts proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstDiscardRate",
                                                    "doc": "The fraction of RTP packets discarded during bursts proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "gapLossRate",
                                                    "doc": "The fraction of RTP packets lost during gap proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "gapDiscardRate",
                                                    "doc": "The fraction of RTP packets discarded during gap proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "lastPacketReceivedTimestamp",
                                                    "doc": "Represents the timestamp at which the last packet was received on the corresponded synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "averageRtcpInterval",
                                                    "doc": "The average RTCP interval between two consecutive compound RTCP packets sent for the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "headerBytesReceived",
                                                    "doc": "Total number of RTP header and padding bytes received over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "fecPacketsReceived",
                                                    "doc": "Total number of FEC packets received over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "fecPacketsDiscarded",
                                                    "doc": "Total number of FEC packets discarded over the corresponding synchronization source (ssrc) due to 1) late arrive; 2) the target RTP packet has already been repaired.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "bytesReceived",
                                                    "doc": "Total number of bytes received over the corresponding synchronization source (ssrc) due to 1) late arrive; 2) the target RTP packet has already been repaired.",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsFailedDecryption",
                                                    "doc": "Total number of packets received and failed to decrypt over the corresponding synchronization source (ssrc) due to 1) late arrive; 2) the target RTP packet has already been repaired.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsDuplicated",
                                                    "doc": "Total number of packets identified as duplicated over the corresponding synchronization source (ssrc).",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "perDscpPacketsReceived",
                                                    "doc": "The total number of DSCP flagged RTP packets received over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "nackCount",
                                                    "doc": "Count the total number of Negative ACKnowledgement (NACK) packets sent and belongs to the corresponded synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalProcessingDelay",
                                                    "doc": "The total processing delay in seconds spend on buffering RTP packets from received up until packets are decoded",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "estimatedPlayoutTimestamp",
                                                    "doc": "The estimated playout time of the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "jitterBufferDelay",
                                                    "doc": "The total time of RTP packets spent in jitterbuffer waiting for frame completion due to network uncertenity.",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "jitterBufferEmittedCount",
                                                    "doc": "The total number of audio samples or video frames that have come out of the jitter buffer on the corresponded synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "decoderImplementation",
                                                    "doc": "Indicate the name of the decoder implementation library",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "framesDropped",
                                                    "doc": "The total number of frames dropped on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "framesDecoded",
                                                    "doc": "The total number of frames decoded on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "partialFramesLost",
                                                    "doc": "The total number of frames partially lost on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "fullFramesLost",
                                                    "doc": "The total number of frames fully lost on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "keyFramesDecoded",
                                                    "doc": "The total number of keyframes decoded on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "frameWidth",
                                                    "doc": "The width of the frame of the video sent by the remote source on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "frameHeight",
                                                    "doc": "The height of the frame of the video sent by the remote source on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "frameBitDepth",
                                                    "doc": "The bit depth in pixels of the frame of the video sent by the remote source on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "framesPerSecond",
                                                    "doc": "The frame per seconds of the video sent by the remote source on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "qpSum",
                                                    "doc": "The QP sum (only interested in VP8,9) of the frame of the video sent by the remote source on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalDecodeTime",
                                                    "doc": "The total tiem spent on decoding video on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalInterFrameDelay",
                                                    "doc": "The total interframe delay",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalSquaredInterFrameDelay",
                                                    "doc": "The total number of inter frame delay squere on the corresponded synchronization source (ssrc) Useful for variance calculation for interframe delays",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "firCount",
                                                    "doc": "The total number FIR packets sent from this endpoint to the source on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "pliCount",
                                                    "doc": "The total number of Picture Loss Indication sent on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sliCount",
                                                    "doc": "The total number of SLI indicator sent from the endpoint on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "framesReceived",
                                                    "doc": "The total number of frames received on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsSent",
                                                    "doc": "Total number of RTP packets sent at the remote endpoint to this endpoint on this synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "bytesSent",
                                                    "doc": "Total number of payload bytes sent at the remote endpoint to this endpoint on this synchronization source",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "remoteTimestamp",
                                                    "doc": "The timestamp corresnponds to the time in UTC Epoch the remote endpoint reported the statistics belong to the sender side and correspond to the synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "reportsSent",
                                                    "doc": "The number of SR reports the remote endpoint sent corresponded to synchronization source (ssrc) this report belongs to",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "roundTripTime",
                                                    "doc": "Estimated round trip time for the SR reports based on DLRR reports on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalRoundTripTime",
                                                    "doc": " Represents the cumulative sum of all round trip time measurements performed on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "roundTripTimeMeasurements",
                                                    "doc": "Represents the total number of SR reports received with DLRR reports to be able to calculate the round trip time on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "ended",
                                                    "doc": "Flag represents if the receiver ended the media stream track or not.",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "payloadType",
                                                    "doc": "The type of the payload the RTP packet SSRC belongs to",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "mimeType",
                                                    "doc": "the MIME type of the codec (e.g.: video/vp8)",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "clockRate",
                                                    "doc": "The negotiated clock rate the RTP timestamp is generated of",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "channels",
                                                    "doc": "The number of channels for audio is used (in stereo it is 2, otherwise it is most likely null)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sdpFmtpLine",
                                                    "doc": "The a=fmtp line in the SDP corresponding to the codec",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "outboundAudioTracks",
                                "doc": "List of compound measurements related to outbound audio tracks",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "OutboundAudioTrack",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "trackId",
                                                    "doc": "The id of the track",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "peerConnectionId",
                                                    "doc": " The unique generated identifier of the peer connection the inbound audio track belongs to",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sfuStreamId",
                                                    "doc": "The id of the SFU stream this track is related to",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "ssrc",
                                                    "doc": "The RTP SSRC field",
                                                    "type": "long"
                                                },
                                                {
                                                    "name": "packetsSent",
                                                    "doc": "The total number of packets sent on the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "bytesSent",
                                                    "doc": "The total number of bytes sent on the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtxSsrc",
                                                    "doc": "If RTX is negotiated as a separate stream, this is the SSRC of the RTX stream that is associated with this stream's ssrc. ",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rid",
                                                    "doc": " The rid encoding parameter of the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "lastPacketSentTimestamp",
                                                    "doc": " the timestamp the last packet was sent. (UTC epoch in ms)",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "headerBytesSent",
                                                    "doc": "Total number of RTP header and padding bytes sent over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsDiscardedOnSend",
                                                    "doc": "Total number of RTP packets discarded at sender side over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "bytesDiscardedOnSend",
                                                    "doc": "Total number of RTP bytes discarded at sender side over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "fecPacketsSent",
                                                    "doc": "Total number of FEC packets sent over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "retransmittedPacketsSent",
                                                    "doc": "Total number of retransmitted packets sent over the corresponding synchronization source (ssrc).",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "retransmittedBytesSent",
                                                    "doc": "Total number of retransmitted bytes sent over the corresponding synchronization source (ssrc).",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "targetBitrate",
                                                    "doc": "Reflects the current encoder target in bits per second.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalEncodedBytesTarget",
                                                    "doc": "The total number of bytes of RTP coherent frames encoded completly depending on the frame size the encoder targets",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalPacketSendDelay",
                                                    "doc": "The total number of delay packets buffered at the sender side in seconds over the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "averageRtcpInterval",
                                                    "doc": "The average RTCP interval between two consecutive compound RTCP packets sent for the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "perDscpPacketsSent",
                                                    "doc": "The total number of DSCP flagged RTP packets sent over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "nackCount",
                                                    "doc": "Count the total number of Negative ACKnowledgement (NACK) packets received over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "encoderImplementation",
                                                    "doc": "Indicate the name of the encoder implementation library",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalSamplesSent",
                                                    "doc": "The total number of samples sent over the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "samplesEncodedWithSilk",
                                                    "doc": "The total number of samples encoded by SILK portion in opus sent over the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "samplesEncodedWithCelt",
                                                    "doc": "The total number of samples encoded by CELT portion in opus sent over the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "voiceActivityFlag",
                                                    "doc": "Indicate if the last RTP packet sent contained voice activity based on the presence of the V bit in the extension header",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsReceived",
                                                    "doc": "The total number of packets received on the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsLost",
                                                    "doc": "The total number of bytes received on the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "jitter",
                                                    "doc": "The corresponded synchronization source reported jitter",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsDiscarded",
                                                    "doc": "The total number of packets missed the playout point and therefore discarded by the jitterbuffer",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsRepaired",
                                                    "doc": "The total number of packets repaired by either FEC or due to retransmission on the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstPacketsLost",
                                                    "doc": "The total number of packets lost in burst (RFC6958)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstPacketsDiscarded",
                                                    "doc": "The total number of packets discarded in burst (RFC6958)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstLossCount",
                                                    "doc": "The total number of burst happened causes burstPacketsLost on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstDiscardCount",
                                                    "doc": "The total number of burst happened causes burstPacketsDiscarded on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstLossRate",
                                                    "doc": "The fraction of RTP packets lost during bursts proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstDiscardRate",
                                                    "doc": "The fraction of RTP packets discarded during bursts proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "gapLossRate",
                                                    "doc": "The fraction of RTP packets lost during gap proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "gapDiscardRate",
                                                    "doc": "The fraction of RTP packets discarded during gap proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "roundTripTime",
                                                    "doc": "RTT measurement in seconds based on (most likely) SR, and RR belongs to the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalRoundTripTime",
                                                    "doc": "The sum of RTT measurements belongs to the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "fractionLost",
                                                    "doc": "The receiver reported fractional lost belongs to the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "reportsReceived",
                                                    "doc": "The total number of RR reports received, which is the base of the remote inbound calculation on this source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "roundTripTimeMeasurements",
                                                    "doc": "The total number of calculated RR measurements received on this source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "relayedSource",
                                                    "doc": "True if the corresponded media source is remote, false otherwise (or null depending on browser and version)",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "audioLevel",
                                                    "doc": "Represents the audio level reported by the media source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalAudioEnergy",
                                                    "doc": "Represents the energy level reported by the media source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalSamplesDuration",
                                                    "doc": "Represents the total duration of the audio samples the media source actually transconverted in seconds",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "echoReturnLoss",
                                                    "doc": "Represents the echo cancellation in decibels corresponded to the media source.",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "echoReturnLossEnhancement",
                                                    "doc": "Represents the echo cancellation in decibels added as a postprocessing by the library after the audio is catched from the emdia source.",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "ended",
                                                    "doc": "Flag represents if the sender ended the media stream track or not.",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "payloadType",
                                                    "doc": "The type of the payload the RTP packet SSRC belongs to",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "mimeType",
                                                    "doc": "the MIME type of the codec (e.g.: video/vp8)",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "clockRate",
                                                    "doc": "The negotiated clock rate the RTP timestamp is generated of",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "channels",
                                                    "doc": "The number of channels for audio is used (in stereo it is 2, otherwise it is most likely null)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sdpFmtpLine",
                                                    "doc": "The a=fmtp line in the SDP corresponding to the codec",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "outboundVideoTracks",
                                "doc": "List of compound measurements related to outbound video tracks",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "OutboundVideoTrack",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "trackId",
                                                    "doc": "The id of the track",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "peerConnectionId",
                                                    "doc": " The unique generated identifier of the peer connection the inbound audio track belongs to",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sfuStreamId",
                                                    "doc": "The id of the SFU stream this track is related to",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "ssrc",
                                                    "doc": "The RTP SSRC field",
                                                    "type": "long"
                                                },
                                                {
                                                    "name": "packetsSent",
                                                    "doc": "The total number of packets sent on the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "bytesSent",
                                                    "doc": "The total number of bytes sent on the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtxSsrc",
                                                    "doc": "If RTX is negotiated as a separate stream, this is the SSRC of the RTX stream that is associated with this stream's ssrc. ",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rid",
                                                    "doc": " The rid encoding parameter of the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "lastPacketSentTimestamp",
                                                    "doc": " the timestamp the last packet was sent. (UTC epoch in ms)",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "headerBytesSent",
                                                    "doc": "Total number of RTP header and padding bytes sent over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsDiscardedOnSend",
                                                    "doc": "Total number of RTP packets discarded at sender side over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "bytesDiscardedOnSend",
                                                    "doc": "Total number of RTP bytes discarded at sender side over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "fecPacketsSent",
                                                    "doc": "Total number of FEC packets sent over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "retransmittedPacketsSent",
                                                    "doc": "Total number of retransmitted packets sent over the corresponding synchronization source (ssrc).",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "retransmittedBytesSent",
                                                    "doc": "Total number of retransmitted bytes sent over the corresponding synchronization source (ssrc).",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "targetBitrate",
                                                    "doc": "Reflects the current encoder target in bits per second.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalEncodedBytesTarget",
                                                    "doc": "The total number of bytes of RTP coherent frames encoded completly depending on the frame size the encoder targets",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalPacketSendDelay",
                                                    "doc": "The total number of delay packets buffered at the sender side in seconds over the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "averageRtcpInterval",
                                                    "doc": "The average RTCP interval between two consecutive compound RTCP packets sent for the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "perDscpPacketsSent",
                                                    "doc": "The total number of DSCP flagged RTP packets sent over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "nackCount",
                                                    "doc": "Count the total number of Negative ACKnowledgement (NACK) packets received over the corresponding synchronization source (ssrc)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "firCount",
                                                    "doc": "The total number FIR packets sent from this endpoint to the source on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "pliCount",
                                                    "doc": "The total number of Picture Loss Indication sent on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sliCount",
                                                    "doc": "The total number of SLI indicator sent from the endpoint on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "encoderImplementation",
                                                    "doc": "Indicate the name of the encoder implementation library",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "frameWidth",
                                                    "doc": "The frame width in pixels of the frames targeted by the media encoder",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "frameHeight",
                                                    "doc": "The frame width the media encoder targeted",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "frameBitDepth",
                                                    "doc": "The frame depth in pixles on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "framesPerSecond",
                                                    "doc": "The encoded number of frames in the last second on the corresponded media source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "framesSent",
                                                    "doc": "TThe total number of frames sent on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "hugeFramesSent",
                                                    "doc": "The total number of huge frames (avgFrameSize * 2.5) on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "framesEncoded",
                                                    "doc": "The total number of frames encoded by the media source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "keyFramesEncoded",
                                                    "doc": "The total number of keyframes encoded on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "framesDiscardedOnSend",
                                                    "doc": "The total number of frames discarded on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "qpSum",
                                                    "doc": "The sum of the QP the media encoder provided on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalEncodeTime",
                                                    "doc": "The total time in seconds spent in encoding media frames for the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "qualityLimitationDurationNone",
                                                    "doc": "Time elapsed in seconds when the RTC connection has not limited the quality",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "qualityLimitationDurationCPU",
                                                    "doc": "Time elapsed in seconds the RTC connection had a limitation because of CPU",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "qualityLimitationDurationBandwidth",
                                                    "doc": "Time elapsed in seconds the RTC connection had a limitation because of Bandwidth",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "qualityLimitationDurationOther",
                                                    "doc": "Time elapsed in seconds the RTC connection had a limitation because of Other factor",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "qualityLimitationReason",
                                                    "doc": "Indicate a reason for the quality limitation of the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "qualityLimitationResolutionChanges",
                                                    "doc": "The total number of resolution changes occured ont he corresponded RTP stream due to quality changes",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsReceived",
                                                    "doc": "The total number of packets received on the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsLost",
                                                    "doc": "The total number of bytes received on the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "jitter",
                                                    "doc": "The corresponded synchronization source reported jitter",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsDiscarded",
                                                    "doc": "The total number of packets missed the playout point and therefore discarded by the jitterbuffer",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsRepaired",
                                                    "doc": "The total number of packets repaired by either FEC or due to retransmission on the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstPacketsLost",
                                                    "doc": "The total number of packets lost in burst (RFC6958)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstPacketsDiscarded",
                                                    "doc": "The total number of packets discarded in burst (RFC6958)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstLossCount",
                                                    "doc": "The total number of burst happened causes burstPacketsLost on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstDiscardCount",
                                                    "doc": "The total number of burst happened causes burstPacketsDiscarded on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstLossRate",
                                                    "doc": "The fraction of RTP packets lost during bursts proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "burstDiscardRate",
                                                    "doc": "The fraction of RTP packets discarded during bursts proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "gapLossRate",
                                                    "doc": "The fraction of RTP packets lost during gap proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "gapDiscardRate",
                                                    "doc": "The fraction of RTP packets discarded during gap proportionally to the total number of RTP packets expected in the bursts on the corresponding synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "roundTripTime",
                                                    "doc": "RTT measurement in seconds based on (most likely) SR, and RR belongs to the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "totalRoundTripTime",
                                                    "doc": "The sum of RTT measurements belongs to the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "fractionLost",
                                                    "doc": "The receiver reported fractional lost belongs to the corresponded synchronization source",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "reportsReceived",
                                                    "doc": "The total number of RR reports received, which is the base of the remote inbound calculation on this source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "roundTripTimeMeasurements",
                                                    "doc": "The total number of calculated RR measurements received on this source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "framesDropped",
                                                    "doc": "The total number of frames reported to be lost by the remote endpoit on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "partialFramesLost",
                                                    "doc": "The total number of partial frames reported to be lost by the remote endpoint on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "fullFramesLost",
                                                    "doc": "The total number of full frames lost at the remote endpoint on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "relayedSource",
                                                    "doc": "True if the corresponded media source is remote, false otherwise (or null depending on browser and version)",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "width",
                                                    "doc": "The width, in pixels, of the last frame originating from the media source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "height",
                                                    "doc": "The height, in pixels, of the last frame originating from the media source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "bitDepth",
                                                    "doc": "The bitDepth, in pixels, of the last frame originating from the media source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "frames",
                                                    "doc": "The total number of frames originated from the media source",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "ended",
                                                    "doc": "Flag represents if the sender ended the media stream track or not.",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "payloadType",
                                                    "doc": "The type of the payload the RTP packet SSRC belongs to",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "mimeType",
                                                    "doc": "the MIME type of the codec (e.g.: video/vp8)",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "clockRate",
                                                    "doc": "The negotiated clock rate the RTP timestamp is generated of",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "channels",
                                                    "doc": "The number of channels for audio is used (in stereo it is 2, otherwise it is most likely null)",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sdpFmtpLine",
                                                    "doc": "The a=fmtp line in the SDP corresponding to the codec",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "iceLocalCandidates",
                                "doc": "List of local ICE candidates",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "IceLocalCandidate",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "peerConnectionId",
                                                    "doc": "Refers to the peer connection the local candidate belongs to",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "id",
                                                    "doc": "The unique identifier of the local candidate",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "address",
                                                    "doc": "The address of the local endpoint (Ipv4, Ipv6, FQDN)",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "port",
                                                    "doc": "The port number of the local endpoint the ICE uses",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "protocol",
                                                    "doc": "The protocol for the ICE",
                                                    "type": [
                                                        "null",
                                                        {
                                                            "type": "enum",
                                                            "name": "LocalCandidateProtocol",
                                                            "symbols": [
                                                                "tcp",
                                                                "udp"
                                                            ]
                                                        }
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidateType",
                                                    "doc": "The type of the local candidate",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "priority",
                                                    "doc": "The priority of the local candidate",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "url",
                                                    "doc": "The url of the ICE server",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "relayProtocol",
                                                    "doc": "The relay protocol the local candidate uses",
                                                    "type": [
                                                        "null",
                                                        {
                                                            "type": "enum",
                                                            "name": "LocalCandidateRelayProtocol",
                                                            "symbols": [
                                                                "tcp",
                                                                "udp",
                                                                "tls"
                                                            ]
                                                        }
                                                    ],
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "iceRemoteCandidates",
                                "doc": "List of remote ICE candidates",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "IceRemoteCandidate",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "peerConnectionId",
                                                    "doc": "Refers to the peer connection the local candidate belongs to",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "id",
                                                    "doc": "The unique identifier of the local candidate",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "address",
                                                    "doc": "The address of the local endpoint (Ipv4, Ipv6, FQDN)",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "port",
                                                    "doc": "The port number of the local endpoint the ICE uses",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "protocol",
                                                    "doc": "The protocol for the ICE",
                                                    "type": [
                                                        "null",
                                                        {
                                                            "type": "enum",
                                                            "name": "RemoteCandidateProtocol",
                                                            "symbols": [
                                                                "tcp",
                                                                "udp"
                                                            ]
                                                        }
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "candidateType",
                                                    "doc": "The type of the local candidate",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "priority",
                                                    "doc": "The priority of the local candidate",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "url",
                                                    "doc": "The url of the ICE server",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "relayProtocol",
                                                    "doc": "The relay protocol the local candidate uses",
                                                    "type": [
                                                        "null",
                                                        {
                                                            "type": "enum",
                                                            "name": "RemoteCandidateRelayProtocol",
                                                            "symbols": [
                                                                "tcp",
                                                                "udp",
                                                                "tls"
                                                            ]
                                                        }
                                                    ],
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "dataChannels",
                                "doc": "List of Data channels",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "DataChannel",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "peerConnectionId",
                                                    "doc": "Refers to the peer connection the local candidate belongs to",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "id",
                                                    "doc": "Unique identifier of the data channel",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "label",
                                                    "doc": "The label the data channel provided at the creation",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "address",
                                                    "doc": "The address of the local endpoint (Ipv4, Ipv6, FQDN)",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "port",
                                                    "doc": "The port number of the local endpoint the ICE uses",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "protocol",
                                                    "doc": " The protocol the data channel use to transfer data",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "dataChannelIdentifier",
                                                    "doc": "The unique identifier of the data channel",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "state",
                                                    "doc": "The state of the data channel",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "messagesSent",
                                                    "doc": "The total number of messages sent on this data channel. this is not equal to the number of packets sent, as messages are chunked to packets",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "bytesSent",
                                                    "doc": "The amount of bytes sent on the corresponded data channel",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "messagesReceived",
                                                    "doc": "The number of messages received on the corresponded data channel",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "bytesReceived",
                                                    "doc": "The amount of bytes received on the corresponded data channel",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "timestamp",
                                "doc": "The timestamp the sample is created in GMT",
                                "type": "long"
                            },
                            {
                                "name": "timeZoneOffsetInHours",
                                "doc": "The offset from GMT in hours",
                                "type": [
                                    "null",
                                    "int"
                                ],
                                "default": null
                            },
                            {
                                "name": "marker",
                                "doc": "Special marker for the samples",
                                "type": [
                                    "null",
                                    "string"
                                ],
                                "default": null
                            }
                        ]
                    }
                }
            ],
            "default": null
        },
        {
            "name": "sfuSamples",
            "doc": "Samples taken from an Sfu",
            "type": [
                "null",
                {
                    "type": "array",
                    "items": {
                        "name": "SfuSample",
                        "type": "record",
                        "doc": "docs",
                        "fields": [
                            {
                                "name": "sfuId",
                                "doc": "Unique generated id for the sfu samples are originated from",
                                "type": "string"
                            },
                            {
                                "name": "timestamp",
                                "doc": "The timestamp the sample is created in GMT",
                                "type": "long"
                            },
                            {
                                "name": "timeZoneOffsetInHours",
                                "doc": "The offset from GMT in hours",
                                "type": [
                                    "null",
                                    "int"
                                ],
                                "default": null
                            },
                            {
                                "name": "marker",
                                "doc": "Special marker for the samples",
                                "type": [
                                    "null",
                                    "string"
                                ],
                                "default": null
                            },
                            {
                                "name": "transports",
                                "doc": "The Sfu Transports obtained measurements",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "SfuTransport",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "noReport",
                                                    "doc": "Flag indicate to not generate report from this sample",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "transportId",
                                                    "doc": "The generated unique identifier of the transport",
                                                    "type": "string"
                                                },
                                                {
                                                    "name": "internal",
                                                    "doc": "Flag to indicate that the transport is used as an internal transport between SFU instances",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "dtlsState",
                                                    "doc": "Represent the current value of the state attribute of the underlying RTCDtlsTransport.",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "iceState",
                                                    "doc": "Represent the current value of the state attribute of the underlying RTCIceTransport",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sctpState",
                                                    "doc": "Represents the the current value of the SCTP state of the transport of the SFU",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "iceRole",
                                                    "doc": "Represent the current value of the role SFU takes place in ICE",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "localAddress",
                                                    "doc": "The local address of the ICE candidate selected for the transport (IPv4, IPv6, FQDN)",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "localPort",
                                                    "doc": "The local port number",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "protocol",
                                                    "doc": "The protocol used by the transport",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "remoteAddress",
                                                    "doc": "The remote address of the ICE candidate selected for the transport (IPv4, IPv6, FQDN)",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "remotePort",
                                                    "doc": "The remote port number",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtpBytesReceived",
                                                    "doc": "The total amount of RTP bytes received on this transport",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtpBytesSent",
                                                    "doc": "The total amount of RTP bytes sent on this transport",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtpPacketsReceived",
                                                    "doc": "The total amount of RTP packets received on this transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtpPacketsSent",
                                                    "doc": "The total amount of RTP packets sent on this transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtpPacketsLost",
                                                    "doc": "The total amount of RTP packets lost on this transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtxBytesReceived",
                                                    "doc": "The total amount of RTX bytes received on this transport",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtxBytesSent",
                                                    "doc": "The total amount of RTX bytes sent on this transport",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtxPacketsReceived",
                                                    "doc": "The total amount of RTX packets received on this transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtxPacketsSent",
                                                    "doc": "The total amount of RTX packets sent on this transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtxPacketsLost",
                                                    "doc": "The total amount of RTX packets lost on this transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtxPacketsDiscarded",
                                                    "doc": "The total amount of RTX packets discarded on this transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sctpBytesReceived",
                                                    "doc": "The total amount of SCTP bytes received on this transport",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sctpBytesSent",
                                                    "doc": "The total amount of SCTP bytes sent on this transport",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sctpPacketsReceived",
                                                    "doc": "The total amount of SCTP packets received on this transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sctpPacketsSent",
                                                    "doc": "The total amount of SCTP packets sent on this transport",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "inboundRtpPads",
                                "doc": "The Sfu Inbound Rtp Pad obtained measurements",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "SfuInboundRtpPad",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "noReport",
                                                    "doc": "Flag indicate to not generate report from this sample",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "transportId",
                                                    "doc": "The id of the transport the RTP Pad uses.",
                                                    "type": "string"
                                                },
                                                {
                                                    "name": "internal",
                                                    "doc": "Flag to indicate that the rtp pad is used as an internal communication between SFU instances",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "streamId",
                                                    "doc": "The id of the media stream the RTP pad belongs to. This id is to group rtp pads (e.g.: simulcast) carrying payloads to the same media. ",
                                                    "type": "string"
                                                },
                                                {
                                                    "name": "padId",
                                                    "doc": "The id of Sfu pad.",
                                                    "type": "string"
                                                },
                                                {
                                                    "name": "ssrc",
                                                    "doc": "The synchronization source id of the RTP stream",
                                                    "type": "long"
                                                },
                                                {
                                                    "name": "mediaType",
                                                    "doc": "the type of the media the stream carries (\"audio\" or \"video\")",
                                                    "type": [
                                                        "null",
                                                        {
                                                            "type": "enum",
                                                            "name": "SfuInboundMediaType",
                                                            "symbols": [
                                                                "audio",
                                                                "video"
                                                            ]
                                                        }
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "payloadType",
                                                    "doc": "The payload type field of the RTP header",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "mimeType",
                                                    "doc": "The negotiated mimeType in the SDP",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "clockRate",
                                                    "doc": "The clock rate of the media source the RTP header carries",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sdpFmtpLine",
                                                    "doc": "The actual SDP line from the negotiation related to this RTP stream",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rid",
                                                    "doc": " The rid parameter of the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtxSsrc",
                                                    "doc": "If RTX is negotiated as a separate stream, this is the SSRC of the RTX stream that is associated with this stream's ssrc. ",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "targetBitrate",
                                                    "doc": "he bitrate the corresponded stream targets.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "voiceActivityFlag",
                                                    "doc": "The RTP header V flag indicate of the activity of the media source by the media codec if the RTP transport ships it through",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "firCount",
                                                    "doc": "The total number FIR packets sent from this endpoint to the source on the corresponded RTP stream. Only for Video streams",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "pliCount",
                                                    "doc": "The total number of Picture Loss Indication sent on the corresponded RTP stream. Only for Video streams",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "nackCount",
                                                    "doc": "The total number of negative acknowledgement received on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sliCount",
                                                    "doc": "The total number of SLI indicator sent from the endpoint on the corresponded RTP stream. Only for Audio stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsLost",
                                                    "doc": "The total number of packets lost on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsReceived",
                                                    "doc": "The total number of packets received on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsDiscarded",
                                                    "doc": "The total number of discarded packets on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsRepaired",
                                                    "doc": "The total number of packets repaired by either retransmission or FEC on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsFailedDecryption",
                                                    "doc": "The total number of packets failed to be decrypted on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsDuplicated",
                                                    "doc": "The total number of duplicated packets appeared on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "fecPacketsReceived",
                                                    "doc": "The total number of FEC packets received on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "fecPacketsDiscarded",
                                                    "doc": "The total number of FEC packets discarded on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "bytesReceived",
                                                    "doc": "The total amount of payload bytes received on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtcpSrReceived",
                                                    "doc": "The total number of SR reports received by the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtcpRrSent",
                                                    "doc": "The total number of RR reports sent on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtxPacketsReceived",
                                                    "doc": "If rtx packets are sent or received on the same stream then this number indicates how may has been sent",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtxPacketsDiscarded",
                                                    "doc": "If rtx packets are received on the same stream then this number indicates how may has been discarded",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "framesReceived",
                                                    "doc": "The number of frames received on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "framesDecoded",
                                                    "doc": "Indicate the number of frames the Sfu has been decoded",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "keyFramesDecoded",
                                                    "doc": "Indicate the number of keyframes the Sfu has been decoded",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "fractionLost",
                                                    "doc": "The calculated fractionLost of the stream",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "jitter",
                                                    "doc": "The calculated jitter of the stream",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "roundTripTime",
                                                    "doc": "The calculated RTT of the stream",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "outboundRtpPads",
                                "doc": "The Sfu Outbound Rtp Pad obtained measurements",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "SfuOutboundRtpPad",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "noReport",
                                                    "doc": "Flag indicate to not generate report from this sample",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "transportId",
                                                    "doc": "The id of the transport the RTP stream uses.",
                                                    "type": "string"
                                                },
                                                {
                                                    "name": "internal",
                                                    "doc": "Flag to indicate that the rtp pad is used as an internal communication between SFU instances",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "streamId",
                                                    "doc": "The id of the stream this outbound RTP pad sinks the media from",
                                                    "type": "string"
                                                },
                                                {
                                                    "name": "sinkId",
                                                    "doc": "The id of a group of RTP pad sinks the media stream out from the SFU.",
                                                    "type": "string"
                                                },
                                                {
                                                    "name": "padId",
                                                    "doc": "The id of Sfu pad.",
                                                    "type": "string"
                                                },
                                                {
                                                    "name": "ssrc",
                                                    "doc": "The synchronization source id of the RTP stream",
                                                    "type": "long"
                                                },
                                                {
                                                    "name": "callId",
                                                    "doc": "The callId the event belongs to",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "clientId",
                                                    "doc": "If the track id was provided by the Sfu, the observer can fill up the information of which client it belongs to",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "trackId",
                                                    "doc": "The id of the track the RTP stream related to at the client side",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "mediaType",
                                                    "doc": "the type of the media the stream carries (\"audio\" or \"video\")",
                                                    "type": [
                                                        "null",
                                                        {
                                                            "type": "enum",
                                                            "name": "SfuOutboundMediaType",
                                                            "symbols": [
                                                                "audio",
                                                                "video"
                                                            ]
                                                        }
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "payloadType",
                                                    "doc": "The payload type field of the RTP header",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "mimeType",
                                                    "doc": "The negotiated mimeType in the SDP",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "clockRate",
                                                    "doc": "The clock rate of the media source the RTP header carries",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sdpFmtpLine",
                                                    "doc": "The actual SDP line from the negotiation related to this RTP stream",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rid",
                                                    "doc": " The rid parameter of the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtxSsrc",
                                                    "doc": "If RTX is negotiated as a separate stream, this is the SSRC of the RTX stream that is associated with this stream's ssrc. ",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "targetBitrate",
                                                    "doc": "he bitrate the corresponded stream targets.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "voiceActivityFlag",
                                                    "doc": "The RTP header V flag indicate of the activity of the media source by the media codec if the RTP transport ships it through",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "firCount",
                                                    "doc": "The total number FIR packets sent from this endpoint to the source on the corresponded RTP stream. Only for Video streams",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "pliCount",
                                                    "doc": "The total number of Picture Loss Indication sent on the corresponded RTP stream. Only for Video streams",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "nackCount",
                                                    "doc": "The total number of negative acknowledgement received on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sliCount",
                                                    "doc": "The total number of SLI indicator sent from the endpoint on the corresponded RTP stream. Only for Audio stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsLost",
                                                    "doc": "The total number of packets lost on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsSent",
                                                    "doc": "The total number of packets sent on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsDiscarded",
                                                    "doc": "The total number of discarded packets on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsRetransmitted",
                                                    "doc": "The total number of packets retransmitted on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsFailedEncryption",
                                                    "doc": "The total number of packets failed to be encrypted on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "packetsDuplicated",
                                                    "doc": "The total number of duplicated packets appeared on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "fecPacketsSent",
                                                    "doc": "The total number of FEC packets sent on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "fecPacketsDiscarded",
                                                    "doc": "The total number of FEC packets discarded on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "bytesSent",
                                                    "doc": "The total amount of payload bytes sent on the corresponded RTP stream.",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtcpSrSent",
                                                    "doc": "The total number of SR reports sent by the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtcpRrReceived",
                                                    "doc": "The total number of RR reports received on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtxPacketsSent",
                                                    "doc": "If rtx packets sent on the same stream then this number indicates how may has been sent",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "rtxPacketsDiscarded",
                                                    "doc": "If rtx packets are received on the same stream then this number indicates how may has been discarded",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "framesSent",
                                                    "doc": "The number of frames sent on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "framesEncoded",
                                                    "doc": "Indicate the number of frames the Sfu has been encoded",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "keyFramesEncoded",
                                                    "doc": "Indicate the number of keyframes the Sfu has been encoded on the corresponded RTP stream",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "fractionLost",
                                                    "doc": "The calculated fractionLost of the stream",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "jitter",
                                                    "doc": "The calculated jitter of the stream",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "roundTripTime",
                                                    "doc": "The calculated RTT of the stream",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "sctpChannels",
                                "doc": "The Sfu Outbound Rtp Pad obtained measurements",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "SfuSctpChannel",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "noReport",
                                                    "doc": "Flag indicate to not generate report from this sample",
                                                    "type": [
                                                        "null",
                                                        "boolean"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "transportId",
                                                    "doc": "The id of the transport the RTP stream uses.",
                                                    "type": "string"
                                                },
                                                {
                                                    "name": "streamId",
                                                    "doc": "The id of the sctp stream",
                                                    "type": "string"
                                                },
                                                {
                                                    "name": "channelId",
                                                    "doc": "The id of the sctp stream",
                                                    "type": "string"
                                                },
                                                {
                                                    "name": "label",
                                                    "doc": "The label of the sctp stream",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "protocol",
                                                    "doc": "The protocol used to establish an sctp stream",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sctpSmoothedRoundTripTime",
                                                    "doc": "The latest smoothed round-trip time value, corresponding to spinfo_srtt defined in [RFC6458] but converted to seconds. If there has been no round-trip time measurements yet, this value is undefined.",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sctpCongestionWindow",
                                                    "doc": "The latest congestion window, corresponding to spinfo_cwnd defined in [RFC6458].",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sctpReceiverWindow",
                                                    "doc": "The latest receiver window, corresponding to sstat_rwnd defined in [RFC6458].",
                                                    "type": [
                                                        "null",
                                                        "double"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sctpMtu",
                                                    "doc": "The latest maximum transmission unit, corresponding to spinfo_mtu defined in [RFC6458].",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sctpUnackData",
                                                    "doc": "The number of unacknowledged DATA chunks, corresponding to sstat_unackdata defined in [RFC6458].",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "messageReceived",
                                                    "doc": "The number of message received on the corresponded SCTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "messageSent",
                                                    "doc": "The number of message sent on the corresponded SCTP stream.",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "bytesReceived",
                                                    "doc": "The number of bytes received on the corresponded SCTP stream.",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "bytesSent",
                                                    "doc": "The number of bytes sent on the corresponded SCTP stream.",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "extensionStats",
                                "doc": "The Sfu provided custom stats payload",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "SfuExtensionStats",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "type",
                                                    "type": "string",
                                                    "doc": "The type of the extension stats the custom app provides"
                                                },
                                                {
                                                    "name": "payload",
                                                    "type": "string",
                                                    "doc": "The payload of the extension stats the custom app provides"
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            }
                        ]
                    }
                }
            ],
            "default": null
        },
        {
            "name": "turnSamples",
            "doc": "Samples taken from the TURN server",
            "type": [
                "null",
                {
                    "type": "array",
                    "items": {
                        "name": "TurnSample",
                        "type": "record",
                        "doc": "docs",
                        "fields": [
                            {
                                "name": "serverId",
                                "doc": "A unique id of the turn server",
                                "type": "string"
                            },
                            {
                                "name": "allocations",
                                "doc": "Peer Alloocation data",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "TurnPeerAllocation",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "peerId",
                                                    "doc": "a unique id for the allocation",
                                                    "type": "string"
                                                },
                                                {
                                                    "name": "sessionId",
                                                    "doc": "The corresponded session the allocation belongs to",
                                                    "type": "string"
                                                },
                                                {
                                                    "name": "relayedAddress",
                                                    "doc": "The allocated address",
                                                    "type": "string"
                                                },
                                                {
                                                    "name": "relayedPort",
                                                    "doc": "The allocated port",
                                                    "type": "int"
                                                },
                                                {
                                                    "name": "transportProtocol",
                                                    "doc": "protocol (TCP, UDP)",
                                                    "type": "string"
                                                },
                                                {
                                                    "name": "peerAddress",
                                                    "doc": "The address of the address the serever connect to",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "peerPort",
                                                    "doc": "The portnumber the server connects to",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sendingBitrate",
                                                    "doc": "the bitrate the TURN server sending to the peer",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "receivingBitrate",
                                                    "doc": "the bitrate the TURN server receiving from the peer",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sentBytes",
                                                    "doc": "the amount of bytes sent to the peer",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "receivedBytes",
                                                    "doc": "the amount of bytes received from the peer",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sentPackets",
                                                    "doc": "the amount of packets sent to the peer",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "receivedPackets",
                                                    "doc": "the amount of packets received from the peer",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            },
                            {
                                "name": "sessions",
                                "doc": "Session data",
                                "type": [
                                    "null",
                                    {
                                        "type": "array",
                                        "items": {
                                            "name": "TurnSession",
                                            "type": "record",
                                            "fields": [
                                                {
                                                    "name": "sessionId",
                                                    "doc": "Flag indicate to not generate report from this sample",
                                                    "type": "string"
                                                },
                                                {
                                                    "name": "realm",
                                                    "doc": "The Authentication Realm (RFC 8656)",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "username",
                                                    "doc": "The username of the used in authentication",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "clientId",
                                                    "doc": "The id of the client the TURN session belongs to (ClientSample)",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "started",
                                                    "doc": "The timestamp when the session has been started. Epoch in milliseconds, GMT",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "nonceExpirationTime",
                                                    "doc": "For each Allocate request, the server SHOULD generate a new random nonce when the allocation is first attempted following the randomness recommendations in [RFC4086] and SHOULD expire the nonce at least once every hour during the lifetime of the allocation.  Epoch in millis GMT",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "serverAddress",
                                                    "doc": "The address of the server the client connected to",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "serverPort",
                                                    "doc": "The portnumber the server listens the client requests",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "transportProtocol",
                                                    "doc": "the transport protocol betwwen the client and the server (TCP, UDP, TCPTLS, UDPTLS, SCTP, SCTPTLS)",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "clientAddress",
                                                    "doc": "The address of the client connected from",
                                                    "type": [
                                                        "null",
                                                        "string"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "clientPort",
                                                    "doc": "The portnumber the client requested from",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sendingBitrate",
                                                    "doc": "the bitrate the TURN server sending to the client",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "receivingBitrate",
                                                    "doc": "the bitrate the TURN server receiving from the client",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sentBytes",
                                                    "doc": "the amount of bytes sent to the client",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "receivedBytes",
                                                    "doc": "the amount of bytes received from the client",
                                                    "type": [
                                                        "null",
                                                        "long"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "sentPackets",
                                                    "doc": "the amount of packets sent to the client",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                },
                                                {
                                                    "name": "receivedPackets",
                                                    "doc": "the amount of packets received from the client",
                                                    "type": [
                                                        "null",
                                                        "int"
                                                    ],
                                                    "default": null
                                                }
                                            ]
                                        }
                                    }
                                ],
                                "default": null
                            }
                        ]
                    }
                }
            ],
            "default": null
        }
    ]
};

},{}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatsType = exports.version = void 0;
exports.version = {
    date: new Date("2021-11-10"),
};
var StatsType;
(function (StatsType) {
    StatsType["codec"] = "codec";
    StatsType["inboundRtp"] = "inbound-rtp";
    StatsType["outboundRtp"] = "outbound-rtp";
    StatsType["remoteInboundRtp"] = "remote-inbound-rtp";
    StatsType["remoteOutboundRtp"] = "remote-outbound-rtp";
    StatsType["mediaSource"] = "media-source";
    StatsType["csrc"] = "csrc";
    StatsType["peerConnection"] = "peer-connection";
    StatsType["dataChannel"] = "data-channel";
    StatsType["stream"] = "stream";
    StatsType["track"] = "track";
    StatsType["transceiver"] = "transceiver";
    StatsType["sender"] = "sender";
    StatsType["receiver"] = "receiver";
    StatsType["transport"] = "transport";
    StatsType["sctpTransport"] = "sctp-transport";
    StatsType["candidatePair"] = "candidate-pair";
    StatsType["localCandidate"] = "local-candidate";
    StatsType["remoteCandidate"] = "remote-candidate";
    StatsType["certificate"] = "certificate";
    StatsType["iceServer"] = "ice-server";
})(StatsType = exports.StatsType || (exports.StatsType = {}));
;

},{}],77:[function(require,module,exports){
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

},{}],78:[function(require,module,exports){
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

},{}],79:[function(require,module,exports){
"use strict";
module.exports = codegen;

/**
 * Begins generating a function.
 * @memberof util
 * @param {string[]} functionParams Function parameter names
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 */
function codegen(functionParams, functionName) {

    /* istanbul ignore if */
    if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = undefined;
    }

    var body = [];

    /**
     * Appends code to the function's body or finishes generation.
     * @typedef Codegen
     * @type {function}
     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
     * @param {...*} [formatParams] Format parameters
     * @returns {Codegen|Function} Itself or the generated function if finished
     * @throws {Error} If format parameter counts do not match
     */

    function Codegen(formatStringOrScope) {
        // note that explicit array handling below makes this ~50% faster

        // finish the function
        if (typeof formatStringOrScope !== "string") {
            var source = toString();
            if (codegen.verbose)
                console.log("codegen: " + source); // eslint-disable-line no-console
            source = "return " + source;
            if (formatStringOrScope) {
                var scopeKeys   = Object.keys(formatStringOrScope),
                    scopeParams = new Array(scopeKeys.length + 1),
                    scopeValues = new Array(scopeKeys.length),
                    scopeOffset = 0;
                while (scopeOffset < scopeKeys.length) {
                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
                }
                scopeParams[scopeOffset] = source;
                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
            }
            return Function(source)(); // eslint-disable-line no-new-func
        }

        // otherwise append to body
        var formatParams = new Array(arguments.length - 1),
            formatOffset = 0;
        while (formatOffset < formatParams.length)
            formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
            var value = formatParams[formatOffset++];
            switch ($1) {
                case "d": case "f": return String(Number(value));
                case "i": return String(Math.floor(value));
                case "j": return JSON.stringify(value);
                case "s": return String(value);
            }
            return "%";
        });
        if (formatOffset !== formatParams.length)
            throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
    }

    function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
    }

    Codegen.toString = toString;
    return Codegen;
}

/**
 * Begins generating a function.
 * @memberof util
 * @function codegen
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 * @variation 2
 */

/**
 * When set to `true`, codegen will log generated code to console. Useful for debugging.
 * @name util.codegen.verbose
 * @type {boolean}
 */
codegen.verbose = false;

},{}],80:[function(require,module,exports){
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

},{}],81:[function(require,module,exports){
"use strict";
module.exports = fetch;

var asPromise = require("@protobufjs/aspromise"),
    inquire   = require("@protobufjs/inquire");

var fs = inquire("fs");

/**
 * Node-style callback as used by {@link util.fetch}.
 * @typedef FetchCallback
 * @type {function}
 * @param {?Error} error Error, if any, otherwise `null`
 * @param {string} [contents] File contents, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Options as used by {@link util.fetch}.
 * @typedef FetchOptions
 * @type {Object}
 * @property {boolean} [binary=false] Whether expecting a binary response
 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
 */

/**
 * Fetches the contents of a file.
 * @memberof util
 * @param {string} filename File path or url
 * @param {FetchOptions} options Fetch options
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
function fetch(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else if (!options)
        options = {};

    if (!callback)
        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
    if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err && typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(null, options.binary ? contents : contents.toString("utf8"));
        });

    // use the XHR version otherwise.
    return fetch.xhr(filename, options, callback);
}

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchOptions} [options] Fetch options
 * @returns {Promise<string|Uint8Array>} Promise
 * @variation 3
 */

/**/
fetch.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

        if (xhr.readyState !== 4)
            return undefined;

        // local cors security errors return status 0 / empty string, too. afaik this cannot be
        // reliably distinguished from an actually empty file for security reasons. feel free
        // to send a pull request if you are aware of a solution.
        if (xhr.status !== 0 && xhr.status !== 200)
            return callback(Error("status " + xhr.status));

        // if binary data is expected, make sure that some sort of array is returned, even if
        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
        if (options.binary) {
            var buffer = xhr.response;
            if (!buffer) {
                buffer = [];
                for (var i = 0; i < xhr.responseText.length; ++i)
                    buffer.push(xhr.responseText.charCodeAt(i) & 255);
            }
            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
    };

    if (options.binary) {
        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
        if ("overrideMimeType" in xhr)
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
    }

    xhr.open("GET", filename);
    xhr.send();
};

},{"@protobufjs/aspromise":77,"@protobufjs/inquire":83}],82:[function(require,module,exports){
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

},{}],83:[function(require,module,exports){
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

},{}],84:[function(require,module,exports){
"use strict";

/**
 * A minimal path module to resolve Unix, Windows and URL paths alike.
 * @memberof util
 * @namespace
 */
var path = exports;

var isAbsolute =
/**
 * Tests if the specified path is absolute.
 * @param {string} path Path to test
 * @returns {boolean} `true` if path is absolute
 */
path.isAbsolute = function isAbsolute(path) {
    return /^(?:\/|\w+:)/.test(path);
};

var normalize =
/**
 * Normalizes the specified path.
 * @param {string} path Path to normalize
 * @returns {string} Normalized path
 */
path.normalize = function normalize(path) {
    path = path.replace(/\\/g, "/")
               .replace(/\/{2,}/g, "/");
    var parts    = path.split("/"),
        absolute = isAbsolute(path),
        prefix   = "";
    if (absolute)
        prefix = parts.shift() + "/";
    for (var i = 0; i < parts.length;) {
        if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
                parts.splice(--i, 2);
            else if (absolute)
                parts.splice(i, 1);
            else
                ++i;
        } else if (parts[i] === ".")
            parts.splice(i, 1);
        else
            ++i;
    }
    return prefix + parts.join("/");
};

/**
 * Resolves the specified include path against the specified origin path.
 * @param {string} originPath Path to the origin file
 * @param {string} includePath Include path relative to origin path
 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
 * @returns {string} Path to the include file
 */
path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
        includePath = normalize(includePath);
    if (isAbsolute(includePath))
        return includePath;
    if (!alreadyNormalized)
        originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
};

},{}],85:[function(require,module,exports){
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

},{}],86:[function(require,module,exports){
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};

},{}],87:[function(require,module,exports){
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.bowser=t():e.bowser=t()}(this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=90)}({17:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n=r(18),i=function(){function e(){}return e.getFirstMatch=function(e,t){var r=t.match(e);return r&&r.length>0&&r[1]||""},e.getSecondMatch=function(e,t){var r=t.match(e);return r&&r.length>1&&r[2]||""},e.matchAndReturnConst=function(e,t,r){if(e.test(t))return r},e.getWindowsVersionName=function(e){switch(e){case"NT":return"NT";case"XP":return"XP";case"NT 5.0":return"2000";case"NT 5.1":return"XP";case"NT 5.2":return"2003";case"NT 6.0":return"Vista";case"NT 6.1":return"7";case"NT 6.2":return"8";case"NT 6.3":return"8.1";case"NT 10.0":return"10";default:return}},e.getMacOSVersionName=function(e){var t=e.split(".").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),10===t[0])switch(t[1]){case 5:return"Leopard";case 6:return"Snow Leopard";case 7:return"Lion";case 8:return"Mountain Lion";case 9:return"Mavericks";case 10:return"Yosemite";case 11:return"El Capitan";case 12:return"Sierra";case 13:return"High Sierra";case 14:return"Mojave";case 15:return"Catalina";default:return}},e.getAndroidVersionName=function(e){var t=e.split(".").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?"Cupcake":1===t[0]&&t[1]>=6?"Donut":2===t[0]&&t[1]<2?"Eclair":2===t[0]&&2===t[1]?"Froyo":2===t[0]&&t[1]>2?"Gingerbread":3===t[0]?"Honeycomb":4===t[0]&&t[1]<1?"Ice Cream Sandwich":4===t[0]&&t[1]<4?"Jelly Bean":4===t[0]&&t[1]>=4?"KitKat":5===t[0]?"Lollipop":6===t[0]?"Marshmallow":7===t[0]?"Nougat":8===t[0]?"Oreo":9===t[0]?"Pie":void 0},e.getVersionPrecision=function(e){return e.split(".").length},e.compareVersions=function(t,r,n){void 0===n&&(n=!1);var i=e.getVersionPrecision(t),s=e.getVersionPrecision(r),a=Math.max(i,s),o=0,u=e.map([t,r],(function(t){var r=a-e.getVersionPrecision(t),n=t+new Array(r+1).join(".0");return e.map(n.split("."),(function(e){return new Array(20-e.length).join("0")+e})).reverse()}));for(n&&(o=a-Math.min(i,s)),a-=1;a>=o;){if(u[0][a]>u[1][a])return 1;if(u[0][a]===u[1][a]){if(a===o)return 0;a-=1}else if(u[0][a]<u[1][a])return-1}},e.map=function(e,t){var r,n=[];if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)n.push(t(e[r]));return n},e.find=function(e,t){var r,n;if(Array.prototype.find)return Array.prototype.find.call(e,t);for(r=0,n=e.length;r<n;r+=1){var i=e[r];if(t(i,r))return i}},e.assign=function(e){for(var t,r,n=e,i=arguments.length,s=new Array(i>1?i-1:0),a=1;a<i;a++)s[a-1]=arguments[a];if(Object.assign)return Object.assign.apply(Object,[e].concat(s));var o=function(){var e=s[t];"object"==typeof e&&null!==e&&Object.keys(e).forEach((function(t){n[t]=e[t]}))};for(t=0,r=s.length;t<r;t+=1)o();return e},e.getBrowserAlias=function(e){return n.BROWSER_ALIASES_MAP[e]},e.getBrowserTypeByAlias=function(e){return n.BROWSER_MAP[e]||""},e}();t.default=i,e.exports=t.default},18:function(e,t,r){"use strict";t.__esModule=!0,t.ENGINE_MAP=t.OS_MAP=t.PLATFORMS_MAP=t.BROWSER_MAP=t.BROWSER_ALIASES_MAP=void 0;t.BROWSER_ALIASES_MAP={"Amazon Silk":"amazon_silk","Android Browser":"android",Bada:"bada",BlackBerry:"blackberry",Chrome:"chrome",Chromium:"chromium",Electron:"electron",Epiphany:"epiphany",Firefox:"firefox",Focus:"focus",Generic:"generic","Google Search":"google_search",Googlebot:"googlebot","Internet Explorer":"ie","K-Meleon":"k_meleon",Maxthon:"maxthon","Microsoft Edge":"edge","MZ Browser":"mz","NAVER Whale Browser":"naver",Opera:"opera","Opera Coast":"opera_coast",PhantomJS:"phantomjs",Puffin:"puffin",QupZilla:"qupzilla",QQ:"qq",QQLite:"qqlite",Safari:"safari",Sailfish:"sailfish","Samsung Internet for Android":"samsung_internet",SeaMonkey:"seamonkey",Sleipnir:"sleipnir",Swing:"swing",Tizen:"tizen","UC Browser":"uc",Vivaldi:"vivaldi","WebOS Browser":"webos",WeChat:"wechat","Yandex Browser":"yandex",Roku:"roku"};t.BROWSER_MAP={amazon_silk:"Amazon Silk",android:"Android Browser",bada:"Bada",blackberry:"BlackBerry",chrome:"Chrome",chromium:"Chromium",electron:"Electron",epiphany:"Epiphany",firefox:"Firefox",focus:"Focus",generic:"Generic",googlebot:"Googlebot",google_search:"Google Search",ie:"Internet Explorer",k_meleon:"K-Meleon",maxthon:"Maxthon",edge:"Microsoft Edge",mz:"MZ Browser",naver:"NAVER Whale Browser",opera:"Opera",opera_coast:"Opera Coast",phantomjs:"PhantomJS",puffin:"Puffin",qupzilla:"QupZilla",qq:"QQ Browser",qqlite:"QQ Browser Lite",safari:"Safari",sailfish:"Sailfish",samsung_internet:"Samsung Internet for Android",seamonkey:"SeaMonkey",sleipnir:"Sleipnir",swing:"Swing",tizen:"Tizen",uc:"UC Browser",vivaldi:"Vivaldi",webos:"WebOS Browser",wechat:"WeChat",yandex:"Yandex Browser"};t.PLATFORMS_MAP={tablet:"tablet",mobile:"mobile",desktop:"desktop",tv:"tv"};t.OS_MAP={WindowsPhone:"Windows Phone",Windows:"Windows",MacOS:"macOS",iOS:"iOS",Android:"Android",WebOS:"WebOS",BlackBerry:"BlackBerry",Bada:"Bada",Tizen:"Tizen",Linux:"Linux",ChromeOS:"Chrome OS",PlayStation4:"PlayStation 4",Roku:"Roku"};t.ENGINE_MAP={EdgeHTML:"EdgeHTML",Blink:"Blink",Trident:"Trident",Presto:"Presto",Gecko:"Gecko",WebKit:"WebKit"}},90:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n,i=(n=r(91))&&n.__esModule?n:{default:n},s=r(18);function a(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var o=function(){function e(){}var t,r,n;return e.getParser=function(e,t){if(void 0===t&&(t=!1),"string"!=typeof e)throw new Error("UserAgent should be a string");return new i.default(e,t)},e.parse=function(e){return new i.default(e).getResult()},t=e,n=[{key:"BROWSER_MAP",get:function(){return s.BROWSER_MAP}},{key:"ENGINE_MAP",get:function(){return s.ENGINE_MAP}},{key:"OS_MAP",get:function(){return s.OS_MAP}},{key:"PLATFORMS_MAP",get:function(){return s.PLATFORMS_MAP}}],(r=null)&&a(t.prototype,r),n&&a(t,n),e}();t.default=o,e.exports=t.default},91:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n=u(r(92)),i=u(r(93)),s=u(r(94)),a=u(r(95)),o=u(r(17));function u(e){return e&&e.__esModule?e:{default:e}}var d=function(){function e(e,t){if(void 0===t&&(t=!1),null==e||""===e)throw new Error("UserAgent parameter can't be empty");this._ua=e,this.parsedResult={},!0!==t&&this.parse()}var t=e.prototype;return t.getUA=function(){return this._ua},t.test=function(e){return e.test(this._ua)},t.parseBrowser=function(){var e=this;this.parsedResult.browser={};var t=o.default.find(n.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.browser=t.describe(this.getUA())),this.parsedResult.browser},t.getBrowser=function(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()},t.getBrowserName=function(e){return e?String(this.getBrowser().name).toLowerCase()||"":this.getBrowser().name||""},t.getBrowserVersion=function(){return this.getBrowser().version},t.getOS=function(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()},t.parseOS=function(){var e=this;this.parsedResult.os={};var t=o.default.find(i.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.os=t.describe(this.getUA())),this.parsedResult.os},t.getOSName=function(e){var t=this.getOS().name;return e?String(t).toLowerCase()||"":t||""},t.getOSVersion=function(){return this.getOS().version},t.getPlatform=function(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()},t.getPlatformType=function(e){void 0===e&&(e=!1);var t=this.getPlatform().type;return e?String(t).toLowerCase()||"":t||""},t.parsePlatform=function(){var e=this;this.parsedResult.platform={};var t=o.default.find(s.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.platform=t.describe(this.getUA())),this.parsedResult.platform},t.getEngine=function(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()},t.getEngineName=function(e){return e?String(this.getEngine().name).toLowerCase()||"":this.getEngine().name||""},t.parseEngine=function(){var e=this;this.parsedResult.engine={};var t=o.default.find(a.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.engine=t.describe(this.getUA())),this.parsedResult.engine},t.parse=function(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this},t.getResult=function(){return o.default.assign({},this.parsedResult)},t.satisfies=function(e){var t=this,r={},n=0,i={},s=0;if(Object.keys(e).forEach((function(t){var a=e[t];"string"==typeof a?(i[t]=a,s+=1):"object"==typeof a&&(r[t]=a,n+=1)})),n>0){var a=Object.keys(r),u=o.default.find(a,(function(e){return t.isOS(e)}));if(u){var d=this.satisfies(r[u]);if(void 0!==d)return d}var c=o.default.find(a,(function(e){return t.isPlatform(e)}));if(c){var f=this.satisfies(r[c]);if(void 0!==f)return f}}if(s>0){var l=Object.keys(i),h=o.default.find(l,(function(e){return t.isBrowser(e,!0)}));if(void 0!==h)return this.compareVersion(i[h])}},t.isBrowser=function(e,t){void 0===t&&(t=!1);var r=this.getBrowserName().toLowerCase(),n=e.toLowerCase(),i=o.default.getBrowserTypeByAlias(n);return t&&i&&(n=i.toLowerCase()),n===r},t.compareVersion=function(e){var t=[0],r=e,n=!1,i=this.getBrowserVersion();if("string"==typeof i)return">"===e[0]||"<"===e[0]?(r=e.substr(1),"="===e[1]?(n=!0,r=e.substr(2)):t=[],">"===e[0]?t.push(1):t.push(-1)):"="===e[0]?r=e.substr(1):"~"===e[0]&&(n=!0,r=e.substr(1)),t.indexOf(o.default.compareVersions(i,r,n))>-1},t.isOS=function(e){return this.getOSName(!0)===String(e).toLowerCase()},t.isPlatform=function(e){return this.getPlatformType(!0)===String(e).toLowerCase()},t.isEngine=function(e){return this.getEngineName(!0)===String(e).toLowerCase()},t.is=function(e,t){return void 0===t&&(t=!1),this.isBrowser(e,t)||this.isOS(e)||this.isPlatform(e)},t.some=function(e){var t=this;return void 0===e&&(e=[]),e.some((function(e){return t.is(e)}))},e}();t.default=d,e.exports=t.default},92:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n};var s=/version\/(\d+(\.?_?\d+)+)/i,a=[{test:[/googlebot/i],describe:function(e){var t={name:"Googlebot"},r=i.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/opera/i],describe:function(e){var t={name:"Opera"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\/|opios/i],describe:function(e){var t={name:"Opera"},r=i.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe:function(e){var t={name:"Samsung Internet for Android"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe:function(e){var t={name:"NAVER Whale Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe:function(e){var t={name:"MZ Browser"},r=i.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/focus/i],describe:function(e){var t={name:"Focus"},r=i.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/swing/i],describe:function(e){var t={name:"Swing"},r=i.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/coast/i],describe:function(e){var t={name:"Opera Coast"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opt\/\d+(?:.?_?\d+)+/i],describe:function(e){var t={name:"Opera Touch"},r=i.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe:function(e){var t={name:"Yandex Browser"},r=i.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe:function(e){var t={name:"UC Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe:function(e){var t={name:"Maxthon"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe:function(e){var t={name:"Epiphany"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe:function(e){var t={name:"Puffin"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe:function(e){var t={name:"Sleipnir"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe:function(e){var t={name:"K-Meleon"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe:function(e){var t={name:"WeChat"},r=i.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe:function(e){var t={name:/qqbrowserlite/i.test(e)?"QQ Browser Lite":"QQ Browser"},r=i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe:function(e){var t={name:"Internet Explorer"},r=i.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\sedg\//i],describe:function(e){var t={name:"Microsoft Edge"},r=i.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe:function(e){var t={name:"Microsoft Edge"},r=i.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe:function(e){var t={name:"Vivaldi"},r=i.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe:function(e){var t={name:"SeaMonkey"},r=i.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe:function(e){var t={name:"Sailfish"},r=i.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe:function(e){var t={name:"Amazon Silk"},r=i.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe:function(e){var t={name:"PhantomJS"},r=i.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe:function(e){var t={name:"SlimerJS"},r=i.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t={name:"BlackBerry"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t={name:"WebOS Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe:function(e){var t={name:"Bada"},r=i.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe:function(e){var t={name:"Tizen"},r=i.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe:function(e){var t={name:"QupZilla"},r=i.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe:function(e){var t={name:"Firefox"},r=i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/electron/i],describe:function(e){var t={name:"Electron"},r=i.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MiuiBrowser/i],describe:function(e){var t={name:"Miui"},r=i.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe:function(e){var t={name:"Chromium"},r=i.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe:function(e){var t={name:"Chrome"},r=i.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe:function(e){var t={name:"Google Search"},r=i.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t={name:"Android Browser"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe:function(e){var t={name:"PlayStation 4"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe:function(e){var t={name:"Safari"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/.*/i],describe:function(e){var t=-1!==e.search("\\(")?/^(.*)\/(.*)[ \t]\((.*)/:/^(.*)\/(.*) /;return{name:i.default.getFirstMatch(t,e),version:i.default.getSecondMatch(t,e)}}}];t.default=a,e.exports=t.default},93:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/Roku\/DVP/],describe:function(e){var t=i.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i,e);return{name:s.OS_MAP.Roku,version:t}}},{test:[/windows phone/i],describe:function(e){var t=i.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.WindowsPhone,version:t}}},{test:[/windows /i],describe:function(e){var t=i.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i,e),r=i.default.getWindowsVersionName(t);return{name:s.OS_MAP.Windows,version:t,versionName:r}}},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe:function(e){var t={name:s.OS_MAP.iOS},r=i.default.getSecondMatch(/(Version\/)(\d[\d.]+)/,e);return r&&(t.version=r),t}},{test:[/macintosh/i],describe:function(e){var t=i.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i,e).replace(/[_\s]/g,"."),r=i.default.getMacOSVersionName(t),n={name:s.OS_MAP.MacOS,version:t};return r&&(n.versionName=r),n}},{test:[/(ipod|iphone|ipad)/i],describe:function(e){var t=i.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i,e).replace(/[_\s]/g,".");return{name:s.OS_MAP.iOS,version:t}}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t=i.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i,e),r=i.default.getAndroidVersionName(t),n={name:s.OS_MAP.Android,version:t};return r&&(n.versionName=r),n}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t=i.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i,e),r={name:s.OS_MAP.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t=i.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i,e)||i.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i,e)||i.default.getFirstMatch(/\bbb(\d+)/i,e);return{name:s.OS_MAP.BlackBerry,version:t}}},{test:[/bada/i],describe:function(e){var t=i.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.Bada,version:t}}},{test:[/tizen/i],describe:function(e){var t=i.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.Tizen,version:t}}},{test:[/linux/i],describe:function(){return{name:s.OS_MAP.Linux}}},{test:[/CrOS/],describe:function(){return{name:s.OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe:function(e){var t=i.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.PlayStation4,version:t}}}];t.default=a,e.exports=t.default},94:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/googlebot/i],describe:function(){return{type:"bot",vendor:"Google"}}},{test:[/huawei/i],describe:function(e){var t=i.default.getFirstMatch(/(can-l01)/i,e)&&"Nova",r={type:s.PLATFORMS_MAP.mobile,vendor:"Huawei"};return t&&(r.model=t),r}},{test:[/nexus\s*(?:7|8|9|10).*/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Nexus"}}},{test:[/ipad/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/kftt build/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Amazon",model:"Kindle Fire HD 7"}}},{test:[/silk/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Amazon"}}},{test:[/tablet(?! pc)/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){var t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe:function(e){var t=i.default.getFirstMatch(/(ipod|iphone)/i,e);return{type:s.PLATFORMS_MAP.mobile,vendor:"Apple",model:t}}},{test:[/nexus\s*[0-6].*/i,/galaxy nexus/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"Nexus"}}},{test:[/[^-]mobi/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"blackberry"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"BlackBerry"}}},{test:function(e){return"bada"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"windows phone"===e.getBrowserName()},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"Microsoft"}}},{test:function(e){var t=Number(String(e.getOSVersion()).split(".")[0]);return"android"===e.getOSName(!0)&&t>=3},describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){return"android"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"macos"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop,vendor:"Apple"}}},{test:function(e){return"windows"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return"linux"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return"playstation 4"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}},{test:function(e){return"roku"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}}];t.default=a,e.exports=t.default},95:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:function(e){return"microsoft edge"===e.getBrowserName(!0)},describe:function(e){if(/\sedg\//i.test(e))return{name:s.ENGINE_MAP.Blink};var t=i.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i,e);return{name:s.ENGINE_MAP.EdgeHTML,version:t}}},{test:[/trident/i],describe:function(e){var t={name:s.ENGINE_MAP.Trident},r=i.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){return e.test(/presto/i)},describe:function(e){var t={name:s.ENGINE_MAP.Presto},r=i.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe:function(e){var t={name:s.ENGINE_MAP.Gecko},r=i.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\/537\.36/i],describe:function(){return{name:s.ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe:function(e){var t={name:s.ENGINE_MAP.WebKit},r=i.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}}];t.default=a,e.exports=t.default}})}));
},{}],88:[function(require,module,exports){
(function (process,global){(function (){
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var ERROR = 'input is invalid type';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA256_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === 'object' && module.exports;
  var AMD = typeof define === 'function' && define.amd;
  var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [-2147483648, 8388608, 32768, 128];
  var SHIFT = [24, 16, 8, 0];
  var K = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
  ];
  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];

  var blocks = [];

  if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (outputType, is224) {
    return function (message) {
      return new Sha256(is224, true).update(message)[outputType]();
    };
  };

  var createMethod = function (is224) {
    var method = createOutputMethod('hex', is224);
    if (NODE_JS) {
      method = nodeWrap(method, is224);
    }
    method.create = function () {
      return new Sha256(is224);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type, is224);
    }
    return method;
  };

  var nodeWrap = function (method, is224) {
    var crypto = eval("require('crypto')");
    var Buffer = eval("require('buffer').Buffer");
    var algorithm = is224 ? 'sha224' : 'sha256';
    var nodeMethod = function (message) {
      if (typeof message === 'string') {
        return crypto.createHash(algorithm).update(message, 'utf8').digest('hex');
      } else {
        if (message === null || message === undefined) {
          throw new Error(ERROR);
        } else if (message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        }
      }
      if (Array.isArray(message) || ArrayBuffer.isView(message) ||
        message.constructor === Buffer) {
        return crypto.createHash(algorithm).update(new Buffer(message)).digest('hex');
      } else {
        return method(message);
      }
    };
    return nodeMethod;
  };

  var createHmacOutputMethod = function (outputType, is224) {
    return function (key, message) {
      return new HmacSha256(key, is224, true).update(message)[outputType]();
    };
  };

  var createHmacMethod = function (is224) {
    var method = createHmacOutputMethod('hex', is224);
    method.create = function (key) {
      return new HmacSha256(key, is224);
    };
    method.update = function (key, message) {
      return method.create(key).update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createHmacOutputMethod(type, is224);
    }
    return method;
  };

  function Sha256(is224, sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =
        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      this.blocks = blocks;
    } else {
      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }

    if (is224) {
      this.h0 = 0xc1059ed8;
      this.h1 = 0x367cd507;
      this.h2 = 0x3070dd17;
      this.h3 = 0xf70e5939;
      this.h4 = 0xffc00b31;
      this.h5 = 0x68581511;
      this.h6 = 0x64f98fa7;
      this.h7 = 0xbefa4fa4;
    } else { // 256
      this.h0 = 0x6a09e667;
      this.h1 = 0xbb67ae85;
      this.h2 = 0x3c6ef372;
      this.h3 = 0xa54ff53a;
      this.h4 = 0x510e527f;
      this.h5 = 0x9b05688c;
      this.h6 = 0x1f83d9ab;
      this.h7 = 0x5be0cd19;
    }

    this.block = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
    this.is224 = is224;
  }

  Sha256.prototype.update = function (message) {
    if (this.finalized) {
      return;
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(ERROR);
          }
        }
      } else {
        throw new Error(ERROR);
      }
      notString = true;
    }
    var code, index = 0, i, length = message.length, blocks = this.blocks;

    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = this.block;
        blocks[16] = blocks[1] = blocks[2] = blocks[3] =
          blocks[4] = blocks[5] = blocks[6] = blocks[7] =
          blocks[8] = blocks[9] = blocks[10] = blocks[11] =
          blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }

      if (notString) {
        for (i = this.start; index < length && i < 64; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < 64; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }

      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.block = blocks[16];
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };

  Sha256.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex;
    blocks[16] = this.block;
    blocks[i >> 2] |= EXTRA[i & 3];
    this.block = blocks[16];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = this.block;
      blocks[16] = blocks[1] = blocks[2] = blocks[3] =
        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    }
    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;
    blocks[15] = this.bytes << 3;
    this.hash();
  };

  Sha256.prototype.hash = function () {
    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6,
      h = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;

    for (j = 16; j < 64; ++j) {
      // rightrotate
      t1 = blocks[j - 15];
      s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
      t1 = blocks[j - 2];
      s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);
      blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;
    }

    bc = b & c;
    for (j = 0; j < 64; j += 4) {
      if (this.first) {
        if (this.is224) {
          ab = 300032;
          t1 = blocks[0] - 1413257819;
          h = t1 - 150054599 << 0;
          d = t1 + 24177077 << 0;
        } else {
          ab = 704751109;
          t1 = blocks[0] - 210244248;
          h = t1 - 1521486534 << 0;
          d = t1 + 143694565 << 0;
        }
        this.first = false;
      } else {
        s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));
        s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
        ab = a & b;
        maj = ab ^ (a & c) ^ bc;
        ch = (e & f) ^ (~e & g);
        t1 = h + s1 + ch + K[j] + blocks[j];
        t2 = s0 + maj;
        h = d + t1 << 0;
        d = t1 + t2 << 0;
      }
      s0 = ((d >>> 2) | (d << 30)) ^ ((d >>> 13) | (d << 19)) ^ ((d >>> 22) | (d << 10));
      s1 = ((h >>> 6) | (h << 26)) ^ ((h >>> 11) | (h << 21)) ^ ((h >>> 25) | (h << 7));
      da = d & a;
      maj = da ^ (d & b) ^ ab;
      ch = (h & e) ^ (~h & f);
      t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
      t2 = s0 + maj;
      g = c + t1 << 0;
      c = t1 + t2 << 0;
      s0 = ((c >>> 2) | (c << 30)) ^ ((c >>> 13) | (c << 19)) ^ ((c >>> 22) | (c << 10));
      s1 = ((g >>> 6) | (g << 26)) ^ ((g >>> 11) | (g << 21)) ^ ((g >>> 25) | (g << 7));
      cd = c & d;
      maj = cd ^ (c & a) ^ da;
      ch = (g & h) ^ (~g & e);
      t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
      t2 = s0 + maj;
      f = b + t1 << 0;
      b = t1 + t2 << 0;
      s0 = ((b >>> 2) | (b << 30)) ^ ((b >>> 13) | (b << 19)) ^ ((b >>> 22) | (b << 10));
      s1 = ((f >>> 6) | (f << 26)) ^ ((f >>> 11) | (f << 21)) ^ ((f >>> 25) | (f << 7));
      bc = b & c;
      maj = bc ^ (b & d) ^ cd;
      ch = (f & g) ^ (~f & h);
      t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
      t2 = s0 + maj;
      e = a + t1 << 0;
      a = t1 + t2 << 0;
    }

    this.h0 = this.h0 + a << 0;
    this.h1 = this.h1 + b << 0;
    this.h2 = this.h2 + c << 0;
    this.h3 = this.h3 + d << 0;
    this.h4 = this.h4 + e << 0;
    this.h5 = this.h5 + f << 0;
    this.h6 = this.h6 + g << 0;
    this.h7 = this.h7 + h << 0;
  };

  Sha256.prototype.hex = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,
      h6 = this.h6, h7 = this.h7;

    var hex = HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +
      HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +
      HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +
      HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +
      HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +
      HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +
      HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +
      HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +
      HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +
      HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +
      HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +
      HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +
      HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F] +
      HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +
      HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +
      HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +
      HEX_CHARS[(h4 >> 28) & 0x0F] + HEX_CHARS[(h4 >> 24) & 0x0F] +
      HEX_CHARS[(h4 >> 20) & 0x0F] + HEX_CHARS[(h4 >> 16) & 0x0F] +
      HEX_CHARS[(h4 >> 12) & 0x0F] + HEX_CHARS[(h4 >> 8) & 0x0F] +
      HEX_CHARS[(h4 >> 4) & 0x0F] + HEX_CHARS[h4 & 0x0F] +
      HEX_CHARS[(h5 >> 28) & 0x0F] + HEX_CHARS[(h5 >> 24) & 0x0F] +
      HEX_CHARS[(h5 >> 20) & 0x0F] + HEX_CHARS[(h5 >> 16) & 0x0F] +
      HEX_CHARS[(h5 >> 12) & 0x0F] + HEX_CHARS[(h5 >> 8) & 0x0F] +
      HEX_CHARS[(h5 >> 4) & 0x0F] + HEX_CHARS[h5 & 0x0F] +
      HEX_CHARS[(h6 >> 28) & 0x0F] + HEX_CHARS[(h6 >> 24) & 0x0F] +
      HEX_CHARS[(h6 >> 20) & 0x0F] + HEX_CHARS[(h6 >> 16) & 0x0F] +
      HEX_CHARS[(h6 >> 12) & 0x0F] + HEX_CHARS[(h6 >> 8) & 0x0F] +
      HEX_CHARS[(h6 >> 4) & 0x0F] + HEX_CHARS[h6 & 0x0F];
    if (!this.is224) {
      hex += HEX_CHARS[(h7 >> 28) & 0x0F] + HEX_CHARS[(h7 >> 24) & 0x0F] +
        HEX_CHARS[(h7 >> 20) & 0x0F] + HEX_CHARS[(h7 >> 16) & 0x0F] +
        HEX_CHARS[(h7 >> 12) & 0x0F] + HEX_CHARS[(h7 >> 8) & 0x0F] +
        HEX_CHARS[(h7 >> 4) & 0x0F] + HEX_CHARS[h7 & 0x0F];
    }
    return hex;
  };

  Sha256.prototype.toString = Sha256.prototype.hex;

  Sha256.prototype.digest = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,
      h6 = this.h6, h7 = this.h7;

    var arr = [
      (h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, h0 & 0xFF,
      (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 8) & 0xFF, h1 & 0xFF,
      (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, h2 & 0xFF,
      (h3 >> 24) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, h3 & 0xFF,
      (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, h4 & 0xFF,
      (h5 >> 24) & 0xFF, (h5 >> 16) & 0xFF, (h5 >> 8) & 0xFF, h5 & 0xFF,
      (h6 >> 24) & 0xFF, (h6 >> 16) & 0xFF, (h6 >> 8) & 0xFF, h6 & 0xFF
    ];
    if (!this.is224) {
      arr.push((h7 >> 24) & 0xFF, (h7 >> 16) & 0xFF, (h7 >> 8) & 0xFF, h7 & 0xFF);
    }
    return arr;
  };

  Sha256.prototype.array = Sha256.prototype.digest;

  Sha256.prototype.arrayBuffer = function () {
    this.finalize();

    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
    var dataView = new DataView(buffer);
    dataView.setUint32(0, this.h0);
    dataView.setUint32(4, this.h1);
    dataView.setUint32(8, this.h2);
    dataView.setUint32(12, this.h3);
    dataView.setUint32(16, this.h4);
    dataView.setUint32(20, this.h5);
    dataView.setUint32(24, this.h6);
    if (!this.is224) {
      dataView.setUint32(28, this.h7);
    }
    return buffer;
  };

  function HmacSha256(key, is224, sharedMemory) {
    var i, type = typeof key;
    if (type === 'string') {
      var bytes = [], length = key.length, index = 0, code;
      for (i = 0; i < length; ++i) {
        code = key.charCodeAt(i);
        if (code < 0x80) {
          bytes[index++] = code;
        } else if (code < 0x800) {
          bytes[index++] = (0xc0 | (code >> 6));
          bytes[index++] = (0x80 | (code & 0x3f));
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes[index++] = (0xe0 | (code >> 12));
          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
          bytes[index++] = (0x80 | (code & 0x3f));
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));
          bytes[index++] = (0xf0 | (code >> 18));
          bytes[index++] = (0x80 | ((code >> 12) & 0x3f));
          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
          bytes[index++] = (0x80 | (code & 0x3f));
        }
      }
      key = bytes;
    } else {
      if (type === 'object') {
        if (key === null) {
          throw new Error(ERROR);
        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
          key = new Uint8Array(key);
        } else if (!Array.isArray(key)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
            throw new Error(ERROR);
          }
        }
      } else {
        throw new Error(ERROR);
      }
    }

    if (key.length > 64) {
      key = (new Sha256(is224, true)).update(key).array();
    }

    var oKeyPad = [], iKeyPad = [];
    for (i = 0; i < 64; ++i) {
      var b = key[i] || 0;
      oKeyPad[i] = 0x5c ^ b;
      iKeyPad[i] = 0x36 ^ b;
    }

    Sha256.call(this, is224, sharedMemory);

    this.update(iKeyPad);
    this.oKeyPad = oKeyPad;
    this.inner = true;
    this.sharedMemory = sharedMemory;
  }
  HmacSha256.prototype = new Sha256();

  HmacSha256.prototype.finalize = function () {
    Sha256.prototype.finalize.call(this);
    if (this.inner) {
      this.inner = false;
      var innerHash = this.array();
      Sha256.call(this, this.is224, this.sharedMemory);
      this.update(this.oKeyPad);
      this.update(innerHash);
      Sha256.prototype.finalize.call(this);
    }
  };

  var exports = createMethod();
  exports.sha256 = exports;
  exports.sha224 = createMethod(true);
  exports.sha256.hmac = createHmacMethod();
  exports.sha224.hmac = createHmacMethod(true);

  if (COMMON_JS) {
    module.exports = exports;
  } else {
    root.sha256 = exports.sha256;
    root.sha224 = exports.sha224;
    if (AMD) {
      define(function () {
        return exports;
      });
    }
  }
})();

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":2}],89:[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (typeof define === 'function' && define.amd) {
        define(definition);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = definition();
    } else {
        root.log = definition();
    }
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;

      var storageKey = "loglevel";
      if (typeof name === "string") {
        storageKey += ":" + name;
      } else if (typeof name === "symbol") {
        storageKey = undefined;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType || !storageKey) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage.removeItem(storageKey);
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {}
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          defaultLevel = level;
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.resetLevel = function () {
          self.setLevel(defaultLevel, false);
          clearPersistedLevel();
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if ((typeof name !== "symbol" && typeof name !== "string") || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    // ES6 default export, for compatibility
    defaultLogger['default'] = defaultLogger;

    return defaultLogger;
}));

},{}],90:[function(require,module,exports){
// light library entry point.

"use strict";
module.exports = require("./src/index-light");
},{"./src/index-light":96}],91:[function(require,module,exports){
"use strict";
/**
 * Runtime message from/to plain object converters.
 * @namespace
 */
var converter = exports;

var Enum = require("./enum"),
    util = require("./util");

/**
 * Generates a partial value fromObject conveter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(d%s){", prop);
            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                if (field.repeated && values[keys[i]] === field.typeDefault) gen
                ("default:");
                gen
                ("case%j:", keys[i])
                ("case %i:", values[keys[i]])
                    ("m%s=%j", prop, values[keys[i]])
                    ("break");
            } gen
            ("}");
        } else gen
            ("if(typeof d%s!==\"object\")", prop)
                ("throw TypeError(%j)", field.fullName + ": object expected")
            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
                ("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
                break;
            case "uint32":
            case "fixed32": gen
                ("m%s=d%s>>>0", prop, prop);
                break;
            case "int32":
            case "sint32":
            case "sfixed32": gen
                ("m%s=d%s|0", prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(util.Long)")
                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
                ("else if(typeof d%s===\"string\")", prop)
                    ("m%s=parseInt(d%s,10)", prop, prop)
                ("else if(typeof d%s===\"number\")", prop)
                    ("m%s=d%s", prop, prop)
                ("else if(typeof d%s===\"object\")", prop)
                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                break;
            case "bytes": gen
                ("if(typeof d%s===\"string\")", prop)
                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
                ("else if(d%s.length)", prop)
                    ("m%s=d%s", prop, prop);
                break;
            case "string": gen
                ("m%s=String(d%s)", prop, prop);
                break;
            case "bool": gen
                ("m%s=Boolean(d%s)", prop, prop);
                break;
            /* default: gen
                ("m%s=d%s", prop, prop);
                break; */
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a plain object to runtime message converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.fromObject = function fromObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")
    ("if(d instanceof this.ctor)")
        ("return d");
    if (!fields.length) return gen
    ("return new this.ctor");
    gen
    ("var m=new this.ctor");
    for (var i = 0; i < fields.length; ++i) {
        var field  = fields[i].resolve(),
            prop   = util.safeProp(field.name);

        // Map fields
        if (field.map) { gen
    ("if(d%s){", prop)
        ("if(typeof d%s!==\"object\")", prop)
            ("throw TypeError(%j)", field.fullName + ": object expected")
        ("m%s={}", prop)
        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
        ("}")
    ("}");

        // Repeated fields
        } else if (field.repeated) { gen
    ("if(d%s){", prop)
        ("if(!Array.isArray(d%s))", prop)
            ("throw TypeError(%j)", field.fullName + ": array expected")
        ("m%s=[]", prop)
        ("for(var i=0;i<d%s.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
        ("}")
    ("}");

        // Non-repeated fields
        } else {
            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
    ("if(d%s!=null){", prop); // !== undefined && !== null
        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
            if (!(field.resolvedType instanceof Enum)) gen
    ("}");
        }
    } return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

/**
 * Generates a partial value toObject converter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_toObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen
            ("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);
        else gen
            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
            ("if(typeof m%s===\"number\")", prop)
                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
            ("else") // Long-like
                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
                break;
            case "bytes": gen
            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                break;
            default: gen
            ("d%s=m%s", prop, prop);
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a runtime message to plain object converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.toObject = function toObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
        return util.codegen()("return {}");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")
    ("if(!o)")
        ("o={}")
    ("var d={}");

    var repeatedFields = [],
        mapFields = [],
        normalFields = [],
        i = 0;
    for (; i < fields.length; ++i)
        if (!fields[i].partOf)
            ( fields[i].resolve().repeated ? repeatedFields
            : fields[i].map ? mapFields
            : normalFields).push(fields[i]);

    if (repeatedFields.length) { gen
    ("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen
        ("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen
    ("}");
    }

    if (mapFields.length) { gen
    ("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen
        ("d%s={}", util.safeProp(mapFields[i].name));
        gen
    ("}");
    }

    if (normalFields.length) { gen
    ("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
            var field = normalFields[i],
                prop  = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum) gen
        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
            else if (field.long) gen
        ("if(util.Long){")
            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
        ("}else")
            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
            else if (field.bytes) {
                var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
                gen
        ("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))
        ("else{")
            ("d%s=%s", prop, arrayDefault)
            ("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)
        ("}");
            } else gen
        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
        } gen
    ("}");
    }
    var hasKs2 = false;
    for (i = 0; i < fields.length; ++i) {
        var field = fields[i],
            index = mtype._fieldsArray.indexOf(field),
            prop  = util.safeProp(field.name);
        if (field.map) {
            if (!hasKs2) { hasKs2 = true; gen
    ("var ks2");
            } gen
    ("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)
        ("d%s={}", prop)
        ("for(var j=0;j<ks2.length;++j){");
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
        ("}");
        } else if (field.repeated) { gen
    ("if(m%s&&m%s.length){", prop, prop)
        ("d%s=[]", prop)
        ("for(var j=0;j<m%s.length;++j){", prop);
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
        ("}");
        } else { gen
    ("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
        if (field.partOf) gen
        ("if(o.oneofs)")
            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen
    ("}");
    }
    return gen
    ("return d");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

},{"./enum":94,"./util":113}],92:[function(require,module,exports){
"use strict";
module.exports = decoder;

var Enum    = require("./enum"),
    types   = require("./types"),
    util    = require("./util");

function missing(field) {
    return "missing required '" + field.name + "'";
}

/**
 * Generates a decoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function decoder(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["r", "l"], mtype.name + "$decode")
    ("if(!(r instanceof Reader))")
        ("r=Reader.create(r)")
    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? ",k,value" : ""))
    ("while(r.pos<c){")
        ("var t=r.uint32()");
    if (mtype.group) gen
        ("if((t&7)===4)")
            ("break");
    gen
        ("switch(t>>>3){");

    var i = 0;
    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            type  = field.resolvedType instanceof Enum ? "int32" : field.type,
            ref   = "m" + util.safeProp(field.name); gen
            ("case %i:", field.id);

        // Map fields
        if (field.map) { gen
                ("if(%s===util.emptyObject)", ref)
                    ("%s={}", ref)
                ("var c2 = r.uint32()+r.pos");

            if (types.defaults[field.keyType] !== undefined) gen
                ("k=%j", types.defaults[field.keyType]);
            else gen
                ("k=null");

            if (types.defaults[type] !== undefined) gen
                ("value=%j", types.defaults[type]);
            else gen
                ("value=null");

            gen
                ("while(r.pos<c2){")
                    ("var tag2=r.uint32()")
                    ("switch(tag2>>>3){")
                        ("case 1: k=r.%s(); break", field.keyType)
                        ("case 2:");

            if (types.basic[type] === undefined) gen
                            ("value=types[%i].decode(r,r.uint32())", i); // can't be groups
            else gen
                            ("value=r.%s()", type);

            gen
                            ("break")
                        ("default:")
                            ("r.skipType(tag2&7)")
                            ("break")
                    ("}")
                ("}");

            if (types.long[field.keyType] !== undefined) gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=value", ref);
            else gen
                ("%s[k]=value", ref);

        // Repeated fields
        } else if (field.repeated) { gen

                ("if(!(%s&&%s.length))", ref, ref)
                    ("%s=[]", ref);

            // Packable (always check for forward and backward compatiblity)
            if (types.packed[type] !== undefined) gen
                ("if((t&7)===2){")
                    ("var c2=r.uint32()+r.pos")
                    ("while(r.pos<c2)")
                        ("%s.push(r.%s())", ref, type)
                ("}else");

            // Non-packed
            if (types.basic[type] === undefined) gen(field.resolvedType.group
                    ? "%s.push(types[%i].decode(r))"
                    : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
            else gen
                    ("%s.push(r.%s())", ref, type);

        // Non-repeated
        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
                ? "%s=types[%i].decode(r)"
                : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen
                ("%s=r.%s()", ref, type);
        gen
                ("break");
    // Unknown fields
    } gen
            ("default:")
                ("r.skipType(t&7)")
                ("break")

        ("}")
    ("}");

    // Field presence
    for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen
    ("if(!m.hasOwnProperty(%j))", rfield.name)
        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }

    return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline */
}

},{"./enum":94,"./types":112,"./util":113}],93:[function(require,module,exports){
"use strict";
module.exports = encoder;

var Enum     = require("./enum"),
    types    = require("./types"),
    util     = require("./util");

/**
 * Generates a partial message type encoder.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genTypePartial(gen, field, fieldIndex, ref) {
    return field.resolvedType.group
        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
}

/**
 * Generates an encoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function encoder(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
    ("if(!w)")
        ("w=Writer.create()");

    var i, ref;

    // "when a message is serialized its known fields should be written sequentially by field number"
    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

    for (var i = 0; i < fields.length; ++i) {
        var field    = fields[i].resolve(),
            index    = mtype._fieldsArray.indexOf(field),
            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
            wireType = types.basic[type];
            ref      = "m" + util.safeProp(field.name);

        // Map fields
        if (field.map) {
            gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name) // !== undefined && !== null
        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)
            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
            if (wireType === undefined) gen
            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
            else gen
            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
            gen
        ("}")
    ("}");

            // Repeated fields
        } else if (field.repeated) { gen
    ("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

            // Packed repeated
            if (field.packed && types.packed[type] !== undefined) { gen

        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
        ("for(var i=0;i<%s.length;++i)", ref)
            ("w.%s(%s[i])", type, ref)
        ("w.ldelim()");

            // Non-packed
            } else { gen

        ("for(var i=0;i<%s.length;++i)", ref);
                if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
                else gen
            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

            } gen
    ("}");

        // Non-repeated
        } else {
            if (field.optional) gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name); // !== undefined && !== null

            if (wireType === undefined)
        genTypePartial(gen, field, index, ref);
            else gen
        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

        }
    }

    return gen
    ("return w");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

},{"./enum":94,"./types":112,"./util":113}],94:[function(require,module,exports){
"use strict";
module.exports = Enum;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

var Namespace = require("./namespace"),
    util = require("./util");

/**
 * Constructs a new enum instance.
 * @classdesc Reflected enum.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {Object.<string,number>} [values] Enum values as an object, by name
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this enum
 * @param {Object.<string,string>} [comments] The value comments for this enum
 */
function Enum(name, values, options, comment, comments) {
    ReflectionObject.call(this, name, options);

    if (values && typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type {Object.<number,string>}
     */
    this.valuesById = {};

    /**
     * Enum values by name.
     * @type {Object.<string,number>}
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Enum comment text.
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Value comment texts, if any.
     * @type {Object.<string,string>}
     */
    this.comments = comments || {};

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
            if (typeof values[keys[i]] === "number") // use forward entries only
                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
}

/**
 * Enum descriptor.
 * @interface IEnum
 * @property {Object.<string,number>} values Enum values
 * @property {Object.<string,*>} [options] Enum options
 */

/**
 * Constructs an enum from an enum descriptor.
 * @param {string} name Enum name
 * @param {IEnum} json Enum descriptor
 * @returns {Enum} Created enum
 * @throws {TypeError} If arguments are invalid
 */
Enum.fromJSON = function fromJSON(name, json) {
    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
    enm.reserved = json.reserved;
    return enm;
};

/**
 * Converts this enum to an enum descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IEnum} Enum descriptor
 */
Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"  , this.options,
        "values"   , this.values,
        "reserved" , this.reserved && this.reserved.length ? this.reserved : undefined,
        "comment"  , keepComments ? this.comment : undefined,
        "comments" , keepComments ? this.comments : undefined
    ]);
};

/**
 * Adds a value to this enum.
 * @param {string} name Value name
 * @param {number} id Value id
 * @param {string} [comment] Comment, if any
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a value with this name or id
 */
Enum.prototype.add = function add(name, id, comment) {
    // utilized by the parser but not by .fromJSON

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (!util.isInteger(id))
        throw TypeError("id must be an integer");

    if (this.values[name] !== undefined)
        throw Error("duplicate name '" + name + "' in " + this);

    if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);

    if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);

    if (this.valuesById[id] !== undefined) {
        if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
    } else
        this.valuesById[this.values[name] = id] = name;

    this.comments[name] = comment || null;
    return this;
};

/**
 * Removes a value from this enum
 * @param {string} name Value name
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `name` is not a name of this enum
 */
Enum.prototype.remove = function remove(name) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    var val = this.values[name];
    if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);

    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];

    return this;
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

},{"./namespace":101,"./object":102,"./util":113}],95:[function(require,module,exports){
"use strict";
module.exports = Field;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

var Enum  = require("./enum"),
    types = require("./types"),
    util  = require("./util");

var Type; // cyclic

var ruleRe = /^required|optional|repeated$/;

/**
 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
 * @name Field
 * @classdesc Reflected message field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a field from a field descriptor.
 * @param {string} name Field name
 * @param {IField} json Field descriptor
 * @returns {Field} Created field
 * @throws {TypeError} If arguments are invalid
 */
Field.fromJSON = function fromJSON(name, json) {
    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
};

/**
 * Not an actual constructor. Use {@link Field} instead.
 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports FieldBase
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function Field(name, id, type, rule, extend, options, comment) {

    if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined && !util.isString(extend))
        throw TypeError("extend must be a string");

    if (rule === "proto3_optional") {
        rule = "optional";
    }
    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is required.
     * @type {boolean}
     */
    this.required = rule === "required";

    /**
     * Whether this field is optional.
     * @type {boolean}
     */
    this.optional = !this.required;

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {Type|null}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {OneOf|null}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {Type|Enum|null}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {Field|null}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {Field|null}
     */
    this.declaringField = null;

    /**
     * Internally remembers whether this field is packed.
     * @type {boolean|null}
     * @private
     */
    this._packed = null;

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
 * @name Field#packed
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "packed", {
    get: function() {
        // defaults to packed=true if not explicity set to false
        if (this._packed === null)
            this._packed = this.getOption("packed") !== false;
        return this._packed;
    }
});

/**
 * @override
 */
Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (name === "packed") // clear cached before setting
        this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
};

/**
 * Field descriptor.
 * @interface IField
 * @property {string} [rule="optional"] Field rule
 * @property {string} type Field type
 * @property {number} id Field id
 * @property {Object.<string,*>} [options] Field options
 */

/**
 * Extension field descriptor.
 * @interface IExtensionField
 * @extends IField
 * @property {string} extend Extended type
 */

/**
 * Converts this field to a field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IField} Field descriptor
 */
Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "rule"    , this.rule !== "optional" && this.rule || undefined,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Resolves this field's type references.
 * @returns {Field} `this`
 * @throws {Error} If any reference cannot be resolved
 */
Field.prototype.resolve = function resolve() {

    if (this.resolved)
        return this;

    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
            this.typeDefault = null;
        else // instanceof Enum
            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
    }

    // use explicitly set default value if present
    if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
            this.typeDefault = this.resolvedType.values[this.typeDefault];
    }

    // remove unnecessary options
    if (this.options) {
        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
            delete this.options.packed;
        if (!Object.keys(this.options).length)
            this.options = undefined;
    }

    // convert to internal data type if necesssary
    if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

        /* istanbul ignore else */
        if (Object.freeze)
            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)

    } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
    }

    // take special care of maps and repeated fields
    if (this.map)
        this.defaultValue = util.emptyObject;
    else if (this.repeated)
        this.defaultValue = util.emptyArray;
    else
        this.defaultValue = this.typeDefault;

    // ensure proper value on prototype
    if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;

    return ReflectionObject.prototype.resolve.call(this);
};

/**
 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
 * @typedef FieldDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} fieldName Field name
 * @returns {undefined}
 */

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @param {T} [defaultValue] Default value
 * @returns {FieldDecorator} Decorator function
 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
 */
Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

    // submessage: decorate the submessage and use its name as the type
    if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;

    // enum reference: create a reflected copy of the enum and keep reuseing it
    else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;

    return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
    };
};

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {Constructor<T>|string} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @returns {FieldDecorator} Decorator function
 * @template T extends Message<T>
 * @variation 2
 */
// like Field.d but without a default value

// Sets up cyclic dependencies (called in index-light)
Field._configure = function configure(Type_) {
    Type = Type_;
};

},{"./enum":94,"./object":102,"./types":112,"./util":113}],96:[function(require,module,exports){
"use strict";
var protobuf = module.exports = require("./index-minimal");

protobuf.build = "light";

/**
 * A node-style callback as used by {@link load} and {@link Root#load}.
 * @typedef LoadCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Root} [root] Root, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} root Root namespace, defaults to create a new one if omitted.
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 */
function load(filename, root, callback) {
    if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
    } else if (!root)
        root = new protobuf.Root();
    return root.load(filename, callback);
}

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Promise<Root>} Promise
 * @see {@link Root#load}
 * @variation 3
 */
// function load(filename:string, [root:Root]):Promise<Root>

protobuf.load = load;

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 * @see {@link Root#loadSync}
 */
function loadSync(filename, root) {
    if (!root)
        root = new protobuf.Root();
    return root.loadSync(filename);
}

protobuf.loadSync = loadSync;

// Serialization
protobuf.encoder          = require("./encoder");
protobuf.decoder          = require("./decoder");
protobuf.verifier         = require("./verifier");
protobuf.converter        = require("./converter");

// Reflection
protobuf.ReflectionObject = require("./object");
protobuf.Namespace        = require("./namespace");
protobuf.Root             = require("./root");
protobuf.Enum             = require("./enum");
protobuf.Type             = require("./type");
protobuf.Field            = require("./field");
protobuf.OneOf            = require("./oneof");
protobuf.MapField         = require("./mapfield");
protobuf.Service          = require("./service");
protobuf.Method           = require("./method");

// Runtime
protobuf.Message          = require("./message");
protobuf.wrappers         = require("./wrappers");

// Utility
protobuf.types            = require("./types");
protobuf.util             = require("./util");

// Set up possibly cyclic reflection dependencies
protobuf.ReflectionObject._configure(protobuf.Root);
protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
protobuf.Root._configure(protobuf.Type);
protobuf.Field._configure(protobuf.Type);

},{"./converter":91,"./decoder":92,"./encoder":93,"./enum":94,"./field":95,"./index-minimal":97,"./mapfield":98,"./message":99,"./method":100,"./namespace":101,"./object":102,"./oneof":103,"./root":106,"./service":110,"./type":111,"./types":112,"./util":113,"./verifier":116,"./wrappers":117}],97:[function(require,module,exports){
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require("./writer");
protobuf.BufferWriter = require("./writer_buffer");
protobuf.Reader       = require("./reader");
protobuf.BufferReader = require("./reader_buffer");

// Utility
protobuf.util         = require("./util/minimal");
protobuf.rpc          = require("./rpc");
protobuf.roots        = require("./roots");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();

},{"./reader":104,"./reader_buffer":105,"./roots":107,"./rpc":108,"./util/minimal":115,"./writer":118,"./writer_buffer":119}],98:[function(require,module,exports){
"use strict";
module.exports = MapField;

// extends Field
var Field = require("./field");
((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

var types   = require("./types"),
    util    = require("./util");

/**
 * Constructs a new map field instance.
 * @classdesc Reflected map field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} keyType Key type
 * @param {string} type Value type
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function MapField(name, id, keyType, type, options, comment) {
    Field.call(this, name, id, type, undefined, undefined, options, comment);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type {string}
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type {ReflectionObject|null}
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
}

/**
 * Map field descriptor.
 * @interface IMapField
 * @extends {IField}
 * @property {string} keyType Key type
 */

/**
 * Extension map field descriptor.
 * @interface IExtensionMapField
 * @extends IMapField
 * @property {string} extend Extended type
 */

/**
 * Constructs a map field from a map field descriptor.
 * @param {string} name Field name
 * @param {IMapField} json Map field descriptor
 * @returns {MapField} Created map field
 * @throws {TypeError} If arguments are invalid
 */
MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
};

/**
 * Converts this map field to a map field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMapField} Map field descriptor
 */
MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "keyType" , this.keyType,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
MapField.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;

    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
    if (types.mapKey[this.keyType] === undefined)
        throw Error("invalid key type: " + this.keyType);

    return Field.prototype.resolve.call(this);
};

/**
 * Map field decorator (TypeScript).
 * @name MapField.d
 * @function
 * @param {number} fieldId Field id
 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
 * @returns {FieldDecorator} Decorator function
 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
 */
MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

    // submessage value: decorate the submessage and use its name as the type
    if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;

    // enum reference value: create a reflected copy of the enum and keep reuseing it
    else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;

    return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
};

},{"./field":95,"./types":112,"./util":113}],99:[function(require,module,exports){
"use strict";
module.exports = Message;

var util = require("./util/minimal");

/**
 * Constructs a new message instance.
 * @classdesc Abstract runtime message.
 * @constructor
 * @param {Properties<T>} [properties] Properties to set
 * @template T extends object = object
 */
function Message(properties) {
    // not used internally
    if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
}

/**
 * Reference to the reflected type.
 * @name Message.$type
 * @type {Type}
 * @readonly
 */

/**
 * Reference to the reflected type.
 * @name Message#$type
 * @type {Type}
 * @readonly
 */

/*eslint-disable valid-jsdoc*/

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<T>} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.create = function create(properties) {
    return this.$type.create(properties);
};

/**
 * Encodes a message of this type.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
};

/**
 * Encodes a message of this type preceeded by its length as a varint.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
};

/**
 * Decodes a message of this type.
 * @name Message.decode
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decode = function decode(reader) {
    return this.$type.decode(reader);
};

/**
 * Decodes a message of this type preceeded by its length as a varint.
 * @name Message.decodeDelimited
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decodeDelimited = function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
};

/**
 * Verifies a message of this type.
 * @name Message.verify
 * @function
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {string|null} `null` if valid, otherwise the reason why it is not
 */
Message.verify = function verify(message) {
    return this.$type.verify(message);
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object
 * @returns {T} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.fromObject = function fromObject(object) {
    return this.$type.fromObject(object);
};

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {T} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.toObject = function toObject(message, options) {
    return this.$type.toObject(message, options);
};

/**
 * Converts this message to JSON.
 * @returns {Object.<string,*>} JSON object
 */
Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
};

/*eslint-enable valid-jsdoc*/
},{"./util/minimal":115}],100:[function(require,module,exports){
"use strict";
module.exports = Method;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

var util = require("./util");

/**
 * Constructs a new service method instance.
 * @classdesc Reflected service method.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Method name
 * @param {string|undefined} type Method type, usually `"rpc"`
 * @param {string} requestType Request message type
 * @param {string} responseType Response message type
 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this method
 * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object
 */
function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {

    /* istanbul ignore next */
    if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = undefined;
    }

    /* istanbul ignore if */
    if (!(type === undefined || util.isString(type)))
        throw TypeError("type must be a string");

    /* istanbul ignore if */
    if (!util.isString(requestType))
        throw TypeError("requestType must be a string");

    /* istanbul ignore if */
    if (!util.isString(responseType))
        throw TypeError("responseType must be a string");

    ReflectionObject.call(this, name, options);

    /**
     * Method type.
     * @type {string}
     */
    this.type = type || "rpc"; // toJSON

    /**
     * Request type.
     * @type {string}
     */
    this.requestType = requestType; // toJSON, marker

    /**
     * Whether requests are streamed or not.
     * @type {boolean|undefined}
     */
    this.requestStream = requestStream ? true : undefined; // toJSON

    /**
     * Response type.
     * @type {string}
     */
    this.responseType = responseType; // toJSON

    /**
     * Whether responses are streamed or not.
     * @type {boolean|undefined}
     */
    this.responseStream = responseStream ? true : undefined; // toJSON

    /**
     * Resolved request type.
     * @type {Type|null}
     */
    this.resolvedRequestType = null;

    /**
     * Resolved response type.
     * @type {Type|null}
     */
    this.resolvedResponseType = null;

    /**
     * Comment for this method
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Options properly parsed into an object
     */
    this.parsedOptions = parsedOptions;
}

/**
 * Method descriptor.
 * @interface IMethod
 * @property {string} [type="rpc"] Method type
 * @property {string} requestType Request type
 * @property {string} responseType Response type
 * @property {boolean} [requestStream=false] Whether requests are streamed
 * @property {boolean} [responseStream=false] Whether responses are streamed
 * @property {Object.<string,*>} [options] Method options
 * @property {string} comment Method comments
 * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object
 */

/**
 * Constructs a method from a method descriptor.
 * @param {string} name Method name
 * @param {IMethod} json Method descriptor
 * @returns {Method} Created method
 * @throws {TypeError} If arguments are invalid
 */
Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
};

/**
 * Converts this method to a method descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMethod} Method descriptor
 */
Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "type"           , this.type !== "rpc" && /* istanbul ignore next */ this.type || undefined,
        "requestType"    , this.requestType,
        "requestStream"  , this.requestStream,
        "responseType"   , this.responseType,
        "responseStream" , this.responseStream,
        "options"        , this.options,
        "comment"        , keepComments ? this.comment : undefined,
        "parsedOptions"  , this.parsedOptions,
    ]);
};

/**
 * @override
 */
Method.prototype.resolve = function resolve() {

    /* istanbul ignore if */
    if (this.resolved)
        return this;

    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);

    return ReflectionObject.prototype.resolve.call(this);
};

},{"./object":102,"./util":113}],101:[function(require,module,exports){
"use strict";
module.exports = Namespace;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

var Field    = require("./field"),
    OneOf    = require("./oneof"),
    util     = require("./util");

var Type,    // cyclic
    Service,
    Enum;

/**
 * Constructs a new namespace instance.
 * @name Namespace
 * @classdesc Reflected namespace.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a namespace from JSON.
 * @memberof Namespace
 * @function
 * @param {string} name Namespace name
 * @param {Object.<string,*>} json JSON object
 * @returns {Namespace} Created namespace
 * @throws {TypeError} If arguments are invalid
 */
Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
};

/**
 * Converts an array of reflection objects to JSON.
 * @memberof Namespace
 * @param {ReflectionObject[]} array Object array
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
 */
function arrayToJSON(array, toJSONOptions) {
    if (!(array && array.length))
        return undefined;
    var obj = {};
    for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
    return obj;
}

Namespace.arrayToJSON = arrayToJSON;

/**
 * Tests if the specified id is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedId = function isReservedId(reserved, id) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
                return true;
    return false;
};

/**
 * Tests if the specified name is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (reserved[i] === name)
                return true;
    return false;
};

/**
 * Not an actual constructor. Use {@link Namespace} instead.
 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports NamespaceBase
 * @extends ReflectionObject
 * @abstract
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 * @see {@link Namespace}
 */
function Namespace(name, options) {
    ReflectionObject.call(this, name, options);

    /**
     * Nested objects by name.
     * @type {Object.<string,ReflectionObject>|undefined}
     */
    this.nested = undefined; // toJSON

    /**
     * Cached nested objects as an array.
     * @type {ReflectionObject[]|null}
     * @private
     */
    this._nestedArray = null;
}

function clearCache(namespace) {
    namespace._nestedArray = null;
    return namespace;
}

/**
 * Nested objects of this namespace as an array for iteration.
 * @name NamespaceBase#nestedArray
 * @type {ReflectionObject[]}
 * @readonly
 */
Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
    }
});

/**
 * Namespace descriptor.
 * @interface INamespace
 * @property {Object.<string,*>} [options] Namespace options
 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
 */

/**
 * Any extension field descriptor.
 * @typedef AnyExtensionField
 * @type {IExtensionField|IExtensionMapField}
 */

/**
 * Any nested object descriptor.
 * @typedef AnyNestedObject
 * @type {IEnum|IType|IService|AnyExtensionField|INamespace}
 */
// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)

/**
 * Converts this namespace to a namespace descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {INamespace} Namespace descriptor
 */
Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util.toObject([
        "options" , this.options,
        "nested"  , arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
};

/**
 * Adds nested objects to this namespace from nested object descriptors.
 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
 * @returns {Namespace} `this`
 */
Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    /* istanbul ignore else */
    if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
            nested = nestedJson[names[i]];
            ns.add( // most to least likely
                ( nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : nested.id !== undefined
                ? Field.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    }
    return this;
};

/**
 * Gets the nested object of the specified name.
 * @param {string} name Nested object name
 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
 */
Namespace.prototype.get = function get(name) {
    return this.nested && this.nested[name]
        || null;
};

/**
 * Gets the values of the nested {@link Enum|enum} of the specified name.
 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
 * @param {string} name Nested enum name
 * @returns {Object.<string,number>} Enum values
 * @throws {Error} If there is no such enum
 */
Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
    throw Error("no such enum: " + name);
};

/**
 * Adds a nested object to this namespace.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name
 */
Namespace.prototype.add = function add(object) {

    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace || object instanceof OneOf))
        throw TypeError("object must be a valid nested object");

    if (!this.nested)
        this.nested = {};
    else {
        var prev = this.get(object.name);
        if (prev) {
            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                // replace plain namespace but keep existing nested elements and options
                var nested = prev.nestedArray;
                for (var i = 0; i < nested.length; ++i)
                    object.add(nested[i]);
                this.remove(prev);
                if (!this.nested)
                    this.nested = {};
                object.setOptions(prev.options, true);

            } else
                throw Error("duplicate name '" + object.name + "' in " + this);
        }
    }
    this.nested[object.name] = object;
    object.onAdd(this);
    return clearCache(this);
};

/**
 * Removes a nested object from this namespace.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this namespace
 */
Namespace.prototype.remove = function remove(object) {

    if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
        throw Error(object + " is not a member of " + this);

    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
        this.nested = undefined;

    object.onRemove(this);
    return clearCache(this);
};

/**
 * Defines additial namespaces within this one if not yet existing.
 * @param {string|string[]} path Path to create
 * @param {*} [json] Nested types to create from JSON
 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
 */
Namespace.prototype.define = function define(path, json) {

    if (util.isString(path))
        path = path.split(".");
    else if (!Array.isArray(path))
        throw TypeError("illegal path");
    if (path && path.length && path[0] === "")
        throw Error("path must be relative");

    var ptr = this;
    while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
            ptr = ptr.nested[part];
            if (!(ptr instanceof Namespace))
                throw Error("path conflicts with non-namespace objects");
        } else
            ptr.add(ptr = new Namespace(part));
    }
    if (json)
        ptr.addJSON(json);
    return ptr;
};

/**
 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
 * @returns {Namespace} `this`
 */
Namespace.prototype.resolveAll = function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i < nested.length)
        if (nested[i] instanceof Namespace)
            nested[i++].resolveAll();
        else
            nested[i++].resolve();
    return this.resolve();
};

/**
 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
 * @param {string|string[]} path Path to look up
 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 */
Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

    /* istanbul ignore next */
    if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = undefined;
    } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [ filterTypes ];

    if (util.isString(path) && path.length) {
        if (path === ".")
            return this.root;
        path = path.split(".");
    } else if (!path.length)
        return this;

    // Start at root if path is absolute
    if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);

    // Test if the first part matches any nested object, and if so, traverse if path contains more
    var found = this.get(path[0]);
    if (found) {
        if (path.length === 1) {
            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
                return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
            return found;

    // Otherwise try each nested namespace
    } else
        for (var i = 0; i < this.nestedArray.length; ++i)
            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
                return found;

    // If there hasn't been a match, try again at the parent
    if (this.parent === null || parentAlreadyChecked)
        return null;
    return this.parent.lookup(path, filterTypes);
};

/**
 * Looks up the reflection object at the specified path, relative to this namespace.
 * @name NamespaceBase#lookup
 * @function
 * @param {string|string[]} path Path to look up
 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 * @variation 2
 */
// lookup(path: string, [parentAlreadyChecked: boolean])

/**
 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type
 * @throws {Error} If `path` does not point to a type
 */
Namespace.prototype.lookupType = function lookupType(path) {
    var found = this.lookup(path, [ Type ]);
    if (!found)
        throw Error("no such type: " + path);
    return found;
};

/**
 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Enum} Looked up enum
 * @throws {Error} If `path` does not point to an enum
 */
Namespace.prototype.lookupEnum = function lookupEnum(path) {
    var found = this.lookup(path, [ Enum ]);
    if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type or enum
 * @throws {Error} If `path` does not point to a type or enum
 */
Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
    var found = this.lookup(path, [ Type, Enum ]);
    if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Service} Looked up service
 * @throws {Error} If `path` does not point to a service
 */
Namespace.prototype.lookupService = function lookupService(path) {
    var found = this.lookup(path, [ Service ]);
    if (!found)
        throw Error("no such Service '" + path + "' in " + this);
    return found;
};

// Sets up cyclic dependencies (called in index-light)
Namespace._configure = function(Type_, Service_, Enum_) {
    Type    = Type_;
    Service = Service_;
    Enum    = Enum_;
};

},{"./field":95,"./object":102,"./oneof":103,"./util":113}],102:[function(require,module,exports){
"use strict";
module.exports = ReflectionObject;

ReflectionObject.className = "ReflectionObject";

var util = require("./util");

var Root; // cyclic

/**
 * Constructs a new reflection object instance.
 * @classdesc Base class of all reflection objects.
 * @constructor
 * @param {string} name Object name
 * @param {Object.<string,*>} [options] Declared options
 * @abstract
 */
function ReflectionObject(name, options) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options && !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type {Object.<string,*>|undefined}
     */
    this.options = options; // toJSON

    /**
     * Parsed Options.
     * @type {Array.<Object.<string,*>>|undefined}
     */
    this.parsedOptions = null;

    /**
     * Unique name within its namespace.
     * @type {string}
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type {Namespace|null}
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type {boolean}
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type {string|null}
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type {string|null}
     */
    this.filename = null;
}

Object.defineProperties(ReflectionObject.prototype, {

    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
        get: function() {
            var ptr = this;
            while (ptr.parent !== null)
                ptr = ptr.parent;
            return ptr;
        }
    },

    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
        get: function() {
            var path = [ this.name ],
                ptr = this.parent;
            while (ptr) {
                path.unshift(ptr.name);
                ptr = ptr.parent;
            }
            return path.join(".");
        }
    }
});

/**
 * Converts this reflection object to its descriptor representation.
 * @returns {Object.<string,*>} Descriptor
 * @abstract
 */
ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {
    throw Error(); // not implemented, shouldn't happen
};

/**
 * Called when this object is added to a parent.
 * @param {ReflectionObject} parent Parent added to
 * @returns {undefined}
 */
ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
        this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
        root._handleAdd(this);
};

/**
 * Called when this object is removed from a parent.
 * @param {ReflectionObject} parent Parent removed from
 * @returns {undefined}
 */
ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
        root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
};

/**
 * Resolves this objects type references.
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;
    if (this.root instanceof Root)
        this.resolved = true; // only if part of a root
    return this;
};

/**
 * Gets an option value.
 * @param {string} name Option name
 * @returns {*} Option value or `undefined` if not set
 */
ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
        return this.options[name];
    return undefined;
};

/**
 * Sets an option.
 * @param {string} name Option name
 * @param {*} value Option value
 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === undefined)
        (this.options || (this.options = {}))[name] = value;
    return this;
};

/**
 * Sets a parsed option.
 * @param {string} name parsed Option name
 * @param {*} value Option value
 * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\empty, will add a new option with that value
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
    if (!this.parsedOptions) {
        this.parsedOptions = [];
    }
    var parsedOptions = this.parsedOptions;
    if (propName) {
        // If setting a sub property of an option then try to merge it
        // with an existing option
        var opt = parsedOptions.find(function (opt) {
            return Object.prototype.hasOwnProperty.call(opt, name);
        });
        if (opt) {
            // If we found an existing option - just merge the property value
            var newValue = opt[name];
            util.setProperty(newValue, propName, value);
        } else {
            // otherwise, create a new option, set it's property and add it to the list
            opt = {};
            opt[name] = util.setProperty({}, propName, value);
            parsedOptions.push(opt);
        }
    } else {
        // Always create a new option when setting the value of the option itself
        var newOpt = {};
        newOpt[name] = value;
        parsedOptions.push(newOpt);
    }
    return this;
};

/**
 * Sets multiple options.
 * @param {Object.<string,*>} options Options to set
 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
};

/**
 * Converts this instance to its string representation.
 * @returns {string} Class name[, space, full name]
 */
ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className,
        fullName  = this.fullName;
    if (fullName.length)
        return className + " " + fullName;
    return className;
};

// Sets up cyclic dependencies (called in index-light)
ReflectionObject._configure = function(Root_) {
    Root = Root_;
};

},{"./util":113}],103:[function(require,module,exports){
"use strict";
module.exports = OneOf;

// extends ReflectionObject
var ReflectionObject = require("./object");
((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

var Field = require("./field"),
    util  = require("./util");

/**
 * Constructs a new oneof instance.
 * @classdesc Reflected oneof.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Oneof name
 * @param {string[]|Object.<string,*>} [fieldNames] Field names
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);

    /* istanbul ignore if */
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");

    /**
     * Field names that belong to this oneof.
     * @type {string[]}
     */
    this.oneof = fieldNames || []; // toJSON, marker

    /**
     * Fields that belong to this oneof as an array for iteration.
     * @type {Field[]}
     * @readonly
     */
    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Oneof descriptor.
 * @interface IOneOf
 * @property {Array.<string>} oneof Oneof field names
 * @property {Object.<string,*>} [options] Oneof options
 */

/**
 * Constructs a oneof from a oneof descriptor.
 * @param {string} name Oneof name
 * @param {IOneOf} json Oneof descriptor
 * @returns {OneOf} Created oneof
 * @throws {TypeError} If arguments are invalid
 */
OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options, json.comment);
};

/**
 * Converts this oneof to a oneof descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IOneOf} Oneof descriptor
 */
OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , this.options,
        "oneof"   , this.oneof,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Adds the fields of the specified oneof to the parent if not already done so.
 * @param {OneOf} oneof The oneof
 * @returns {undefined}
 * @inner
 * @ignore
 */
function addFieldsToParent(oneof) {
    if (oneof.parent)
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
            if (!oneof.fieldsArray[i].parent)
                oneof.parent.add(oneof.fieldsArray[i]);
}

/**
 * Adds a field to this oneof and removes it from its current parent, if any.
 * @param {Field} field Field to add
 * @returns {OneOf} `this`
 */
OneOf.prototype.add = function add(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this; // field.parent remains null
    addFieldsToParent(this);
    return this;
};

/**
 * Removes a field from this oneof and puts it back to the oneof's parent.
 * @param {Field} field Field to remove
 * @returns {OneOf} `this`
 */
OneOf.prototype.remove = function remove(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    var index = this.fieldsArray.indexOf(field);

    /* istanbul ignore if */
    if (index < 0)
        throw Error(field + " is not a member of " + this);

    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);

    /* istanbul ignore else */
    if (index > -1) // theoretical
        this.oneof.splice(index, 1);

    field.partOf = null;
    return this;
};

/**
 * @override
 */
OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self = this;
    // Collect present fields
    for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
            field.partOf = self;
            self.fieldsArray.push(field);
        }
    }
    // Add not yet present fields
    addFieldsToParent(this);
};

/**
 * @override
 */
OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
            field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
};

/**
 * Decorator function as returned by {@link OneOf.d} (TypeScript).
 * @typedef OneOfDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} oneofName OneOf name
 * @returns {undefined}
 */

/**
 * OneOf decorator (TypeScript).
 * @function
 * @param {...string} fieldNames Field names
 * @returns {OneOfDecorator} Decorator function
 * @template T extends string
 */
OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length),
        index = 0;
    while (index < arguments.length)
        fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor)
            .add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
            get: util.oneOfGetter(fieldNames),
            set: util.oneOfSetter(fieldNames)
        });
    };
};

},{"./field":95,"./object":102,"./util":113}],104:[function(require,module,exports){
"use strict";
module.exports = Reader;

var util      = require("./util/minimal");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

},{"./util/minimal":115}],105:[function(require,module,exports){
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require("./reader");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require("./util/minimal");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();

},{"./reader":104,"./util/minimal":115}],106:[function(require,module,exports){
"use strict";
module.exports = Root;

// extends Namespace
var Namespace = require("./namespace");
((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

var Field   = require("./field"),
    Enum    = require("./enum"),
    OneOf   = require("./oneof"),
    util    = require("./util");

var Type,   // cyclic
    parse,  // might be excluded
    common; // "

/**
 * Constructs a new root namespace instance.
 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
 * @extends NamespaceBase
 * @constructor
 * @param {Object.<string,*>} [options] Top level options
 */
function Root(options) {
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type {Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type {string[]}
     */
    this.files = [];
}

/**
 * Loads a namespace descriptor into a root namespace.
 * @param {INamespace} json Nameespace descriptor
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
 * @returns {Root} Root namespace
 */
Root.fromJSON = function fromJSON(json, root) {
    if (!root)
        root = new Root();
    if (json.options)
        root.setOptions(json.options);
    return root.addJSON(json.nested);
};

/**
 * Resolves the path of an imported file, relative to the importing origin.
 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
 * @function
 * @param {string} origin The file name of the importing file
 * @param {string} target The file name being imported
 * @returns {string|null} Resolved path to `target` or `null` to skip the file
 */
Root.prototype.resolvePath = util.path.resolve;

/**
 * Fetch content from file path or url
 * This method exists so you can override it with your own logic.
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.fetch = util.fetch;

// A symbol-like function to safely signal synchronous loading
/* istanbul ignore next */
function SYNC() {} // eslint-disable-line no-empty-function

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} options Parse options
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    var self = this;
    if (!callback)
        return util.asPromise(load, self, filename, options);

    var sync = callback === SYNC; // undocumented

    // Finishes loading by calling the callback (exactly once)
    function finish(err, root) {
        /* istanbul ignore if */
        if (!callback)
            return;
        var cb = callback;
        callback = null;
        if (sync)
            throw err;
        cb(err, root);
    }

    // Bundled definition existence checking
    function getBundledFileName(filename) {
        var idx = filename.lastIndexOf("google/protobuf/");
        if (idx > -1) {
            var altname = filename.substring(idx);
            if (altname in common) return altname;
        }
        return null;
    }

    // Processes a single file
    function process(filename, source) {
        try {
            if (util.isString(source) && source.charAt(0) === "{")
                source = JSON.parse(source);
            if (!util.isString(source))
                self.setOptions(source.options).addJSON(source.nested);
            else {
                parse.filename = filename;
                var parsed = parse(source, self, options),
                    resolved,
                    i = 0;
                if (parsed.imports)
                    for (; i < parsed.imports.length; ++i)
                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))
                            fetch(resolved);
                if (parsed.weakImports)
                    for (i = 0; i < parsed.weakImports.length; ++i)
                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))
                            fetch(resolved, true);
            }
        } catch (err) {
            finish(err);
        }
        if (!sync && !queued)
            finish(null, self); // only once anyway
    }

    // Fetches a single file
    function fetch(filename, weak) {

        // Skip if already loaded / attempted
        if (self.files.indexOf(filename) > -1)
            return;
        self.files.push(filename);

        // Shortcut bundled definitions
        if (filename in common) {
            if (sync)
                process(filename, common[filename]);
            else {
                ++queued;
                setTimeout(function() {
                    --queued;
                    process(filename, common[filename]);
                });
            }
            return;
        }

        // Otherwise fetch from disk or network
        if (sync) {
            var source;
            try {
                source = util.fs.readFileSync(filename).toString("utf8");
            } catch (err) {
                if (!weak)
                    finish(err);
                return;
            }
            process(filename, source);
        } else {
            ++queued;
            self.fetch(filename, function(err, source) {
                --queued;
                /* istanbul ignore if */
                if (!callback)
                    return; // terminated meanwhile
                if (err) {
                    /* istanbul ignore else */
                    if (!weak)
                        finish(err);
                    else if (!queued) // can't be covered reliably
                        finish(null, self);
                    return;
                }
                process(filename, source);
            });
        }
    }
    var queued = 0;

    // Assembling the root namespace doesn't require working type
    // references anymore, so we can load everything in parallel
    if (util.isString(filename))
        filename = [ filename ];
    for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self.resolvePath("", filename[i]))
            fetch(resolved);

    if (sync)
        return self;
    if (!queued)
        finish(null, self);
    return undefined;
};
// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Promise<Root>} Promise
 * @variation 3
 */
// function load(filename:string, [options:IParseOptions]):Promise<Root>

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
 * @function Root#loadSync
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 */
Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util.isNode)
        throw Error("not supported");
    return this.load(filename, options, SYNC);
};

/**
 * @override
 */
Root.prototype.resolveAll = function resolveAll() {
    if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
            return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
};

// only uppercased (and thus conflict-free) children are exposed, see below
var exposeRe = /^[A-Z]/;

/**
 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
 * @param {Root} root Root instance
 * @param {Field} field Declaring extension field witin the declaring type
 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
 * @inner
 * @ignore
 */
function tryHandleExtension(root, field) {
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
    }
    return false;
}

/**
 * Called when any object is added to this root or its sub-namespaces.
 * @param {ReflectionObject} object Object added
 * @returns {undefined}
 * @private
 */
Root.prototype._handleAdd = function _handleAdd(object) {
    if (object instanceof Field) {

        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
            if (!tryHandleExtension(this, object))
                this.deferred.push(object);

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            object.parent[object.name] = object.values; // expose enum values as property of its parent

    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {

        if (object instanceof Type) // Try to handle any deferred extensions
            for (var i = 0; i < this.deferred.length;)
                if (tryHandleExtension(this, this.deferred[i]))
                    this.deferred.splice(i, 1);
                else
                    ++i;
        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
            this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
            object.parent[object.name] = object; // expose namespace as property of its parent
    }

    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
    // properties of namespaces just like static code does. This allows using a .d.ts generated for
    // a static module with reflection-based solutions where the condition is met.
};

/**
 * Called when any object is removed from this root or its sub-namespaces.
 * @param {ReflectionObject} object Object removed
 * @returns {undefined}
 * @private
 */
Root.prototype._handleRemove = function _handleRemove(object) {
    if (object instanceof Field) {

        if (/* an extension field */ object.extend !== undefined) {
            if (/* already handled */ object.extensionField) { // remove its sister field
                object.extensionField.parent.remove(object.extensionField);
                object.extensionField = null;
            } else { // cancel the extension
                var index = this.deferred.indexOf(object);
                /* istanbul ignore else */
                if (index > -1)
                    this.deferred.splice(index, 1);
            }
        }

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose enum values

    } else if (object instanceof Namespace) {

        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
            this._handleRemove(object._nestedArray[i]);

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose namespaces

    }
};

// Sets up cyclic dependencies (called in index-light)
Root._configure = function(Type_, parse_, common_) {
    Type   = Type_;
    parse  = parse_;
    common = common_;
};

},{"./enum":94,"./field":95,"./namespace":101,"./oneof":103,"./util":113}],107:[function(require,module,exports){
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

},{}],108:[function(require,module,exports){
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require("./rpc/service");

},{"./rpc/service":109}],109:[function(require,module,exports){
"use strict";
module.exports = Service;

var util = require("../util/minimal");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

},{"../util/minimal":115}],110:[function(require,module,exports){
"use strict";
module.exports = Service;

// extends Namespace
var Namespace = require("./namespace");
((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

var Method = require("./method"),
    util   = require("./util"),
    rpc    = require("./rpc");

/**
 * Constructs a new service instance.
 * @classdesc Reflected service.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Service name
 * @param {Object.<string,*>} [options] Service options
 * @throws {TypeError} If arguments are invalid
 */
function Service(name, options) {
    Namespace.call(this, name, options);

    /**
     * Service methods.
     * @type {Object.<string,Method>}
     */
    this.methods = {}; // toJSON, marker

    /**
     * Cached methods as an array.
     * @type {Method[]|null}
     * @private
     */
    this._methodsArray = null;
}

/**
 * Service descriptor.
 * @interface IService
 * @extends INamespace
 * @property {Object.<string,IMethod>} methods Method descriptors
 */

/**
 * Constructs a service from a service descriptor.
 * @param {string} name Service name
 * @param {IService} json Service descriptor
 * @returns {Service} Created service
 * @throws {TypeError} If arguments are invalid
 */
Service.fromJSON = function fromJSON(name, json) {
    var service = new Service(name, json.options);
    /* istanbul ignore else */
    if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
        service.addJSON(json.nested);
    service.comment = json.comment;
    return service;
};

/**
 * Converts this service to a service descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IService} Service descriptor
 */
Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , inherited && inherited.options || undefined,
        "methods" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},
        "nested"  , inherited && inherited.nested || undefined,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Methods of this service as an array for iteration.
 * @name Service#methodsArray
 * @type {Method[]}
 * @readonly
 */
Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
    }
});

function clearCache(service) {
    service._methodsArray = null;
    return service;
}

/**
 * @override
 */
Service.prototype.get = function get(name) {
    return this.methods[name]
        || Namespace.prototype.get.call(this, name);
};

/**
 * @override
 */
Service.prototype.resolveAll = function resolveAll() {
    var methods = this.methodsArray;
    for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
    return Namespace.prototype.resolve.call(this);
};

/**
 * @override
 */
Service.prototype.add = function add(object) {

    /* istanbul ignore if */
    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * @override
 */
Service.prototype.remove = function remove(object) {
    if (object instanceof Method) {

        /* istanbul ignore if */
        if (this.methods[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Creates a runtime service using the specified rpc implementation.
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
 */
Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r","c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
            m: method,
            q: method.resolvedRequestType.ctor,
            s: method.resolvedResponseType.ctor
        });
    }
    return rpcService;
};

},{"./method":100,"./namespace":101,"./rpc":108,"./util":113}],111:[function(require,module,exports){
"use strict";
module.exports = Type;

// extends Namespace
var Namespace = require("./namespace");
((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

var Enum      = require("./enum"),
    OneOf     = require("./oneof"),
    Field     = require("./field"),
    MapField  = require("./mapfield"),
    Service   = require("./service"),
    Message   = require("./message"),
    Reader    = require("./reader"),
    Writer    = require("./writer"),
    util      = require("./util"),
    encoder   = require("./encoder"),
    decoder   = require("./decoder"),
    verifier  = require("./verifier"),
    converter = require("./converter"),
    wrappers  = require("./wrappers");

/**
 * Constructs a new reflected message type instance.
 * @classdesc Reflected message type.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Message name
 * @param {Object.<string,*>} [options] Declared options
 */
function Type(name, options) {
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type {Object.<string,Field>}
     */
    this.fields = {};  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type {Object.<string,OneOf>}
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type {number[][]}
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type {boolean|undefined}
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type {Object.<number,Field>|null}
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type {Field[]|null}
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type {OneOf[]|null}
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type {Constructor<{}>}
     * @private
     */
    this._ctor = null;
}

Object.defineProperties(Type.prototype, {

    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
        get: function() {

            /* istanbul ignore if */
            if (this._fieldsById)
                return this._fieldsById;

            this._fieldsById = {};
            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                var field = this.fields[names[i]],
                    id = field.id;

                /* istanbul ignore if */
                if (this._fieldsById[id])
                    throw Error("duplicate id " + id + " in " + this);

                this._fieldsById[id] = field;
            }
            return this._fieldsById;
        }
    },

    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
        get: function() {
            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
    },

    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
        get: function() {
            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
    },

    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
        get: function() {
            return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {

            // Ensure proper prototype
            var prototype = ctor.prototype;
            if (!(prototype instanceof Message)) {
                (ctor.prototype = new Message()).constructor = ctor;
                util.merge(ctor.prototype, prototype);
            }

            // Classes and messages reference their reflected type
            ctor.$type = ctor.prototype.$type = this;

            // Mix in static methods
            util.merge(ctor, Message, true);

            this._ctor = ctor;

            // Messages have non-enumerable default values on their prototype
            var i = 0;
            for (; i < /* initializes */ this.fieldsArray.length; ++i)
                this._fieldsArray[i].resolve(); // ensures a proper value

            // Messages have non-enumerable getters and setters for each virtual oneof field
            var ctorProperties = {};
            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
                ctorProperties[this._oneofsArray[i].resolve().name] = {
                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
                };
            if (i)
                Object.defineProperties(ctor.prototype, ctorProperties);
        }
    }
});

/**
 * Generates a constructor function for the specified type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
Type.generateConstructor = function generateConstructor(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["p"], mtype.name);
    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen
            ("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen
            ("this%s=[]", util.safeProp(field.name));
    return gen
    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
        ("this[ks[i]]=p[ks[i]]");
    /* eslint-enable no-unexpected-multiline */
};

function clearCache(type) {
    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
    delete type.encode;
    delete type.decode;
    delete type.verify;
    return type;
}

/**
 * Message type descriptor.
 * @interface IType
 * @extends INamespace
 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
 * @property {Object.<string,IField>} fields Field descriptors
 * @property {number[][]} [extensions] Extension ranges
 * @property {number[][]} [reserved] Reserved ranges
 * @property {boolean} [group=false] Whether a legacy group or not
 */

/**
 * Creates a message type from a message type descriptor.
 * @param {string} name Message name
 * @param {IType} json Message type descriptor
 * @returns {Type} Created message type
 */
Type.fromJSON = function fromJSON(name, json) {
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields),
        i = 0;
    for (; i < names.length; ++i)
        type.add(
            ( typeof json.fields[names[i]].keyType !== "undefined"
            ? MapField.fromJSON
            : Field.fromJSON )(names[i], json.fields[names[i]])
        );
    if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
            var nested = json.nested[names[i]];
            type.add( // most to least likely
                ( nested.id !== undefined
                ? Field.fromJSON
                : nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
    if (json.group)
        type.group = true;
    if (json.comment)
        type.comment = json.comment;
    return type;
};

/**
 * Converts this message type to a message type descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IType} Message type descriptor
 */
Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"    , inherited && inherited.options || undefined,
        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},
        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
        "group"      , this.group || undefined,
        "nested"     , inherited && inherited.nested || undefined,
        "comment"    , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Type.prototype.resolveAll = function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
        fields[i++].resolve();
    var oneofs = this.oneofsArray; i = 0;
    while (i < oneofs.length)
        oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
};

/**
 * @override
 */
Type.prototype.get = function get(name) {
    return this.fields[name]
        || this.oneofs && this.oneofs[name]
        || this.nested && this.nested[name]
        || null;
};

/**
 * Adds a nested object to this type.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
 */
Type.prototype.add = function add(object) {

    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Field && object.extend === undefined) {
        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
        // The root object takes care of adding distinct sister-fields to the respective extended
        // type instead.

        // avoids calling the getter if not absolutely necessary because it's called quite frequently
        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
            throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);

        if (object.parent)
            object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {
        if (!this.oneofs)
            this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * Removes a nested object from this type.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this type
 */
Type.prototype.remove = function remove(object) {
    if (object instanceof Field && object.extend === undefined) {
        // See Type#add for the reason why extension fields are excluded here.

        /* istanbul ignore if */
        if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {

        /* istanbul ignore if */
        if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<{}>} Message instance
 */
Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
};

/**
 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
 * @returns {Type} `this`
 */
Type.prototype.setup = function setup() {
    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
    // multiple times (V8, soft-deopt prototype-check).

    var fullName = this.fullName,
        types    = [];
    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);

    // Replace setup methods with type-specific generated functions
    this.encode = encoder(this)({
        Writer : Writer,
        types  : types,
        util   : util
    });
    this.decode = decoder(this)({
        Reader : Reader,
        types  : types,
        util   : util
    });
    this.verify = verifier(this)({
        types : types,
        util  : util
    });
    this.fromObject = converter.fromObject(this)({
        types : types,
        util  : util
    });
    this.toObject = converter.toObject(this)({
        types : types,
        util  : util
    });

    // Inject custom wrappers for common types
    var wrapper = wrappers[fullName];
    if (wrapper) {
        var originalThis = Object.create(this);
        // if (wrapper.fromObject) {
            originalThis.fromObject = this.fromObject;
            this.fromObject = wrapper.fromObject.bind(originalThis);
        // }
        // if (wrapper.toObject) {
            originalThis.toObject = this.toObject;
            this.toObject = wrapper.toObject.bind(originalThis);
        // }
    }

    return this;
};

/**
 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encode = function encode_setup(message, writer) {
    return this.setup().encode(message, writer); // overrides this method
};

/**
 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
};

/**
 * Decodes a message of this type.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @param {number} [length] Length of the message, if known beforehand
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError<{}>} If required fields are missing
 */
Type.prototype.decode = function decode_setup(reader, length) {
    return this.setup().decode(reader, length); // overrides this method
};

/**
 * Decodes a message of this type preceeded by its byte length as a varint.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError} If required fields are missing
 */
Type.prototype.decodeDelimited = function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
        reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
};

/**
 * Verifies that field values are valid and that required fields are present.
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {null|string} `null` if valid, otherwise the reason why it is not
 */
Type.prototype.verify = function verify_setup(message) {
    return this.setup().verify(message); // overrides this method
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object to convert
 * @returns {Message<{}>} Message instance
 */
Type.prototype.fromObject = function fromObject(object) {
    return this.setup().fromObject(object);
};

/**
 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
 * @interface IConversionOptions
 * @property {Function} [longs] Long conversion type.
 * Valid values are `String` and `Number` (the global types).
 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
 * @property {Function} [enums] Enum value conversion type.
 * Only valid value is `String` (the global type).
 * Defaults to copy the present value, which is the numeric id.
 * @property {Function} [bytes] Bytes value conversion type.
 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
 * @property {boolean} [defaults=false] Also sets default values on the resulting object
 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
 */

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 */
Type.prototype.toObject = function toObject(message, options) {
    return this.setup().toObject(message, options);
};

/**
 * Decorator function as returned by {@link Type.d} (TypeScript).
 * @typedef TypeDecorator
 * @type {function}
 * @param {Constructor<T>} target Target constructor
 * @returns {undefined}
 * @template T extends Message<T>
 */

/**
 * Type decorator (TypeScript).
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {TypeDecorator<T>} Decorator function
 * @template T extends Message<T>
 */
Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
        util.decorateType(target, typeName);
    };
};

},{"./converter":91,"./decoder":92,"./encoder":93,"./enum":94,"./field":95,"./mapfield":98,"./message":99,"./namespace":101,"./oneof":103,"./reader":104,"./service":110,"./util":113,"./verifier":116,"./wrappers":117,"./writer":118}],112:[function(require,module,exports){
"use strict";

/**
 * Common type constants.
 * @namespace
 */
var types = exports;

var util = require("./util");

var s = [
    "double",   // 0
    "float",    // 1
    "int32",    // 2
    "uint32",   // 3
    "sint32",   // 4
    "fixed32",  // 5
    "sfixed32", // 6
    "int64",    // 7
    "uint64",   // 8
    "sint64",   // 9
    "fixed64",  // 10
    "sfixed64", // 11
    "bool",     // 12
    "string",   // 13
    "bytes"     // 14
];

function bake(values, offset) {
    var i = 0, o = {};
    offset |= 0;
    while (i < values.length) o[s[i + offset]] = values[i++];
    return o;
}

/**
 * Basic type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 * @property {number} bytes=2 Ldelim wire type
 */
types.basic = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2,
    /* bytes    */ 2
]);

/**
 * Basic type defaults.
 * @type {Object.<string,*>}
 * @const
 * @property {number} double=0 Double default
 * @property {number} float=0 Float default
 * @property {number} int32=0 Int32 default
 * @property {number} uint32=0 Uint32 default
 * @property {number} sint32=0 Sint32 default
 * @property {number} fixed32=0 Fixed32 default
 * @property {number} sfixed32=0 Sfixed32 default
 * @property {number} int64=0 Int64 default
 * @property {number} uint64=0 Uint64 default
 * @property {number} sint64=0 Sint32 default
 * @property {number} fixed64=0 Fixed64 default
 * @property {number} sfixed64=0 Sfixed64 default
 * @property {boolean} bool=false Bool default
 * @property {string} string="" String default
 * @property {Array.<number>} bytes=Array(0) Bytes default
 * @property {null} message=null Message default
 */
types.defaults = bake([
    /* double   */ 0,
    /* float    */ 0,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 0,
    /* sfixed32 */ 0,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 0,
    /* sfixed64 */ 0,
    /* bool     */ false,
    /* string   */ "",
    /* bytes    */ util.emptyArray,
    /* message  */ null
]);

/**
 * Basic long type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 */
types.long = bake([
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1
], 7);

/**
 * Allowed types for map keys with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 */
types.mapKey = bake([
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2
], 2);

/**
 * Allowed types for packed repeated fields with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 */
types.packed = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0
]);

},{"./util":113}],113:[function(require,module,exports){
"use strict";

/**
 * Various utility functions.
 * @namespace
 */
var util = module.exports = require("./util/minimal");

var roots = require("./roots");

var Type, // cyclic
    Enum;

util.codegen = require("@protobufjs/codegen");
util.fetch   = require("@protobufjs/fetch");
util.path    = require("@protobufjs/path");

/**
 * Node's fs module if available.
 * @type {Object.<string,*>}
 */
util.fs = util.inquire("fs");

/**
 * Converts an object's values to an array.
 * @param {Object.<string,*>} object Object to convert
 * @returns {Array.<*>} Converted array
 */
util.toArray = function toArray(object) {
    if (object) {
        var keys  = Object.keys(object),
            array = new Array(keys.length),
            index = 0;
        while (index < keys.length)
            array[index] = object[keys[index++]];
        return array;
    }
    return [];
};

/**
 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
 * @param {Array.<*>} array Array to convert
 * @returns {Object.<string,*>} Converted object
 */
util.toObject = function toObject(array) {
    var object = {},
        index  = 0;
    while (index < array.length) {
        var key = array[index++],
            val = array[index++];
        if (val !== undefined)
            object[key] = val;
    }
    return object;
};

var safePropBackslashRe = /\\/g,
    safePropQuoteRe     = /"/g;

/**
 * Tests whether the specified name is a reserved word in JS.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
util.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
};

/**
 * Returns a safe property accessor for the specified property name.
 * @param {string} prop Property name
 * @returns {string} Safe accessor
 */
util.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
    return "." + prop;
};

/**
 * Converts the first character of a string to upper case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
};

var camelCaseRe = /_([a-z])/g;

/**
 * Converts a string to camel case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.camelCase = function camelCase(str) {
    return str.substring(0, 1)
         + str.substring(1)
               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });
};

/**
 * Compares reflected fields by id.
 * @param {Field} a First field
 * @param {Field} b Second field
 * @returns {number} Comparison value
 */
util.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
};

/**
 * Decorator helper for types (TypeScript).
 * @param {Constructor<T>} ctor Constructor function
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {Type} Reflected type
 * @template T extends Message<T>
 * @property {Root} root Decorators root
 */
util.decorateType = function decorateType(ctor, typeName) {

    /* istanbul ignore if */
    if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
            util.decorateRoot.remove(ctor.$type);
            ctor.$type.name = typeName;
            util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
    }

    /* istanbul ignore next */
    if (!Type)
        Type = require("./type");

    var type = new Type(typeName || ctor.name);
    util.decorateRoot.add(type);
    type.ctor = ctor; // sets up .encode, .decode etc.
    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
    return type;
};

var decorateEnumIndex = 0;

/**
 * Decorator helper for enums (TypeScript).
 * @param {Object} object Enum object
 * @returns {Enum} Reflected enum
 */
util.decorateEnum = function decorateEnum(object) {

    /* istanbul ignore if */
    if (object.$type)
        return object.$type;

    /* istanbul ignore next */
    if (!Enum)
        Enum = require("./enum");

    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
    return enm;
};


/**
 * Sets the value of a property by property path. If a value already exists, it is turned to an array
 * @param {Object.<string,*>} dst Destination object
 * @param {string} path dot '.' delimited path of the property to set
 * @param {Object} value the value to set
 * @returns {Object.<string,*>} Destination object
 */
util.setProperty = function setProperty(dst, path, value) {
    function setProp(dst, path, value) {
        var part = path.shift();
        if (path.length > 0) {
            dst[part] = setProp(dst[part] || {}, path, value);
        } else {
            var prevValue = dst[part];
            if (prevValue)
                value = [].concat(prevValue).concat(value);
            dst[part] = value;
        }
        return dst;
    }

    if (typeof dst !== "object")
        throw TypeError("dst must be an object");
    if (!path)
        throw TypeError("path must be specified");

    path = path.split(".");
    return setProp(dst, path, value);
};

/**
 * Decorator root (TypeScript).
 * @name util.decorateRoot
 * @type {Root}
 * @readonly
 */
Object.defineProperty(util, "decorateRoot", {
    get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require("./root"))());
    }
});

},{"./enum":94,"./root":106,"./roots":107,"./type":111,"./util/minimal":115,"@protobufjs/codegen":79,"@protobufjs/fetch":81,"@protobufjs/path":84}],114:[function(require,module,exports){
"use strict";
module.exports = LongBits;

var util = require("../util/minimal");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

},{"../util/minimal":115}],115:[function(require,module,exports){
(function (global){(function (){
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require("@protobufjs/aspromise");

// converts to / from base64 encoded strings
util.base64 = require("@protobufjs/base64");

// base class of rpc.Service
util.EventEmitter = require("@protobufjs/eventemitter");

// float handling accross browsers
util.float = require("@protobufjs/float");

// requires modules optionally and hides the call from bundlers
util.inquire = require("@protobufjs/inquire");

// converts to / from utf8 encoded strings
util.utf8 = require("@protobufjs/utf8");

// provides a node-like buffer pool in the browser
util.pool = require("@protobufjs/pool");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require("./longbits");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./longbits":114,"@protobufjs/aspromise":77,"@protobufjs/base64":78,"@protobufjs/eventemitter":80,"@protobufjs/float":82,"@protobufjs/inquire":83,"@protobufjs/pool":85,"@protobufjs/utf8":86}],116:[function(require,module,exports){
"use strict";
module.exports = verifier;

var Enum      = require("./enum"),
    util      = require("./util");

function invalid(field, expected) {
    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:"+field.keyType+"}" : "") + " expected";
}

/**
 * Generates a partial value verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyValue(gen, field, fieldIndex, ref) {
    /* eslint-disable no-unexpected-multiline */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(%s){", ref)
                ("default:")
                    ("return%j", invalid(field, "enum value"));
            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen
                ("case %i:", field.resolvedType.values[keys[j]]);
            gen
                    ("break")
            ("}");
        } else {
            gen
            ("{")
                ("var e=types[%i].verify(%s);", fieldIndex, ref)
                ("if(e)")
                    ("return%j+e", field.name + ".")
            ("}");
        }
    } else {
        switch (field.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32": gen
                ("if(!util.isInteger(%s))", ref)
                    ("return%j", invalid(field, "integer"));
                break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)
                    ("return%j", invalid(field, "integer|Long"));
                break;
            case "float":
            case "double": gen
                ("if(typeof %s!==\"number\")", ref)
                    ("return%j", invalid(field, "number"));
                break;
            case "bool": gen
                ("if(typeof %s!==\"boolean\")", ref)
                    ("return%j", invalid(field, "boolean"));
                break;
            case "string": gen
                ("if(!util.isString(%s))", ref)
                    ("return%j", invalid(field, "string"));
                break;
            case "bytes": gen
                ("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
                    ("return%j", invalid(field, "buffer"));
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a partial key verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyKey(gen, field, ref) {
    /* eslint-disable no-unexpected-multiline */
    switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32": gen
            ("if(!util.key32Re.test(%s))", ref)
                ("return%j", invalid(field, "integer key"));
            break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64": gen
            ("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
                ("return%j", invalid(field, "integer|Long key"));
            break;
        case "bool": gen
            ("if(!util.key2Re.test(%s))", ref)
                ("return%j", invalid(field, "boolean key"));
            break;
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a verifier specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function verifier(mtype) {
    /* eslint-disable no-unexpected-multiline */

    var gen = util.codegen(["m"], mtype.name + "$verify")
    ("if(typeof m!==\"object\"||m===null)")
        ("return%j", "object expected");
    var oneofs = mtype.oneofsArray,
        seenFirstField = {};
    if (oneofs.length) gen
    ("var p={}");

    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            ref   = "m" + util.safeProp(field.name);

        if (field.optional) gen
        ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

        // map fields
        if (field.map) { gen
            ("if(!util.isObject(%s))", ref)
                ("return%j", invalid(field, "object"))
            ("var k=Object.keys(%s)", ref)
            ("for(var i=0;i<k.length;++i){");
                genVerifyKey(gen, field, "k[i]");
                genVerifyValue(gen, field, i, ref + "[k[i]]")
            ("}");

        // repeated fields
        } else if (field.repeated) { gen
            ("if(!Array.isArray(%s))", ref)
                ("return%j", invalid(field, "array"))
            ("for(var i=0;i<%s.length;++i){", ref);
                genVerifyValue(gen, field, i, ref + "[i]")
            ("}");

        // required or present fields
        } else {
            if (field.partOf) {
                var oneofProp = util.safeProp(field.partOf.name);
                if (seenFirstField[field.partOf.name] === 1) gen
            ("if(p%s===1)", oneofProp)
                ("return%j", field.partOf.name + ": multiple values");
                seenFirstField[field.partOf.name] = 1;
                gen
            ("p%s=1", oneofProp);
            }
            genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen
        ("}");
    }
    return gen
    ("return null");
    /* eslint-enable no-unexpected-multiline */
}
},{"./enum":94,"./util":113}],117:[function(require,module,exports){
"use strict";

/**
 * Wrappers for common types.
 * @type {Object.<string,IWrapper>}
 * @const
 */
var wrappers = exports;

var Message = require("./message");

/**
 * From object converter part of an {@link IWrapper}.
 * @typedef WrapperFromObjectConverter
 * @type {function}
 * @param {Object.<string,*>} object Plain object
 * @returns {Message<{}>} Message instance
 * @this Type
 */

/**
 * To object converter part of an {@link IWrapper}.
 * @typedef WrapperToObjectConverter
 * @type {function}
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @this Type
 */

/**
 * Common type wrapper part of {@link wrappers}.
 * @interface IWrapper
 * @property {WrapperFromObjectConverter} [fromObject] From object converter
 * @property {WrapperToObjectConverter} [toObject] To object converter
 */

// Custom wrapper for Any
wrappers[".google.protobuf.Any"] = {

    fromObject: function(object) {

        // unwrap value type if mapped
        if (object && object["@type"]) {
             // Only use fully qualified type name after the last '/'
            var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type) {
                // type_url does not accept leading "."
                var type_url = object["@type"].charAt(0) === "." ?
                    object["@type"].substr(1) : object["@type"];
                // type_url prefix is optional, but path seperator is required
                if (type_url.indexOf("/") === -1) {
                    type_url = "/" + type_url;
                }
                return this.create({
                    type_url: type_url,
                    value: type.encode(type.fromObject(object)).finish()
                });
            }
        }

        return this.fromObject(object);
    },

    toObject: function(message, options) {

        // Default prefix
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";

        // decode value if requested and unmapped
        if (options && options.json && message.type_url && message.value) {
            // Only use fully qualified type name after the last '/'
            name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
            // Separate the prefix used
            prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type)
                message = type.decode(message.value);
        }

        // wrap value if unmapped
        if (!(message instanceof this.ctor) && message instanceof Message) {
            var object = message.$type.toObject(message, options);
            var messageName = message.$type.fullName[0] === "." ?
                message.$type.fullName.substr(1) : message.$type.fullName;
            // Default to type.googleapis.com prefix if no prefix is used
            if (prefix === "") {
                prefix = googleApi;
            }
            name = prefix + messageName;
            object["@type"] = name;
            return object;
        }

        return this.toObject(message, options);
    }
};

},{"./message":99}],118:[function(require,module,exports){
"use strict";
module.exports = Writer;

var util      = require("./util/minimal");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};

},{"./util/minimal":115}],119:[function(require,module,exports){
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require("./writer");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require("./util/minimal");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();

},{"./util/minimal":115,"./writer":118}],120:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function () {
    return _nil.default;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _version.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

var _nil = _interopRequireDefault(require("./nil.js"));

var _version = _interopRequireDefault(require("./version.js"));

var _validate = _interopRequireDefault(require("./validate.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./nil.js":122,"./parse.js":123,"./stringify.js":127,"./v1.js":128,"./v3.js":129,"./v4.js":131,"./v5.js":132,"./validate.js":133,"./version.js":134}],121:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;
},{}],122:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports.default = _default;
},{}],123:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports.default = _default;
},{"./validate.js":133}],124:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports.default = _default;
},{}],125:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
},{}],126:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;
},{}],127:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports.default = _default;
},{"./validate.js":133}],128:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports.default = _default;
},{"./rng.js":125,"./stringify.js":127}],129:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
},{"./md5.js":121,"./v35.js":130}],130:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
},{"./parse.js":123,"./stringify.js":127}],131:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports.default = _default;
},{"./rng.js":125,"./stringify.js":127}],132:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
},{"./sha1.js":126,"./v35.js":130}],133:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regex = _interopRequireDefault(require("./regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports.default = _default;
},{"./regex.js":124}],134:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports.default = _default;
},{"./validate.js":133}],135:[function(require,module,exports){
const { EventEmitter } = require("events");
const { Device } = require("mediasoup-client");
const { v4: uuidv4 } = require("uuid");

const { ClientMonitor } = require("@observertc/client-monitor-js");

ClientMonitor.setLogLevel('debug');

const roomId = document.querySelector("span#roomId").textContent;
const observerAddress = document.querySelector("span#observerAddress").textContent;
console.log("roomId", roomId);
const localClientId = uuidv4();
const monitor = ClientMonitor.create({
    collectingPeriodInMs: 1000,
    samplingPeriodInMs: 5000,
    sendingPeriodInMs: 10000,
    sampler: {
        roomId,
        clientId: localClientId,
    },
    sender: {
        websocket: {
            urls: [`ws://${observerAddress}/samples/myServiceId/mediasoup-app`]
        }
    }
});

monitor.events.onStatsCollected(() => {
    const storage = monitor.storage;
    const trackMetrics = new Map();
    const putMetrics = (trackId, metrics) => {
        let trackMetric = trackMetrics.get(trackId);
        if (!trackMetric) {
            trackMetric = [];
            trackMetrics.set(trackId, trackMetric);
        }
        trackMetric.push(metrics);
    };
    for (const inboundRtp of storage.inboundRtps()) {
        const trackId = inboundRtp.getTrackId();
        if (!trackId) continue;
        const { bytesReceived, packetsReceived, kind, ssrc } = inboundRtp.stats;
        const { clockRate } = inboundRtp.getCodec()?.stats || {};
        const { roundTripTime } = inboundRtp.getRemoteOutboundRtp()?.stats || {};
        const metrics = {
            ssrc,
            kind,
            bytesReceived,
            packetsReceived,
            clockRate,
            roundTripTime,
        };
        putMetrics(trackId, metrics);
    }

    for (const outboundRtp of storage.outboundRtps()) {
        const trackId = outboundRtp.getTrackId();
        if (!trackId) continue;
        const { bytesSent, packetsSent, kind, ssrc } = outboundRtp.stats;
        const { clockRate } = outboundRtp.getCodec()?.stats || {};
        const { roundTripTime } = outboundRtp.getRemoteInboundRtp()?.stats || {};
        const metrics = {
            ssrc,
            kind,
            bytesSent,
            packetsSent,
            clockRate,
            roundTripTime,
        };
        putMetrics(trackId, metrics);
    }
    for (const [trackId, trackMetric] of trackMetrics.entries()) {
        const lines = [];
        trackMetric.forEach(metrics => {
            lines.push(...Object.entries(metrics).map(([k,v]) => `${k}: ${v}`));
            lines.push(``);
        });
        const element = document.querySelector(`div[id='${trackId}']`);
        if (!element) {
            continue;
        }
        element.innerHTML = lines.join("<br />");
    }
});

const ON_CONSUMER_CREATED_EVENT_NAME = "ConsumerCreated";
const ON_CONSUMER_REMOVED_EVENT_NAME = "ConsumerRemoved";
class Comlink {
    static builder() {
        const comlink = new Comlink();
        const result = {
            withIceServerUrl: (iceServerUrl) => {
                client._iceServerUrl = iceServerUrl;
                return result;
            },
            withWebsocket: (ws) => {
                ws.onmessage = event => {
                    comlink._receive(event);
                }
                comlink._ws = ws;
                return result;
            },
            onConsumerCreated: (listener) => {
                comlink._emitter.on(ON_CONSUMER_CREATED_EVENT_NAME, listener);
                return result;
            },
            onConsumerRemoved: (listener) => {
                comlink._emitter.on(ON_CONSUMER_REMOVED_EVENT_NAME, listener);
                return result;
            },
            build: async () => {
                return new Promise(resolve => {
                    let tried = 0;
                    const createTimer = () => setTimeout(() => {
                        if (comlink._ws.readyState === WebSocket.OPEN) {
                            console.log("Websocket is connected");
                            resolve(comlink);
                        } else {
                            console.log("Connection is not ready. tried: ", ++tried);
                            createTimer();
                        }
                    }, 1000);
                    createTimer();
                });
            },
        };
        return result;
    }

    constructor() {
        this._emitter = new EventEmitter();
        this._requests = new Map();
        this._ws = null;
    }

    requestCapabilities() {
        return this._sendRequestAndPromise({
            messageType: "CapabilitiesRequest"
        });
    }

    requestCreateProducer({ kind, rtpParameters, userId }) {
        return this._sendRequestAndPromise({
            messageType: "CreateProducerRequest",
            payload: {
                kind,
                rtpParameters,
                userId,
            }
        });
    }

    requestPauseProducer({ producerId }) {
        return this._sendRequestAndPromise({
            messageType: "PauseProducerRequest",
            payload: {
                producerId,
            }
        });
    }

    requestResumeProducer({ producerId }) {
        return this._sendRequestAndPromise({
            messageType: "ResumeProducerRequest",
            payload: {
                producerId,
            }
        });
    }

    sendTransportConnectedNotification({ role, dtlsParameters }) {
        this._ws.send(JSON.stringify({
            messageType: "TransportConnected",
            payload: {
                role,
                dtlsParameters,
            }
        }));
    }

    sendRtpCapabilities({ rtpCapabilities }) {
        this._ws.send(JSON.stringify({
            messageType: "RtpCapabilities",
            payload: {
                rtpCapabilities,
            }
        }));
    }

    requestTransportInfo({ role }) {
        return this._sendRequestAndPromise({
            messageType: "TransportInfoRequest",
            payload: {
                role,
            }
        });
    }

    _receive(event) {
        let message;
        try {
            message = JSON.parse(event.data);
        } catch (err) {
            console.warn(`Cannot parse data ${event.data}`);
            return;
        }
        const { messageType, payload } = message;
        if (!messageType) {
            console.warn(`Undefined message type`);
            return;
        }
        if (0 < this._emitter.listenerCount(messageType)) {
            this._emitter.emit(messageType, payload);
            return;
        }
        if (!payload) {
            console.warn(`Cannot find listener for message type: ${messageType}`);
            return;
        }
        const { requestId, ...values } = payload;
        const resolve = this._requests.get(requestId);
        if (resolve) {
            const response = {...values};
            // console.warn(`resolve request with response`, response);
            resolve(response);
            return;
        }
        console.warn(`Cannot find listener for message type: ${messageType}`);
    }

    _sendRequestAndPromise({messageType, payload}) {
        const requestId = uuidv4();
        const message = JSON.stringify({
            messageType,
            payload: {
                requestId,
                ...payload,
            },
        });
        const promise = new Promise(resolve => {
            this._requests.set(requestId, (...args) => {
                resolve(...args);
            })
        });
        this._ws.send(message);
        return promise;
    }
}

const possibleUserIds = ['Alice', 'Bob', 'Eve', 'Oscar', 'Homer', 'Maggie', 'Bart']
const userId = possibleUserIds[Math.floor(Math.random() * possibleUserIds.length)];
document.querySelector("span#userId").textContent = userId;
// const iceServerUrl = "stun:stun.l.google.com:19302";
const iceServerUrl = "turn:turn.example.com:443?transport=tcp";
// const roomId = "test";
const websocket = new WebSocket(`ws://localhost:5959?roomId=${roomId}&userId=${userId}&clientId=${localClientId}`);
let rcvTransport;
let sndTransport;
const remoteStreams = new Map();
const consumers = new Map();
const producers = new Map();
async function main() {
    const comlink = await Comlink.builder()
        .withWebsocket(websocket)
        .onConsumerCreated(async ({
            clientId: remoteClientId,
            consumerId,
            remoteProducerId,
            kind,
            rtpParameters,
            appData,
        }) => {
            console.warn(`Consumer is received ${consumerId} from client ${remoteClientId}`, { remoteClientId,
            consumerId,
            remoteProducerId,
            kind,
            rtpParameters,
            appData});
            const { userId } = appData;
            const consumer = await rcvTransport.consume({
                id: consumerId,
                producerId: remoteProducerId,
                kind,
                rtpParameters,
                appData,
            });
            const track = consumer.track;
            monitor.addTrackRelation({
                trackId: track.id,
                sfuStreamId: remoteProducerId,
                sfuSinkId: consumerId,
            });
            consumer.observer.on("close", () => {
                monitor.removeTrackRelation(track.id);
                consumers.delete(consumer.id);
            });
            consumers.set(consumer.id, consumer);
            let remoteStream = remoteStreams.get(remoteClientId);
            if (!remoteStream) {
                remoteStream = new MediaStream();
                remoteStreams.set(remoteClientId, remoteStream);
                const article = document.createElement("article");
                article.setAttribute("id", remoteClientId);
                const userElement = document.createElement("h3");
                userElement.textContent = "User: " + userId
                article.appendChild(userElement);
                document.querySelector(`section#remoteClients`).appendChild(article);
            }
            const article = document.querySelector(`section#remoteClients article[id='${remoteClientId}']`);
            if (track.kind === "audio") {
                remoteStream.addTrack(track);
            } else if (track.kind === "video") {
                remoteStream.addTrack(track);
                const video = document.createElement("video");
                video.setAttribute("width", 240);
                video.setAttribute("height", 120);
                video.setAttribute("autoplay", true);
                video.playsinline = true;
                video.controls = false;
                if ('srcObject' in video) video.srcObject = remoteStream;
                else video.src = URL.createObjectURL(remoteStream);
                article.appendChild(video);
            }
            const metrics = document.createElement("div");
            metrics.setAttribute("id", track.id);
            metrics.setAttribute("class", "stats");
            article.appendChild(metrics);
        })
        .onConsumerRemoved(({ consumerId }) => {
            const consumer = consumers.get(consumerId);
            const { clientId: remoteClientId } = consumer.appData;
            const article = document.querySelector(`section#remoteClients article[id='${remoteClientId}']`);
            document.querySelector(`section#remoteClients`).removeChild(article);
            if (!consumer.closed) {
                consumer.close();
            }
        })
        .build();
    const device = new Device();
    const { rtpCapabilities: routerRtpCapabilities } = await comlink.requestCapabilities();
    console.log(`Got routerCapabilities:`, routerRtpCapabilities);
    await device.load({ routerRtpCapabilities });
    console.log("Device is loaded", device.loaded, device.rtpCapabilities);
    comlink.sendRtpCapabilities({
        rtpCapabilities: device.rtpCapabilities,
    });
    const sndTransportInfo = Object.assign(await comlink.requestTransportInfo({
            role: "producers",
        }),
        { 
            iceServers: [{
                urls : ['turn:turn.example.com:443?transport=tcp'],
                username   : 'example',
                credential : 'example'
            }],
        }
        // { iceServers: [{ urls: iceServerUrl }] }
    );
    console.log(`sndTransportInfo`, sndTransportInfo);
    sndTransport = device.createSendTransport(sndTransportInfo);
    console.log(`sndTransport ${sndTransport.id} is created`, sndTransport);
    sndTransport.on("connect", async ({ dtlsParameters }, callback, errback) => {
        await comlink.sendTransportConnectedNotification({
            role: "producers",
            dtlsParameters
        });
        callback();
    });
    sndTransport.on("produce", async ({ kind, rtpParameters, appData }, callback, errback) => {
        try {
            const { userId } = appData;
            const { producerId } = await comlink.requestCreateProducer({
                kind,
                rtpParameters,
                userId,
            });
            callback({ id: producerId });
        } catch (err) {
            errback(err);
        }
    });
    const collectorId = uuidv4();
    monitor.addStatsCollector({
        id: collectorId,
        label: "sndTransport",
        getStats: sndTransport.getStats.bind(sndTransport),
    });
    console.log(`sndTransport with ${collectorId} has been added to the monitor`);
    const rcvTransportInfo = Object.assign(await comlink.requestTransportInfo({
            role: "consumers",
        }), 
        { 
            iceServers: [{
                urls : ['turn:turn.example.com:443?transport=tcp'],
                username   : 'example',
                credential : 'example'
            }],
        }
    );
    
    rcvTransport = device.createRecvTransport(rcvTransportInfo);
    console.log(`rcvTransport ${rcvTransport.id} is created`, rcvTransport);
    rcvTransport.on("connect", async ({ dtlsParameters }, callback, errback) => {
        await comlink.sendTransportConnectedNotification({
            role: "consumers",
            dtlsParameters
        });
        callback();
    });
    monitor.addStatsCollector({
        id: uuidv4(),
        label: "rcvTransport",
        getStats: rcvTransport.getStats.bind(rcvTransport),
    });
    const localStream = await navigator.mediaDevices.getUserMedia({'video':true,'audio':true});
    console.log('Got MediaStream:', localStream, localStream.getTracks());
    const videoElement = document.querySelector('video#localVideo');
    videoElement.srcObject = localStream;
    localStream.getTracks().forEach(async track => {
        try {
            const producer = await sndTransport.produce({
                track,
                appData: {
                    userId,
                },
                // codec,
            });
            monitor.addTrackRelation({
                trackId: track.id,
                sfuStreamId: producer.id,
            });
            producer.observer.on("close", () => {
                monitor.removeTrackRelation(track.id);
                producers.delete(producer.id);
            })
            producers.set(producer.id, producer);
            const li = document.createElement("li");
            li.textContent = `${track.kind}: ${track.label}`
            document.querySelector(`ul#lablels`).appendChild(li);

            const localMetrics = document.querySelector("div[id=localMetrics]");
            const metrics = document.createElement("div");
            metrics.setAttribute("id", track.id);
            localMetrics.appendChild(metrics);
        } catch (err) {
            console.warn(err);
        }
    });
    const audioController = document.querySelector(`button[id='audioController']`);
    let muted = false;
    audioController.onclick = async () => {
        const audioProducers = Array.from(producers.values())
            .filter(producer => producer.kind === "audio");
        if (audioProducers.length < 1) {
            console.warn("There is no audio producer to mute");
            return;
        }
        audioController.disabled = true;
        try {
            let promises = [];
            if (muted) {
                promises = audioProducers.map(producer => {
                    return comlink.requestResumeProducer({ producerId: producer.id });
                });
            } else {
                promises = audioProducers.map(producer => {
                    return comlink.requestPauseProducer({ producerId: producer.id });
                });
            }
            await Promise.all(promises);
            muted = !muted;
            audioController.innerHTML = muted ? "UnMute" : "Mute";
        } catch (err) {
            console.error("Error occurred while mute / unmute audio", err);
        } finally {
            audioController.disabled = false;
        }
    };
    console.log("Audio Controller is initialized");
    const videoController = document.querySelector(`button[id='videoController']`);
    let paused = false;
    videoController.onclick = async () => {
        const videoProducers = Array.from(producers.values())
            .filter(producer => producer.kind === "video");
        if (videoProducers.length < 1) {
            console.warn("There is no audio producer to mute");
            return;
        }
        videoController.disabled = true;
        try {
            let promises = [];
            if (paused) {
                promises = videoProducers.map(producer => {
                    return comlink.requestResumeProducer({ producerId: producer.id });
                });
            } else {
                promises = videoProducers.map(producer => {
                    return comlink.requestPauseProducer({ producerId: producer.id });
                });
            }
            await Promise.all(promises);
            paused = !paused;
            videoController.innerHTML = paused ? "Resume" : "Pause";
        } catch (err) {
            console.error("Error occurred while pause / resume video", err);
        } finally {
            videoController.disabled = false;
        }
    }
    console.log("Video Controller is initialized");
}

main();

},{"@observertc/client-monitor-js":24,"events":1,"mediasoup-client":168,"uuid":178}],136:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
class AwaitQueue {
    constructor({ ClosedErrorClass = Error, StoppedErrorClass = Error } = {
        ClosedErrorClass: Error,
        StoppedErrorClass: Error
    }) {
        // Closed flag.
        this.closed = false;
        // Queue of pending tasks.
        this.pendingTasks = [];
        // Error class used when rejecting a task due to AwaitQueue being closed.
        this.ClosedErrorClass = Error;
        // Error class used when rejecting a task due to AwaitQueue being stopped.
        this.StoppedErrorClass = Error;
        this.ClosedErrorClass = ClosedErrorClass;
        this.StoppedErrorClass = StoppedErrorClass;
    }
    /**
     * The number of ongoing enqueued tasks.
     */
    get size() {
        return this.pendingTasks.length;
    }
    /**
     * Closes the AwaitQueue. Pending tasks will be rejected with ClosedErrorClass
     * error.
     */
    close() {
        if (this.closed)
            return;
        this.closed = true;
        for (const pendingTask of this.pendingTasks) {
            pendingTask.stopped = true;
            pendingTask.reject(new this.ClosedErrorClass('AwaitQueue closed'));
        }
        // Enpty the pending tasks array.
        this.pendingTasks.length = 0;
    }
    /**
     * Accepts a task as argument (and an optional task name) and enqueues it after
     * pending tasks. Once processed, the push() method resolves (or rejects) with
     * the result returned by the given task.
     *
     * The given task must return a Promise or directly a value.
     */
    push(task, name) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.closed)
                throw new this.ClosedErrorClass('AwaitQueue closed');
            if (typeof task !== 'function')
                throw new TypeError('given task is not a function');
            if (!task.name && name) {
                try {
                    Object.defineProperty(task, 'name', { value: name });
                }
                catch (error) { }
            }
            return new Promise((resolve, reject) => {
                const pendingTask = {
                    task,
                    name,
                    resolve,
                    reject,
                    stopped: false,
                    enqueuedAt: new Date(),
                    executedAt: undefined
                };
                // Append task to the queue.
                this.pendingTasks.push(pendingTask);
                // And run it if this is the only task in the queue.
                if (this.pendingTasks.length === 1)
                    this.next();
            });
        });
    }
    /**
     * Make ongoing pending tasks reject with the given StoppedErrorClass error.
     * The AwaitQueue instance is still usable for future tasks added via push()
     * method.
     */
    stop() {
        if (this.closed)
            return;
        for (const pendingTask of this.pendingTasks) {
            pendingTask.stopped = true;
            pendingTask.reject(new this.StoppedErrorClass('AwaitQueue stopped'));
        }
        // Enpty the pending tasks array.
        this.pendingTasks.length = 0;
    }
    dump() {
        const now = new Date();
        return this.pendingTasks.map((pendingTask) => {
            return {
                task: pendingTask.task,
                name: pendingTask.name,
                enqueuedTime: pendingTask.executedAt
                    ? pendingTask.executedAt.getTime() - pendingTask.enqueuedAt.getTime()
                    : now.getTime() - pendingTask.enqueuedAt.getTime(),
                executingTime: pendingTask.executedAt
                    ? now.getTime() - pendingTask.executedAt.getTime()
                    : 0
            };
        });
    }
    next() {
        return __awaiter(this, void 0, void 0, function* () {
            // Take the first pending task.
            const pendingTask = this.pendingTasks[0];
            if (!pendingTask)
                return;
            // Execute it.
            yield this.executeTask(pendingTask);
            // Remove the first pending task (the completed one) from the queue.
            this.pendingTasks.shift();
            // And continue.
            this.next();
        });
    }
    executeTask(pendingTask) {
        return __awaiter(this, void 0, void 0, function* () {
            // If the task is stopped, ignore it.
            if (pendingTask.stopped)
                return;
            pendingTask.executedAt = new Date();
            try {
                const result = yield pendingTask.task();
                // If the task is stopped, ignore it.
                if (pendingTask.stopped)
                    return;
                // Resolve the task with the returned result (if any).
                pendingTask.resolve(result);
            }
            catch (error) {
                // If the task is stopped, ignore it.
                if (pendingTask.stopped)
                    return;
                // Reject the task with its own error.
                pendingTask.reject(error);
            }
        });
    }
}
exports.AwaitQueue = AwaitQueue;

},{}],137:[function(require,module,exports){
arguments[4][87][0].apply(exports,arguments)
},{"dup":87}],138:[function(require,module,exports){
(function (process){(function (){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = require('./common')(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

}).call(this)}).call(this,require('_process'))
},{"./common":139,"_process":2}],139:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;

},{"ms":173}],140:[function(require,module,exports){
const debug = require('debug')('h264-profile-level-id');

/* eslint-disable no-console */
debug.log = console.info.bind(console);
/* eslint-enable no-console */

const ProfileConstrainedBaseline = 1;
const ProfileBaseline = 2;
const ProfileMain = 3;
const ProfileConstrainedHigh = 4;
const ProfileHigh = 5;

exports.ProfileConstrainedBaseline = ProfileConstrainedBaseline;
exports.ProfileBaseline = ProfileBaseline;
exports.ProfileMain = ProfileMain;
exports.ProfileConstrainedHigh = ProfileConstrainedHigh;
exports.ProfileHigh = ProfileHigh;

// All values are equal to ten times the level number, except level 1b which is
// special.
const Level1_b = 0;
const Level1 = 10;
const Level1_1 = 11;
const Level1_2 = 12;
const Level1_3 = 13;
const Level2 = 20;
const Level2_1 = 21;
const Level2_2 = 22;
const Level3 = 30;
const Level3_1 = 31;
const Level3_2 = 32;
const Level4 = 40;
const Level4_1 = 41;
const Level4_2 = 42;
const Level5 = 50;
const Level5_1 = 51;
const Level5_2 = 52;

exports.Level1_b = Level1_b;
exports.Level1 = Level1;
exports.Level1_1 = Level1_1;
exports.Level1_2 = Level1_2;
exports.Level1_3 = Level1_3;
exports.Level2 = Level2;
exports.Level2_1 = Level2_1;
exports.Level2_2 = Level2_2;
exports.Level3 = Level3;
exports.Level3_1 = Level3_1;
exports.Level3_2 = Level3_2;
exports.Level4 = Level4;
exports.Level4_1 = Level4_1;
exports.Level4_2 = Level4_2;
exports.Level5 = Level5;
exports.Level5_1 = Level5_1;
exports.Level5_2 = Level5_2;

class ProfileLevelId
{
	constructor(profile, level)
	{
		this.profile = profile;
		this.level = level;
	}
}

exports.ProfileLevelId = ProfileLevelId;

// Default ProfileLevelId.
//
// TODO: The default should really be profile Baseline and level 1 according to
// the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not
// break backwards compatibility with older versions of WebRTC where external
// codecs don't have any parameters, use profile ConstrainedBaseline level 3_1
// instead. This workaround will only be done in an interim period to allow
// external clients to update their code.
//
// http://crbug/webrtc/6337.
const DefaultProfileLevelId =
	new ProfileLevelId(ProfileConstrainedBaseline, Level3_1);

// For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3
// flag specifies if level 1b or level 1.1 is used.
const ConstraintSet3Flag = 0x10;

// Class for matching bit patterns such as "x1xx0000" where 'x' is allowed to be
// either 0 or 1.
class BitPattern
{
	constructor(str)
	{
		this._mask = ~byteMaskString('x', str);
		this._maskedValue = byteMaskString('1', str);
	}

	isMatch(value)
	{
		return this._maskedValue === (value & this._mask);
	}
}

// Class for converting between profile_idc/profile_iop to Profile.
class ProfilePattern
{
	constructor(profile_idc, profile_iop, profile)
	{
		this.profile_idc = profile_idc;
		this.profile_iop = profile_iop;
		this.profile = profile;
	}
}

// This is from https://tools.ietf.org/html/rfc6184#section-8.1.
const ProfilePatterns =
[
	new ProfilePattern(0x42, new BitPattern('x1xx0000'), ProfileConstrainedBaseline),
	new ProfilePattern(0x4D, new BitPattern('1xxx0000'), ProfileConstrainedBaseline),
	new ProfilePattern(0x58, new BitPattern('11xx0000'), ProfileConstrainedBaseline),
	new ProfilePattern(0x42, new BitPattern('x0xx0000'), ProfileBaseline),
	new ProfilePattern(0x58, new BitPattern('10xx0000'), ProfileBaseline),
	new ProfilePattern(0x4D, new BitPattern('0x0x0000'), ProfileMain),
	new ProfilePattern(0x64, new BitPattern('00000000'), ProfileHigh),
	new ProfilePattern(0x64, new BitPattern('00001100'), ProfileConstrainedHigh)
];

/**
 * Parse profile level id that is represented as a string of 3 hex bytes.
 * Nothing will be returned if the string is not a recognized H264 profile
 * level id.
 *
 * @param {String} str - profile-level-id value as a string of 3 hex bytes.
 *
 * @returns {ProfileLevelId}
 */
exports.parseProfileLevelId = function(str)
{
	// The string should consist of 3 bytes in hexadecimal format.
	if (typeof str !== 'string' || str.length !== 6)
		return null;

	const profile_level_id_numeric = parseInt(str, 16);

	if (profile_level_id_numeric === 0)
		return null;

	// Separate into three bytes.
	const level_idc = profile_level_id_numeric & 0xFF;
	const profile_iop = (profile_level_id_numeric >> 8) & 0xFF;
	const profile_idc = (profile_level_id_numeric >> 16) & 0xFF;

	// Parse level based on level_idc and constraint set 3 flag.
	let level;

	switch (level_idc)
	{
		case Level1_1:
		{
			level = (profile_iop & ConstraintSet3Flag) !== 0 ? Level1_b : Level1_1;
			break;
		}
		case Level1:
		case Level1_2:
		case Level1_3:
		case Level2:
		case Level2_1:
		case Level2_2:
		case Level3:
		case Level3_1:
		case Level3_2:
		case Level4:
		case Level4_1:
		case Level4_2:
		case Level5:
		case Level5_1:
		case Level5_2:
		{
			level = level_idc;
			break;
		}
		// Unrecognized level_idc.
		default:
		{
			debug('parseProfileLevelId() | unrecognized level_idc:%s', level_idc);

			return null;
		}
	}

	// Parse profile_idc/profile_iop into a Profile enum.
	for (const pattern of ProfilePatterns)
	{
		if (
			profile_idc === pattern.profile_idc &&
			pattern.profile_iop.isMatch(profile_iop)
		)
		{
			return new ProfileLevelId(pattern.profile, level);
		}
	}

	debug('parseProfileLevelId() | unrecognized profile_idc/profile_iop combination');

	return null;
};

/**
 * Returns canonical string representation as three hex bytes of the profile
 * level id, or returns nothing for invalid profile level ids.
 *
 * @param {ProfileLevelId} profile_level_id
 *
 * @returns {String}
 */
exports.profileLevelIdToString = function(profile_level_id)
{
	// Handle special case level == 1b.
	if (profile_level_id.level == Level1_b)
	{
		switch (profile_level_id.profile)
		{
			case ProfileConstrainedBaseline:
			{
				return '42f00b';
			}
			case ProfileBaseline:
			{
				return '42100b';
			}
			case ProfileMain:
			{
				return '4d100b';
			}
			// Level 1_b is not allowed for other profiles.
			default:
			{
				debug(
					'profileLevelIdToString() | Level 1_b not is allowed for profile:%s',
					profile_level_id.profile);

				return null;
			}
		}
	}

	let profile_idc_iop_string;

	switch (profile_level_id.profile)
	{
		case ProfileConstrainedBaseline:
		{
			profile_idc_iop_string = '42e0';
			break;
		}
		case ProfileBaseline:
		{
			profile_idc_iop_string = '4200';
			break;
		}
		case ProfileMain:
		{
			profile_idc_iop_string = '4d00';
			break;
		}
		case ProfileConstrainedHigh:
		{
			profile_idc_iop_string = '640c';
			break;
		}
		case ProfileHigh:
		{
			profile_idc_iop_string = '6400';
			break;
		}
		default:
		{
			debug(
				'profileLevelIdToString() | unrecognized profile:%s',
				profile_level_id.profile);

			return null;
		}
	}

	let levelStr = (profile_level_id.level).toString(16);

	if (levelStr.length === 1)
		levelStr = `0${levelStr}`;

	return `${profile_idc_iop_string}${levelStr}`;
};

/**
 * Parse profile level id that is represented as a string of 3 hex bytes
 * contained in an SDP key-value map. A default profile level id will be
 * returned if the profile-level-id key is missing. Nothing will be returned if
 * the key is present but the string is invalid.
 *
 * @param {Object} [params={}] - Codec parameters object.
 *
 * @returns {ProfileLevelId}
 */
exports.parseSdpProfileLevelId = function(params = {})
{
	const profile_level_id = params['profile-level-id'];

	return !profile_level_id
		? DefaultProfileLevelId
		: exports.parseProfileLevelId(profile_level_id);
};

/**
 * Returns true if the parameters have the same H264 profile, i.e. the same
 * H264 profile (Baseline, High, etc).
 *
 * @param {Object} [params1={}] - Codec parameters object.
 * @param {Object} [params2={}] - Codec parameters object.
 *
 * @returns {Boolean}
 */
exports.isSameProfile = function(params1 = {}, params2 = {})
{
	const profile_level_id_1 = exports.parseSdpProfileLevelId(params1);
	const profile_level_id_2 = exports.parseSdpProfileLevelId(params2);

	// Compare H264 profiles, but not levels.
	return Boolean(
		profile_level_id_1 &&
		profile_level_id_2 &&
		profile_level_id_1.profile === profile_level_id_2.profile
	);
};

/**
 * Generate codec parameters that will be used as answer in an SDP negotiation
 * based on local supported parameters and remote offered parameters. Both
 * local_supported_params and remote_offered_params represent sendrecv media
 * descriptions, i.e they are a mix of both encode and decode capabilities. In
 * theory, when the profile in local_supported_params represent a strict superset
 * of the profile in remote_offered_params, we could limit the profile in the
 * answer to the profile in remote_offered_params.
 *
 * However, to simplify the code, each supported H264 profile should be listed
 * explicitly in the list of local supported codecs, even if they are redundant.
 * Then each local codec in the list should be tested one at a time against the
 * remote codec, and only when the profiles are equal should this function be
 * called. Therefore, this function does not need to handle profile intersection,
 * and the profile of local_supported_params and remote_offered_params must be
 * equal before calling this function. The parameters that are used when
 * negotiating are the level part of profile-level-id and level-asymmetry-allowed.
 *
 * @param {Object} [local_supported_params={}]
 * @param {Object} [remote_offered_params={}]
 *
 * @returns {String} Canonical string representation as three hex bytes of the
 *   profile level id, or null if no one of the params have profile-level-id.
 *
 * @throws {TypeError} If Profile mismatch or invalid params.
 */
exports.generateProfileLevelIdForAnswer = function(
	local_supported_params = {},
	remote_offered_params = {}
)
{
	// If both local and remote params do not contain profile-level-id, they are
	// both using the default profile. In this case, don't return anything.
	if (
		!local_supported_params['profile-level-id'] &&
		!remote_offered_params['profile-level-id']
	)
	{
		debug(
			'generateProfileLevelIdForAnswer() | no profile-level-id in local and remote params');

		return null;
	}

	// Parse profile-level-ids.
	const local_profile_level_id =
		exports.parseSdpProfileLevelId(local_supported_params);
	const remote_profile_level_id =
		exports.parseSdpProfileLevelId(remote_offered_params);

	// The local and remote codec must have valid and equal H264 Profiles.
	if (!local_profile_level_id)
		throw new TypeError('invalid local_profile_level_id');

	if (!remote_profile_level_id)
		throw new TypeError('invalid remote_profile_level_id');

	if (local_profile_level_id.profile !== remote_profile_level_id.profile)
		throw new TypeError('H264 Profile mismatch');

	// Parse level information.
	const level_asymmetry_allowed = (
		isLevelAsymmetryAllowed(local_supported_params) &&
		isLevelAsymmetryAllowed(remote_offered_params)
	);

	const local_level = local_profile_level_id.level;
	const remote_level = remote_profile_level_id.level;
	const min_level = minLevel(local_level, remote_level);

	// Determine answer level. When level asymmetry is not allowed, level upgrade
	// is not allowed, i.e., the level in the answer must be equal to or lower
	// than the level in the offer.
	const answer_level = level_asymmetry_allowed ? local_level : min_level;

	debug(
		'generateProfileLevelIdForAnswer() | result: [profile:%s, level:%s]',
		local_profile_level_id.profile, answer_level);

	// Return the resulting profile-level-id for the answer parameters.
	return exports.profileLevelIdToString(
		new ProfileLevelId(local_profile_level_id.profile, answer_level));
};

// Convert a string of 8 characters into a byte where the positions containing
// character c will have their bit set. For example, c = 'x', str = "x1xx0000"
// will return 0b10110000.
function byteMaskString(c, str)
{
	return (
		((str[0] === c) << 7) | ((str[1] === c) << 6) | ((str[2] === c) << 5) |
		((str[3] === c) << 4)	| ((str[4] === c) << 3)	| ((str[5] === c) << 2)	|
		((str[6] === c) << 1)	| ((str[7] === c) << 0)
	);
}

// Compare H264 levels and handle the level 1b case.
function isLessLevel(a, b)
{
	if (a === Level1_b)
		return b !== Level1 && b !== Level1_b;

	if (b === Level1_b)
		return a !== Level1;

	return a < b;
}

function minLevel(a, b)
{
	return isLessLevel(a, b) ? a : b;
}

function isLevelAsymmetryAllowed(params = {})
{
	const level_asymmetry_allowed = params['level-asymmetry-allowed'];

	return (
		level_asymmetry_allowed === 1 ||
		level_asymmetry_allowed === '1'
	);
}

},{"debug":138}],141:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Consumer = void 0;
const Logger_1 = require("./Logger");
const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
const errors_1 = require("./errors");
const logger = new Logger_1.Logger('Consumer');
class Consumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    /**
     * @emits transportclose
     * @emits trackended
     * @emits @getstats
     * @emits @close
     * @emits @pause
     * @emits @resume
     */
    constructor({ id, localId, producerId, rtpReceiver, track, rtpParameters, appData }) {
        super();
        // Closed flag.
        this._closed = false;
        // Observer instance.
        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
        logger.debug('constructor()');
        this._id = id;
        this._localId = localId;
        this._producerId = producerId;
        this._rtpReceiver = rtpReceiver;
        this._track = track;
        this._rtpParameters = rtpParameters;
        this._paused = !track.enabled;
        this._appData = appData;
        this._onTrackEnded = this._onTrackEnded.bind(this);
        this._handleTrack();
    }
    /**
     * Consumer id.
     */
    get id() {
        return this._id;
    }
    /**
     * Local id.
     */
    get localId() {
        return this._localId;
    }
    /**
     * Associated Producer id.
     */
    get producerId() {
        return this._producerId;
    }
    /**
     * Whether the Consumer is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * Media kind.
     */
    get kind() {
        return this._track.kind;
    }
    /**
     * Associated RTCRtpReceiver.
     */
    get rtpReceiver() {
        return this._rtpReceiver;
    }
    /**
     * The associated track.
     */
    get track() {
        return this._track;
    }
    /**
     * RTP parameters.
     */
    get rtpParameters() {
        return this._rtpParameters;
    }
    /**
     * Whether the Consumer is paused.
     */
    get paused() {
        return this._paused;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * Invalid setter.
     */
    set appData(appData) {
        throw new Error('cannot override appData object');
    }
    /**
     * Observer.
     *
     * @emits close
     * @emits pause
     * @emits resume
     * @emits trackended
     */
    get observer() {
        return this._observer;
    }
    /**
     * Closes the Consumer.
     */
    close() {
        if (this._closed)
            return;
        logger.debug('close()');
        this._closed = true;
        this._destroyTrack();
        this.emit('@close');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
        if (this._closed)
            return;
        logger.debug('transportClosed()');
        this._closed = true;
        this._destroyTrack();
        this.safeEmit('transportclose');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Get associated RTCRtpReceiver stats.
     */
    async getStats() {
        if (this._closed)
            throw new errors_1.InvalidStateError('closed');
        return this.safeEmitAsPromise('@getstats');
    }
    /**
     * Pauses receiving media.
     */
    pause() {
        logger.debug('pause()');
        if (this._closed) {
            logger.error('pause() | Consumer closed');
            return;
        }
        this._paused = true;
        this._track.enabled = false;
        this.emit('@pause');
        // Emit observer event.
        this._observer.safeEmit('pause');
    }
    /**
     * Resumes receiving media.
     */
    resume() {
        logger.debug('resume()');
        if (this._closed) {
            logger.error('resume() | Consumer closed');
            return;
        }
        this._paused = false;
        this._track.enabled = true;
        this.emit('@resume');
        // Emit observer event.
        this._observer.safeEmit('resume');
    }
    _onTrackEnded() {
        logger.debug('track "ended" event');
        this.safeEmit('trackended');
        // Emit observer event.
        this._observer.safeEmit('trackended');
    }
    _handleTrack() {
        this._track.addEventListener('ended', this._onTrackEnded);
    }
    _destroyTrack() {
        try {
            this._track.removeEventListener('ended', this._onTrackEnded);
            this._track.stop();
        }
        catch (error) { }
    }
}
exports.Consumer = Consumer;

},{"./EnhancedEventEmitter":145,"./Logger":146,"./errors":151}],142:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataConsumer = void 0;
const Logger_1 = require("./Logger");
const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
const logger = new Logger_1.Logger('DataConsumer');
class DataConsumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    /**
     * @emits transportclose
     * @emits open
     * @emits error - (error: Error)
     * @emits close
     * @emits message - (message: any)
     * @emits @close
     */
    constructor({ id, dataProducerId, dataChannel, sctpStreamParameters, appData }) {
        super();
        // Closed flag.
        this._closed = false;
        // Observer instance.
        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
        logger.debug('constructor()');
        this._id = id;
        this._dataProducerId = dataProducerId;
        this._dataChannel = dataChannel;
        this._sctpStreamParameters = sctpStreamParameters;
        this._appData = appData;
        this._handleDataChannel();
    }
    /**
     * DataConsumer id.
     */
    get id() {
        return this._id;
    }
    /**
     * Associated DataProducer id.
     */
    get dataProducerId() {
        return this._dataProducerId;
    }
    /**
     * Whether the DataConsumer is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * SCTP stream parameters.
     */
    get sctpStreamParameters() {
        return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */
    get readyState() {
        return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */
    get label() {
        return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */
    get protocol() {
        return this._dataChannel.protocol;
    }
    /**
     * DataChannel binaryType.
     */
    get binaryType() {
        return this._dataChannel.binaryType;
    }
    /**
     * Set DataChannel binaryType.
     */
    set binaryType(binaryType) {
        this._dataChannel.binaryType = binaryType;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * Invalid setter.
     */
    set appData(appData) {
        throw new Error('cannot override appData object');
    }
    /**
     * Observer.
     *
     * @emits close
     */
    get observer() {
        return this._observer;
    }
    /**
     * Closes the DataConsumer.
     */
    close() {
        if (this._closed)
            return;
        logger.debug('close()');
        this._closed = true;
        this._dataChannel.close();
        this.emit('@close');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
        if (this._closed)
            return;
        logger.debug('transportClosed()');
        this._closed = true;
        this._dataChannel.close();
        this.safeEmit('transportclose');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    _handleDataChannel() {
        this._dataChannel.addEventListener('open', () => {
            if (this._closed)
                return;
            logger.debug('DataChannel "open" event');
            this.safeEmit('open');
        });
        this._dataChannel.addEventListener('error', (event) => {
            if (this._closed)
                return;
            let { error } = event;
            if (!error)
                error = new Error('unknown DataChannel error');
            if (error.errorDetail === 'sctp-failure') {
                logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);
            }
            else {
                logger.error('DataChannel "error" event: %o', error);
            }
            this.safeEmit('error', error);
        });
        this._dataChannel.addEventListener('close', () => {
            if (this._closed)
                return;
            logger.warn('DataChannel "close" event');
            this._closed = true;
            this.emit('@close');
            this.safeEmit('close');
        });
        this._dataChannel.addEventListener('message', (event) => {
            if (this._closed)
                return;
            this.safeEmit('message', event.data);
        });
    }
}
exports.DataConsumer = DataConsumer;

},{"./EnhancedEventEmitter":145,"./Logger":146}],143:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataProducer = void 0;
const Logger_1 = require("./Logger");
const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
const errors_1 = require("./errors");
const logger = new Logger_1.Logger('DataProducer');
class DataProducer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    /**
     * @emits transportclose
     * @emits open
     * @emits error - (error: Error)
     * @emits close
     * @emits bufferedamountlow
     * @emits @close
     */
    constructor({ id, dataChannel, sctpStreamParameters, appData }) {
        super();
        // Closed flag.
        this._closed = false;
        // Observer instance.
        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
        logger.debug('constructor()');
        this._id = id;
        this._dataChannel = dataChannel;
        this._sctpStreamParameters = sctpStreamParameters;
        this._appData = appData;
        this._handleDataChannel();
    }
    /**
     * DataProducer id.
     */
    get id() {
        return this._id;
    }
    /**
     * Whether the DataProducer is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * SCTP stream parameters.
     */
    get sctpStreamParameters() {
        return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */
    get readyState() {
        return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */
    get label() {
        return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */
    get protocol() {
        return this._dataChannel.protocol;
    }
    /**
     * DataChannel bufferedAmount.
     */
    get bufferedAmount() {
        return this._dataChannel.bufferedAmount;
    }
    /**
     * DataChannel bufferedAmountLowThreshold.
     */
    get bufferedAmountLowThreshold() {
        return this._dataChannel.bufferedAmountLowThreshold;
    }
    /**
     * Set DataChannel bufferedAmountLowThreshold.
     */
    set bufferedAmountLowThreshold(bufferedAmountLowThreshold) {
        this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * Invalid setter.
     */
    set appData(appData) {
        throw new Error('cannot override appData object');
    }
    /**
     * Observer.
     *
     * @emits close
     */
    get observer() {
        return this._observer;
    }
    /**
     * Closes the DataProducer.
     */
    close() {
        if (this._closed)
            return;
        logger.debug('close()');
        this._closed = true;
        this._dataChannel.close();
        this.emit('@close');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
        if (this._closed)
            return;
        logger.debug('transportClosed()');
        this._closed = true;
        this._dataChannel.close();
        this.safeEmit('transportclose');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Send a message.
     *
     * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.
     */
    send(data) {
        logger.debug('send()');
        if (this._closed)
            throw new errors_1.InvalidStateError('closed');
        this._dataChannel.send(data);
    }
    _handleDataChannel() {
        this._dataChannel.addEventListener('open', () => {
            if (this._closed)
                return;
            logger.debug('DataChannel "open" event');
            this.safeEmit('open');
        });
        this._dataChannel.addEventListener('error', (event) => {
            if (this._closed)
                return;
            let { error } = event;
            if (!error)
                error = new Error('unknown DataChannel error');
            if (error.errorDetail === 'sctp-failure') {
                logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);
            }
            else {
                logger.error('DataChannel "error" event: %o', error);
            }
            this.safeEmit('error', error);
        });
        this._dataChannel.addEventListener('close', () => {
            if (this._closed)
                return;
            logger.warn('DataChannel "close" event');
            this._closed = true;
            this.emit('@close');
            this.safeEmit('close');
        });
        this._dataChannel.addEventListener('message', () => {
            if (this._closed)
                return;
            logger.warn('DataChannel "message" event in a DataProducer, message discarded');
        });
        this._dataChannel.addEventListener('bufferedamountlow', () => {
            if (this._closed)
                return;
            this.safeEmit('bufferedamountlow');
        });
    }
}
exports.DataProducer = DataProducer;

},{"./EnhancedEventEmitter":145,"./Logger":146,"./errors":151}],144:[function(require,module,exports){
"use strict";
/* global RTCRtpTransceiver */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Device = exports.detectDevice = void 0;
const bowser_1 = __importDefault(require("bowser"));
const Logger_1 = require("./Logger");
const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
const errors_1 = require("./errors");
const utils = __importStar(require("./utils"));
const ortc = __importStar(require("./ortc"));
const Transport_1 = require("./Transport");
const Chrome74_1 = require("./handlers/Chrome74");
const Chrome70_1 = require("./handlers/Chrome70");
const Chrome67_1 = require("./handlers/Chrome67");
const Chrome55_1 = require("./handlers/Chrome55");
const Firefox60_1 = require("./handlers/Firefox60");
const Safari12_1 = require("./handlers/Safari12");
const Safari11_1 = require("./handlers/Safari11");
const Edge11_1 = require("./handlers/Edge11");
const ReactNative_1 = require("./handlers/ReactNative");
const logger = new Logger_1.Logger('Device');
function detectDevice() {
    // React-Native.
    // NOTE: react-native-webrtc >= 1.75.0 is required.
    if (typeof navigator === 'object' && navigator.product === 'ReactNative') {
        if (typeof RTCPeerConnection === 'undefined') {
            logger.warn('this._detectDevice() | unsupported ReactNative without RTCPeerConnection');
            return undefined;
        }
        logger.debug('this._detectDevice() | ReactNative handler chosen');
        return 'ReactNative';
    }
    // Browser.
    else if (typeof navigator === 'object' && typeof navigator.userAgent === 'string') {
        const ua = navigator.userAgent;
        const browser = bowser_1.default.getParser(ua);
        const engine = browser.getEngine();
        // Chrome, Chromium, and Edge.
        if (browser.satisfies({ chrome: '>=74', chromium: '>=74', 'microsoft edge': '>=88' })) {
            return 'Chrome74';
        }
        else if (browser.satisfies({ chrome: '>=70', chromium: '>=70' })) {
            return 'Chrome70';
        }
        else if (browser.satisfies({ chrome: '>=67', chromium: '>=67' })) {
            return 'Chrome67';
        }
        else if (browser.satisfies({ chrome: '>=55', chromium: '>=55' })) {
            return 'Chrome55';
        }
        // Firefox.
        else if (browser.satisfies({ firefox: '>=60' })) {
            return 'Firefox60';
        }
        // Firefox on iOS.
        else if (browser.satisfies({ ios: { OS: '>=14.3', firefox: '>=30.0' } })) {
            return 'Safari12';
        }
        // Safari with Unified-Plan support enabled.
        else if (browser.satisfies({ safari: '>=12.0' }) &&
            typeof RTCRtpTransceiver !== 'undefined' &&
            RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) {
            return 'Safari12';
        }
        // Safari with Plab-B support.
        else if (browser.satisfies({ safari: '>=11' })) {
            return 'Safari11';
        }
        // Old Edge with ORTC support.
        else if (browser.satisfies({ 'microsoft edge': '>=11' }) &&
            browser.satisfies({ 'microsoft edge': '<=18' })) {
            return 'Edge11';
        }
        // Best effort for Chromium based browsers.
        else if (engine.name && engine.name.toLowerCase() === 'blink') {
            const match = ua.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
            if (match) {
                const version = Number(match[1]);
                if (version >= 74) {
                    return 'Chrome74';
                }
                else if (version >= 70) {
                    return 'Chrome70';
                }
                else if (version >= 67) {
                    return 'Chrome67';
                }
                else {
                    return 'Chrome55';
                }
            }
            else {
                return 'Chrome74';
            }
        }
        // Unsupported browser.
        else {
            logger.warn('this._detectDevice() | browser not supported [name:%s, version:%s]', browser.getBrowserName(), browser.getBrowserVersion());
            return undefined;
        }
    }
    // Unknown device.
    else {
        logger.warn('this._detectDevice() | unknown device');
        return undefined;
    }
}
exports.detectDevice = detectDevice;
class Device {
    /**
     * Create a new Device to connect to mediasoup server.
     *
     * @throws {UnsupportedError} if device is not supported.
     */
    constructor({ handlerName, handlerFactory, Handler } = {}) {
        // Loaded flag.
        this._loaded = false;
        // Observer instance.
        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
        logger.debug('constructor()');
        // Handle deprecated option.
        if (Handler) {
            logger.warn('constructor() | Handler option is DEPRECATED, use handlerName or handlerFactory instead');
            if (typeof Handler === 'string')
                handlerName = Handler;
            else
                throw new TypeError('non string Handler option no longer supported, use handlerFactory instead');
        }
        if (handlerName && handlerFactory) {
            throw new TypeError('just one of handlerName or handlerInterface can be given');
        }
        if (handlerFactory) {
            this._handlerFactory = handlerFactory;
        }
        else {
            if (handlerName) {
                logger.debug('constructor() | handler given: %s', handlerName);
            }
            else {
                handlerName = detectDevice();
                if (handlerName)
                    logger.debug('constructor() | detected handler: %s', handlerName);
                else
                    throw new errors_1.UnsupportedError('device not supported');
            }
            switch (handlerName) {
                case 'Chrome74':
                    this._handlerFactory = Chrome74_1.Chrome74.createFactory();
                    break;
                case 'Chrome70':
                    this._handlerFactory = Chrome70_1.Chrome70.createFactory();
                    break;
                case 'Chrome67':
                    this._handlerFactory = Chrome67_1.Chrome67.createFactory();
                    break;
                case 'Chrome55':
                    this._handlerFactory = Chrome55_1.Chrome55.createFactory();
                    break;
                case 'Firefox60':
                    this._handlerFactory = Firefox60_1.Firefox60.createFactory();
                    break;
                case 'Safari12':
                    this._handlerFactory = Safari12_1.Safari12.createFactory();
                    break;
                case 'Safari11':
                    this._handlerFactory = Safari11_1.Safari11.createFactory();
                    break;
                case 'Edge11':
                    this._handlerFactory = Edge11_1.Edge11.createFactory();
                    break;
                case 'ReactNative':
                    this._handlerFactory = ReactNative_1.ReactNative.createFactory();
                    break;
                default:
                    throw new TypeError(`unknown handlerName "${handlerName}"`);
            }
        }
        // Create a temporal handler to get its name.
        const handler = this._handlerFactory();
        this._handlerName = handler.name;
        handler.close();
        this._extendedRtpCapabilities = undefined;
        this._recvRtpCapabilities = undefined;
        this._canProduceByKind =
            {
                audio: false,
                video: false
            };
        this._sctpCapabilities = undefined;
    }
    /**
     * The RTC handler name.
     */
    get handlerName() {
        return this._handlerName;
    }
    /**
     * Whether the Device is loaded.
     */
    get loaded() {
        return this._loaded;
    }
    /**
     * RTP capabilities of the Device for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     */
    get rtpCapabilities() {
        if (!this._loaded)
            throw new errors_1.InvalidStateError('not loaded');
        return this._recvRtpCapabilities;
    }
    /**
     * SCTP capabilities of the Device.
     *
     * @throws {InvalidStateError} if not loaded.
     */
    get sctpCapabilities() {
        if (!this._loaded)
            throw new errors_1.InvalidStateError('not loaded');
        return this._sctpCapabilities;
    }
    /**
     * Observer.
     *
     * @emits newtransport - (transport: Transport)
     */
    get observer() {
        return this._observer;
    }
    /**
     * Initialize the Device.
     */
    async load({ routerRtpCapabilities }) {
        logger.debug('load() [routerRtpCapabilities:%o]', routerRtpCapabilities);
        routerRtpCapabilities = utils.clone(routerRtpCapabilities, undefined);
        // Temporal handler to get its capabilities.
        let handler;
        try {
            if (this._loaded)
                throw new errors_1.InvalidStateError('already loaded');
            // This may throw.
            ortc.validateRtpCapabilities(routerRtpCapabilities);
            handler = this._handlerFactory();
            const nativeRtpCapabilities = await handler.getNativeRtpCapabilities();
            logger.debug('load() | got native RTP capabilities:%o', nativeRtpCapabilities);
            // This may throw.
            ortc.validateRtpCapabilities(nativeRtpCapabilities);
            // Get extended RTP capabilities.
            this._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, routerRtpCapabilities);
            logger.debug('load() | got extended RTP capabilities:%o', this._extendedRtpCapabilities);
            // Check whether we can produce audio/video.
            this._canProduceByKind.audio =
                ortc.canSend('audio', this._extendedRtpCapabilities);
            this._canProduceByKind.video =
                ortc.canSend('video', this._extendedRtpCapabilities);
            // Generate our receiving RTP capabilities for receiving media.
            this._recvRtpCapabilities =
                ortc.getRecvRtpCapabilities(this._extendedRtpCapabilities);
            // This may throw.
            ortc.validateRtpCapabilities(this._recvRtpCapabilities);
            logger.debug('load() | got receiving RTP capabilities:%o', this._recvRtpCapabilities);
            // Generate our SCTP capabilities.
            this._sctpCapabilities = await handler.getNativeSctpCapabilities();
            logger.debug('load() | got native SCTP capabilities:%o', this._sctpCapabilities);
            // This may throw.
            ortc.validateSctpCapabilities(this._sctpCapabilities);
            logger.debug('load() succeeded');
            this._loaded = true;
            handler.close();
        }
        catch (error) {
            if (handler)
                handler.close();
            throw error;
        }
    }
    /**
     * Whether we can produce audio/video.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    canProduce(kind) {
        if (!this._loaded)
            throw new errors_1.InvalidStateError('not loaded');
        else if (kind !== 'audio' && kind !== 'video')
            throw new TypeError(`invalid kind "${kind}"`);
        return this._canProduceByKind[kind];
    }
    /**
     * Creates a Transport for sending media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    createSendTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData = {} }) {
        logger.debug('createSendTransport()');
        return this._createTransport({
            direction: 'send',
            id: id,
            iceParameters: iceParameters,
            iceCandidates: iceCandidates,
            dtlsParameters: dtlsParameters,
            sctpParameters: sctpParameters,
            iceServers: iceServers,
            iceTransportPolicy: iceTransportPolicy,
            additionalSettings: additionalSettings,
            proprietaryConstraints: proprietaryConstraints,
            appData: appData
        });
    }
    /**
     * Creates a Transport for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    createRecvTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData = {} }) {
        logger.debug('createRecvTransport()');
        return this._createTransport({
            direction: 'recv',
            id: id,
            iceParameters: iceParameters,
            iceCandidates: iceCandidates,
            dtlsParameters: dtlsParameters,
            sctpParameters: sctpParameters,
            iceServers: iceServers,
            iceTransportPolicy: iceTransportPolicy,
            additionalSettings: additionalSettings,
            proprietaryConstraints: proprietaryConstraints,
            appData: appData
        });
    }
    _createTransport({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData = {} }) {
        if (!this._loaded)
            throw new errors_1.InvalidStateError('not loaded');
        else if (typeof id !== 'string')
            throw new TypeError('missing id');
        else if (typeof iceParameters !== 'object')
            throw new TypeError('missing iceParameters');
        else if (!Array.isArray(iceCandidates))
            throw new TypeError('missing iceCandidates');
        else if (typeof dtlsParameters !== 'object')
            throw new TypeError('missing dtlsParameters');
        else if (sctpParameters && typeof sctpParameters !== 'object')
            throw new TypeError('wrong sctpParameters');
        else if (appData && typeof appData !== 'object')
            throw new TypeError('if given, appData must be an object');
        // Create a new Transport.
        const transport = new Transport_1.Transport({
            direction,
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            appData,
            handlerFactory: this._handlerFactory,
            extendedRtpCapabilities: this._extendedRtpCapabilities,
            canProduceByKind: this._canProduceByKind
        });
        // Emit observer event.
        this._observer.safeEmit('newtransport', transport);
        return transport;
    }
}
exports.Device = Device;

},{"./EnhancedEventEmitter":145,"./Logger":146,"./Transport":150,"./errors":151,"./handlers/Chrome55":152,"./handlers/Chrome67":153,"./handlers/Chrome70":154,"./handlers/Chrome74":155,"./handlers/Edge11":156,"./handlers/Firefox60":157,"./handlers/ReactNative":159,"./handlers/Safari11":160,"./handlers/Safari12":161,"./ortc":169,"./utils":172,"bowser":137}],145:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnhancedEventEmitter = void 0;
const events_1 = require("events");
const Logger_1 = require("./Logger");
const logger = new Logger_1.Logger('EnhancedEventEmitter');
class EnhancedEventEmitter extends events_1.EventEmitter {
    constructor() {
        super();
        this.setMaxListeners(Infinity);
    }
    safeEmit(event, ...args) {
        const numListeners = this.listenerCount(event);
        try {
            return this.emit(event, ...args);
        }
        catch (error) {
            logger.error('safeEmit() | event listener threw an error [event:%s]:%o', event, error);
            return Boolean(numListeners);
        }
    }
    async safeEmitAsPromise(event, ...args) {
        return new Promise((resolve, reject) => {
            try {
                this.emit(event, ...args, resolve, reject);
            }
            catch (error) {
                logger.error('safeEmitAsPromise() | event listener threw an error [event:%s]:%o', event, error);
                reject(error);
            }
        });
    }
}
exports.EnhancedEventEmitter = EnhancedEventEmitter;

},{"./Logger":146,"events":1}],146:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const debug_1 = __importDefault(require("debug"));
const APP_NAME = 'mediasoup-client';
class Logger {
    constructor(prefix) {
        if (prefix) {
            this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
        }
        else {
            this._debug = (0, debug_1.default)(APP_NAME);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
        }
        /* eslint-disable no-console */
        this._debug.log = console.info.bind(console);
        this._warn.log = console.warn.bind(console);
        this._error.log = console.error.bind(console);
        /* eslint-enable no-console */
    }
    get debug() {
        return this._debug;
    }
    get warn() {
        return this._warn;
    }
    get error() {
        return this._error;
    }
}
exports.Logger = Logger;

},{"debug":138}],147:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Producer = void 0;
const Logger_1 = require("./Logger");
const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
const errors_1 = require("./errors");
const logger = new Logger_1.Logger('Producer');
class Producer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    /**
     * @emits transportclose
     * @emits trackended
     * @emits @replacetrack - (track: MediaStreamTrack | null)
     * @emits @setmaxspatiallayer - (spatialLayer: string)
     * @emits @setrtpencodingparameters - (params: any)
     * @emits @getstats
     * @emits @close
     */
    constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData }) {
        super();
        // Closed flag.
        this._closed = false;
        // Observer instance.
        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
        logger.debug('constructor()');
        this._id = id;
        this._localId = localId;
        this._rtpSender = rtpSender;
        this._track = track;
        this._kind = track.kind;
        this._rtpParameters = rtpParameters;
        this._paused = disableTrackOnPause ? !track.enabled : false;
        this._maxSpatialLayer = undefined;
        this._stopTracks = stopTracks;
        this._disableTrackOnPause = disableTrackOnPause;
        this._zeroRtpOnPause = zeroRtpOnPause;
        this._appData = appData;
        this._onTrackEnded = this._onTrackEnded.bind(this);
        // NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the
        // '@replacetrack' event here, so RTCRtpSender.track won't be null.
        this._handleTrack();
    }
    /**
     * Producer id.
     */
    get id() {
        return this._id;
    }
    /**
     * Local id.
     */
    get localId() {
        return this._localId;
    }
    /**
     * Whether the Producer is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * Media kind.
     */
    get kind() {
        return this._kind;
    }
    /**
     * Associated RTCRtpSender.
     */
    get rtpSender() {
        return this._rtpSender;
    }
    /**
     * The associated track.
     */
    get track() {
        return this._track;
    }
    /**
     * RTP parameters.
     */
    get rtpParameters() {
        return this._rtpParameters;
    }
    /**
     * Whether the Producer is paused.
     */
    get paused() {
        return this._paused;
    }
    /**
     * Max spatial layer.
     *
     * @type {Number | undefined}
     */
    get maxSpatialLayer() {
        return this._maxSpatialLayer;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * Invalid setter.
     */
    set appData(appData) {
        throw new Error('cannot override appData object');
    }
    /**
     * Observer.
     *
     * @emits close
     * @emits pause
     * @emits resume
     * @emits trackended
     */
    get observer() {
        return this._observer;
    }
    /**
     * Closes the Producer.
     */
    close() {
        if (this._closed)
            return;
        logger.debug('close()');
        this._closed = true;
        this._destroyTrack();
        this.emit('@close');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
        if (this._closed)
            return;
        logger.debug('transportClosed()');
        this._closed = true;
        this._destroyTrack();
        this.safeEmit('transportclose');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Get associated RTCRtpSender stats.
     */
    async getStats() {
        if (this._closed)
            throw new errors_1.InvalidStateError('closed');
        return this.safeEmitAsPromise('@getstats');
    }
    /**
     * Pauses sending media.
     */
    pause() {
        logger.debug('pause()');
        if (this._closed) {
            logger.error('pause() | Producer closed');
            return;
        }
        this._paused = true;
        if (this._track && this._disableTrackOnPause) {
            this._track.enabled = false;
        }
        if (this._zeroRtpOnPause) {
            this.safeEmitAsPromise('@replacetrack', null)
                .catch(() => { });
        }
        // Emit observer event.
        this._observer.safeEmit('pause');
    }
    /**
     * Resumes sending media.
     */
    resume() {
        logger.debug('resume()');
        if (this._closed) {
            logger.error('resume() | Producer closed');
            return;
        }
        this._paused = false;
        if (this._track && this._disableTrackOnPause) {
            this._track.enabled = true;
        }
        if (this._zeroRtpOnPause) {
            this.safeEmitAsPromise('@replacetrack', this._track)
                .catch(() => { });
        }
        // Emit observer event.
        this._observer.safeEmit('resume');
    }
    /**
     * Replaces the current track with a new one or null.
     */
    async replaceTrack({ track }) {
        logger.debug('replaceTrack() [track:%o]', track);
        if (this._closed) {
            // This must be done here. Otherwise there is no chance to stop the given
            // track.
            if (track && this._stopTracks) {
                try {
                    track.stop();
                }
                catch (error) { }
            }
            throw new errors_1.InvalidStateError('closed');
        }
        else if (track && track.readyState === 'ended') {
            throw new errors_1.InvalidStateError('track ended');
        }
        // Do nothing if this is the same track as the current handled one.
        if (track === this._track) {
            logger.debug('replaceTrack() | same track, ignored');
            return;
        }
        if (!this._zeroRtpOnPause || !this._paused) {
            await this.safeEmitAsPromise('@replacetrack', track);
        }
        // Destroy the previous track.
        this._destroyTrack();
        // Set the new track.
        this._track = track;
        // If this Producer was paused/resumed and the state of the new
        // track does not match, fix it.
        if (this._track && this._disableTrackOnPause) {
            if (!this._paused)
                this._track.enabled = true;
            else if (this._paused)
                this._track.enabled = false;
        }
        // Handle the effective track.
        this._handleTrack();
    }
    /**
     * Sets the video max spatial layer to be sent.
     */
    async setMaxSpatialLayer(spatialLayer) {
        if (this._closed)
            throw new errors_1.InvalidStateError('closed');
        else if (this._kind !== 'video')
            throw new errors_1.UnsupportedError('not a video Producer');
        else if (typeof spatialLayer !== 'number')
            throw new TypeError('invalid spatialLayer');
        if (spatialLayer === this._maxSpatialLayer)
            return;
        await this.safeEmitAsPromise('@setmaxspatiallayer', spatialLayer);
        this._maxSpatialLayer = spatialLayer;
    }
    /**
     * Sets the DSCP value.
     */
    async setRtpEncodingParameters(params) {
        if (this._closed)
            throw new errors_1.InvalidStateError('closed');
        else if (typeof params !== 'object')
            throw new TypeError('invalid params');
        await this.safeEmitAsPromise('@setrtpencodingparameters', params);
    }
    _onTrackEnded() {
        logger.debug('track "ended" event');
        this.safeEmit('trackended');
        // Emit observer event.
        this._observer.safeEmit('trackended');
    }
    _handleTrack() {
        if (!this._track)
            return;
        this._track.addEventListener('ended', this._onTrackEnded);
    }
    _destroyTrack() {
        if (!this._track)
            return;
        try {
            this._track.removeEventListener('ended', this._onTrackEnded);
            // Just stop the track unless the app set stopTracks: false.
            if (this._stopTracks)
                this._track.stop();
        }
        catch (error) { }
    }
}
exports.Producer = Producer;

},{"./EnhancedEventEmitter":145,"./Logger":146,"./errors":151}],148:[function(require,module,exports){
"use strict";
/**
 * The RTP capabilities define what mediasoup or an endpoint can receive at
 * media level.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],149:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],150:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transport = void 0;
const awaitqueue_1 = require("awaitqueue");
const Logger_1 = require("./Logger");
const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
const errors_1 = require("./errors");
const utils = __importStar(require("./utils"));
const ortc = __importStar(require("./ortc"));
const Producer_1 = require("./Producer");
const Consumer_1 = require("./Consumer");
const DataProducer_1 = require("./DataProducer");
const DataConsumer_1 = require("./DataConsumer");
const logger = new Logger_1.Logger('Transport');
class Transport extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    /**
     * @emits connect - (transportLocalParameters: any, callback: Function, errback: Function)
     * @emits connectionstatechange - (connectionState: ConnectionState)
     * @emits produce - (producerLocalParameters: any, callback: Function, errback: Function)
     * @emits producedata - (dataProducerLocalParameters: any, callback: Function, errback: Function)
     */
    constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, handlerFactory, extendedRtpCapabilities, canProduceByKind }) {
        super();
        // Closed flag.
        this._closed = false;
        // Transport connection state.
        this._connectionState = 'new';
        // Map of Producers indexed by id.
        this._producers = new Map();
        // Map of Consumers indexed by id.
        this._consumers = new Map();
        // Map of DataProducers indexed by id.
        this._dataProducers = new Map();
        // Map of DataConsumers indexed by id.
        this._dataConsumers = new Map();
        // Whether the Consumer for RTP probation has been created.
        this._probatorConsumerCreated = false;
        // AwaitQueue instance to make async tasks happen sequentially.
        this._awaitQueue = new awaitqueue_1.AwaitQueue({ ClosedErrorClass: errors_1.InvalidStateError });
        // Observer instance.
        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
        logger.debug('constructor() [id:%s, direction:%s]', id, direction);
        this._id = id;
        this._direction = direction;
        this._extendedRtpCapabilities = extendedRtpCapabilities;
        this._canProduceByKind = canProduceByKind;
        this._maxSctpMessageSize =
            sctpParameters ? sctpParameters.maxMessageSize : null;
        // Clone and sanitize additionalSettings.
        additionalSettings = utils.clone(additionalSettings, {});
        delete additionalSettings.iceServers;
        delete additionalSettings.iceTransportPolicy;
        delete additionalSettings.bundlePolicy;
        delete additionalSettings.rtcpMuxPolicy;
        delete additionalSettings.sdpSemantics;
        this._handler = handlerFactory();
        this._handler.run({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            extendedRtpCapabilities
        });
        this._appData = appData;
        this._handleHandler();
    }
    /**
     * Transport id.
     */
    get id() {
        return this._id;
    }
    /**
     * Whether the Transport is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * Transport direction.
     */
    get direction() {
        return this._direction;
    }
    /**
     * RTC handler instance.
     */
    get handler() {
        return this._handler;
    }
    /**
     * Connection state.
     */
    get connectionState() {
        return this._connectionState;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * Invalid setter.
     */
    set appData(appData) {
        throw new Error('cannot override appData object');
    }
    /**
     * Observer.
     *
     * @emits close
     * @emits newproducer - (producer: Producer)
     * @emits newconsumer - (producer: Producer)
     * @emits newdataproducer - (dataProducer: DataProducer)
     * @emits newdataconsumer - (dataProducer: DataProducer)
     */
    get observer() {
        return this._observer;
    }
    /**
     * Close the Transport.
     */
    close() {
        if (this._closed)
            return;
        logger.debug('close()');
        this._closed = true;
        // Close the AwaitQueue.
        this._awaitQueue.close();
        // Close the handler.
        this._handler.close();
        // Close all Producers.
        for (const producer of this._producers.values()) {
            producer.transportClosed();
        }
        this._producers.clear();
        // Close all Consumers.
        for (const consumer of this._consumers.values()) {
            consumer.transportClosed();
        }
        this._consumers.clear();
        // Close all DataProducers.
        for (const dataProducer of this._dataProducers.values()) {
            dataProducer.transportClosed();
        }
        this._dataProducers.clear();
        // Close all DataConsumers.
        for (const dataConsumer of this._dataConsumers.values()) {
            dataConsumer.transportClosed();
        }
        this._dataConsumers.clear();
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Get associated Transport (RTCPeerConnection) stats.
     *
     * @returns {RTCStatsReport}
     */
    async getStats() {
        if (this._closed)
            throw new errors_1.InvalidStateError('closed');
        return this._handler.getTransportStats();
    }
    /**
     * Restart ICE connection.
     */
    async restartIce({ iceParameters }) {
        logger.debug('restartIce()');
        if (this._closed)
            throw new errors_1.InvalidStateError('closed');
        else if (!iceParameters)
            throw new TypeError('missing iceParameters');
        // Enqueue command.
        return this._awaitQueue.push(async () => this._handler.restartIce(iceParameters), 'transport.restartIce()');
    }
    /**
     * Update ICE servers.
     */
    async updateIceServers({ iceServers } = {}) {
        logger.debug('updateIceServers()');
        if (this._closed)
            throw new errors_1.InvalidStateError('closed');
        else if (!Array.isArray(iceServers))
            throw new TypeError('missing iceServers');
        // Enqueue command.
        return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), 'transport.updateIceServers()');
    }
    /**
     * Create a Producer.
     */
    async produce({ track, encodings, codecOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, appData = {} } = {}) {
        logger.debug('produce() [track:%o]', track);
        if (!track)
            throw new TypeError('missing track');
        else if (this._direction !== 'send')
            throw new errors_1.UnsupportedError('not a sending Transport');
        else if (!this._canProduceByKind[track.kind])
            throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);
        else if (track.readyState === 'ended')
            throw new errors_1.InvalidStateError('track ended');
        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')
            throw new TypeError('no "connect" listener set into this transport');
        else if (this.listenerCount('produce') === 0)
            throw new TypeError('no "produce" listener set into this transport');
        else if (appData && typeof appData !== 'object')
            throw new TypeError('if given, appData must be an object');
        // Enqueue command.
        return this._awaitQueue.push(async () => {
            let normalizedEncodings;
            if (encodings && !Array.isArray(encodings)) {
                throw TypeError('encodings must be an array');
            }
            else if (encodings && encodings.length === 0) {
                normalizedEncodings = undefined;
            }
            else if (encodings) {
                normalizedEncodings = encodings
                    .map((encoding) => {
                    const normalizedEncoding = { active: true };
                    if (encoding.active === false)
                        normalizedEncoding.active = false;
                    if (typeof encoding.dtx === 'boolean')
                        normalizedEncoding.dtx = encoding.dtx;
                    if (typeof encoding.scalabilityMode === 'string')
                        normalizedEncoding.scalabilityMode = encoding.scalabilityMode;
                    if (typeof encoding.scaleResolutionDownBy === 'number')
                        normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;
                    if (typeof encoding.maxBitrate === 'number')
                        normalizedEncoding.maxBitrate = encoding.maxBitrate;
                    if (typeof encoding.maxFramerate === 'number')
                        normalizedEncoding.maxFramerate = encoding.maxFramerate;
                    if (typeof encoding.adaptivePtime === 'boolean')
                        normalizedEncoding.adaptivePtime = encoding.adaptivePtime;
                    if (typeof encoding.priority === 'string')
                        normalizedEncoding.priority = encoding.priority;
                    if (typeof encoding.networkPriority === 'string')
                        normalizedEncoding.networkPriority = encoding.networkPriority;
                    return normalizedEncoding;
                });
            }
            const { localId, rtpParameters, rtpSender } = await this._handler.send({
                track,
                encodings: normalizedEncodings,
                codecOptions,
                codec
            });
            try {
                // This will fill rtpParameters's missing fields with default values.
                ortc.validateRtpParameters(rtpParameters);
                const { id } = await this.safeEmitAsPromise('produce', {
                    kind: track.kind,
                    rtpParameters,
                    appData
                });
                const producer = new Producer_1.Producer({
                    id,
                    localId,
                    rtpSender,
                    track,
                    rtpParameters,
                    stopTracks,
                    disableTrackOnPause,
                    zeroRtpOnPause,
                    appData
                });
                this._producers.set(producer.id, producer);
                this._handleProducer(producer);
                // Emit observer event.
                this._observer.safeEmit('newproducer', producer);
                return producer;
            }
            catch (error) {
                this._handler.stopSending(localId)
                    .catch(() => { });
                throw error;
            }
        }, 'transport.produce()')
            // This catch is needed to stop the given track if the command above
            // failed due to closed Transport.
            .catch((error) => {
            if (stopTracks) {
                try {
                    track.stop();
                }
                catch (error2) { }
            }
            throw error;
        });
    }
    /**
     * Create a Consumer to consume a remote Producer.
     */
    async consume({ id, producerId, kind, rtpParameters, appData = {} }) {
        logger.debug('consume()');
        rtpParameters = utils.clone(rtpParameters, undefined);
        if (this._closed)
            throw new errors_1.InvalidStateError('closed');
        else if (this._direction !== 'recv')
            throw new errors_1.UnsupportedError('not a receiving Transport');
        else if (typeof id !== 'string')
            throw new TypeError('missing id');
        else if (typeof producerId !== 'string')
            throw new TypeError('missing producerId');
        else if (kind !== 'audio' && kind !== 'video')
            throw new TypeError(`invalid kind '${kind}'`);
        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')
            throw new TypeError('no "connect" listener set into this transport');
        else if (appData && typeof appData !== 'object')
            throw new TypeError('if given, appData must be an object');
        // Enqueue command.
        return this._awaitQueue.push(async () => {
            // Ensure the device can consume it.
            const canConsume = ortc.canReceive(rtpParameters, this._extendedRtpCapabilities);
            if (!canConsume)
                throw new errors_1.UnsupportedError('cannot consume this Producer');
            const { localId, rtpReceiver, track } = await this._handler.receive({ trackId: id, kind, rtpParameters });
            const consumer = new Consumer_1.Consumer({
                id,
                localId,
                producerId,
                rtpReceiver,
                track,
                rtpParameters,
                appData
            });
            this._consumers.set(consumer.id, consumer);
            this._handleConsumer(consumer);
            // If this is the first video Consumer and the Consumer for RTP probation
            // has not yet been created, create it now.
            if (!this._probatorConsumerCreated && kind === 'video') {
                try {
                    const probatorRtpParameters = ortc.generateProbatorRtpParameters(consumer.rtpParameters);
                    await this._handler.receive({
                        trackId: 'probator',
                        kind: 'video',
                        rtpParameters: probatorRtpParameters
                    });
                    logger.debug('consume() | Consumer for RTP probation created');
                    this._probatorConsumerCreated = true;
                }
                catch (error) {
                    logger.error('consume() | failed to create Consumer for RTP probation:%o', error);
                }
            }
            // Emit observer event.
            this._observer.safeEmit('newconsumer', consumer);
            return consumer;
        }, 'transport.consume()');
    }
    /**
     * Create a DataProducer
     */
    async produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, label = '', protocol = '', appData = {} } = {}) {
        logger.debug('produceData()');
        if (this._direction !== 'send')
            throw new errors_1.UnsupportedError('not a sending Transport');
        else if (!this._maxSctpMessageSize)
            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');
        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')
            throw new TypeError('no "connect" listener set into this transport');
        else if (this.listenerCount('producedata') === 0)
            throw new TypeError('no "producedata" listener set into this transport');
        else if (appData && typeof appData !== 'object')
            throw new TypeError('if given, appData must be an object');
        if (maxPacketLifeTime || maxRetransmits)
            ordered = false;
        // Enqueue command.
        return this._awaitQueue.push(async () => {
            const { dataChannel, sctpStreamParameters } = await this._handler.sendDataChannel({
                ordered,
                maxPacketLifeTime,
                maxRetransmits,
                label,
                protocol
            });
            // This will fill sctpStreamParameters's missing fields with default values.
            ortc.validateSctpStreamParameters(sctpStreamParameters);
            const { id } = await this.safeEmitAsPromise('producedata', {
                sctpStreamParameters,
                label,
                protocol,
                appData
            });
            const dataProducer = new DataProducer_1.DataProducer({ id, dataChannel, sctpStreamParameters, appData });
            this._dataProducers.set(dataProducer.id, dataProducer);
            this._handleDataProducer(dataProducer);
            // Emit observer event.
            this._observer.safeEmit('newdataproducer', dataProducer);
            return dataProducer;
        }, 'transport.produceData()');
    }
    /**
     * Create a DataConsumer
     */
    async consumeData({ id, dataProducerId, sctpStreamParameters, label = '', protocol = '', appData = {} }) {
        logger.debug('consumeData()');
        sctpStreamParameters = utils.clone(sctpStreamParameters, undefined);
        if (this._closed)
            throw new errors_1.InvalidStateError('closed');
        else if (this._direction !== 'recv')
            throw new errors_1.UnsupportedError('not a receiving Transport');
        else if (!this._maxSctpMessageSize)
            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');
        else if (typeof id !== 'string')
            throw new TypeError('missing id');
        else if (typeof dataProducerId !== 'string')
            throw new TypeError('missing dataProducerId');
        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')
            throw new TypeError('no "connect" listener set into this transport');
        else if (appData && typeof appData !== 'object')
            throw new TypeError('if given, appData must be an object');
        // This may throw.
        ortc.validateSctpStreamParameters(sctpStreamParameters);
        // Enqueue command.
        return this._awaitQueue.push(async () => {
            const { dataChannel } = await this._handler.receiveDataChannel({
                sctpStreamParameters,
                label,
                protocol
            });
            const dataConsumer = new DataConsumer_1.DataConsumer({
                id,
                dataProducerId,
                dataChannel,
                sctpStreamParameters,
                appData
            });
            this._dataConsumers.set(dataConsumer.id, dataConsumer);
            this._handleDataConsumer(dataConsumer);
            // Emit observer event.
            this._observer.safeEmit('newdataconsumer', dataConsumer);
            return dataConsumer;
        }, 'transport.consumeData()');
    }
    _handleHandler() {
        const handler = this._handler;
        handler.on('@connect', ({ dtlsParameters }, callback, errback) => {
            if (this._closed) {
                errback(new errors_1.InvalidStateError('closed'));
                return;
            }
            this.safeEmit('connect', { dtlsParameters }, callback, errback);
        });
        handler.on('@connectionstatechange', (connectionState) => {
            if (connectionState === this._connectionState)
                return;
            logger.debug('connection state changed to %s', connectionState);
            this._connectionState = connectionState;
            if (!this._closed)
                this.safeEmit('connectionstatechange', connectionState);
        });
    }
    _handleProducer(producer) {
        producer.on('@close', () => {
            this._producers.delete(producer.id);
            if (this._closed)
                return;
            this._awaitQueue.push(async () => this._handler.stopSending(producer.localId), 'producer @close event')
                .catch((error) => logger.warn('producer.close() failed:%o', error));
        });
        producer.on('@replacetrack', (track, callback, errback) => {
            this._awaitQueue.push(async () => this._handler.replaceTrack(producer.localId, track), 'producer @replacetrack event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@setmaxspatiallayer', (spatialLayer, callback, errback) => {
            this._awaitQueue.push(async () => (this._handler.setMaxSpatialLayer(producer.localId, spatialLayer)), 'producer @setmaxspatiallayer event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@setrtpencodingparameters', (params, callback, errback) => {
            this._awaitQueue.push(async () => (this._handler.setRtpEncodingParameters(producer.localId, params)), 'producer @setrtpencodingparameters event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@getstats', (callback, errback) => {
            if (this._closed)
                return errback(new errors_1.InvalidStateError('closed'));
            this._handler.getSenderStats(producer.localId)
                .then(callback)
                .catch(errback);
        });
    }
    _handleConsumer(consumer) {
        consumer.on('@close', () => {
            this._consumers.delete(consumer.id);
            if (this._closed)
                return;
            this._awaitQueue.push(async () => this._handler.stopReceiving(consumer.localId), 'consumer @close event')
                .catch(() => { });
        });
        consumer.on('@pause', () => {
            this._awaitQueue.push(async () => this._handler.pauseReceiving(consumer.localId), 'consumer @pause event')
                .catch(() => { });
        });
        consumer.on('@resume', () => {
            this._awaitQueue.push(async () => this._handler.resumeReceiving(consumer.localId), 'consumer @resume event')
                .catch(() => { });
        });
        consumer.on('@getstats', (callback, errback) => {
            if (this._closed)
                return errback(new errors_1.InvalidStateError('closed'));
            this._handler.getReceiverStats(consumer.localId)
                .then(callback)
                .catch(errback);
        });
    }
    _handleDataProducer(dataProducer) {
        dataProducer.on('@close', () => {
            this._dataProducers.delete(dataProducer.id);
        });
    }
    _handleDataConsumer(dataConsumer) {
        dataConsumer.on('@close', () => {
            this._dataConsumers.delete(dataConsumer.id);
        });
    }
}
exports.Transport = Transport;

},{"./Consumer":141,"./DataConsumer":142,"./DataProducer":143,"./EnhancedEventEmitter":145,"./Logger":146,"./Producer":147,"./errors":151,"./ortc":169,"./utils":172,"awaitqueue":136}],151:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidStateError = exports.UnsupportedError = void 0;
/**
 * Error indicating not support for something.
 */
class UnsupportedError extends Error {
    constructor(message) {
        super(message);
        this.name = 'UnsupportedError';
        if (Error.hasOwnProperty('captureStackTrace')) // Just in V8.
         {
            // @ts-ignore
            Error.captureStackTrace(this, UnsupportedError);
        }
        else {
            this.stack = (new Error(message)).stack;
        }
    }
}
exports.UnsupportedError = UnsupportedError;
/**
 * Error produced when calling a method in an invalid state.
 */
class InvalidStateError extends Error {
    constructor(message) {
        super(message);
        this.name = 'InvalidStateError';
        if (Error.hasOwnProperty('captureStackTrace')) // Just in V8.
         {
            // @ts-ignore
            Error.captureStackTrace(this, InvalidStateError);
        }
        else {
            this.stack = (new Error(message)).stack;
        }
    }
}
exports.InvalidStateError = InvalidStateError;

},{}],152:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chrome55 = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const errors_1 = require("../errors");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpPlanBUtils = __importStar(require("./sdp/planBUtils"));
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const logger = new Logger_1.Logger('Chrome55');
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Chrome55 extends HandlerInterface_1.HandlerInterface {
    constructor() {
        super();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Map of sending MediaStreamTracks indexed by localId.
        this._mapSendLocalIdTrack = new Map();
        // Next sending localId.
        this._nextSendLocalId = 0;
        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
        // Value is an Object with mid, rtpParameters and rtpReceiver.
        this._mapRecvLocalIdInfo = new Map();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Chrome55();
    }
    get name() {
        return 'Chrome55';
    }
    close() {
        logger.debug('close()');
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b'
        });
        try {
            const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
            });
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
        });
        this._sendingRtpParametersByKind =
            {
                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
            };
        this._sendingRemoteRtpParametersByKind =
            {
                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
            };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole = dtlsParameters.role === 'server'
                ? 'client'
                : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b',
            ...additionalSettings
        }, proprietaryConstraints);
        // Handle RTCPeerConnection connection status.
        this._pc.addEventListener('iceconnectionstatechange', () => {
            switch (this._pc.iceConnectionState) {
                case 'checking':
                    this.emit('@connectionstatechange', 'connecting');
                    break;
                case 'connected':
                case 'completed':
                    this.emit('@connectionstatechange', 'connected');
                    break;
                case 'failed':
                    this.emit('@connectionstatechange', 'failed');
                    break;
                case 'disconnected':
                    this.emit('@connectionstatechange', 'disconnected');
                    break;
                case 'closed':
                    this.emit('@connectionstatechange', 'closed');
                    break;
            }
        });
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady)
            return;
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec }) {
        var _a;
        this._assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (codec) {
            logger.warn('send() | codec selection is not available in %s handler', this.name);
        }
        this._sendStream.addTrack(track);
        this._pc.addStream(this._sendStream);
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        sendingRtpParameters.codecs =
            ortc.reduceCodecs(sendingRtpParameters.codecs);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        sendingRemoteRtpParameters.codecs =
            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
        if (!this._transportReady) {
            await this._setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject
            });
        }
        if (track.kind === 'video' && encodings && encodings.length > 1) {
            logger.debug('send() | enabling simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');
            sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media
            .find((m) => m.type === track.kind);
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname =
            sdpCommonUtils.getCname({ offerMediaObject });
        // Set RTP encodings.
        sendingRtpParameters.encodings =
            sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx])
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
            }
        }
        // If VP8 and there is effective simulcast, add scalabilityMode to each
        // encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'S1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        // Insert into the map.
        this._mapSendLocalIdTrack.set(localId, track);
        return {
            localId: localId,
            rtpParameters: sendingRtpParameters
        };
    }
    async stopSending(localId) {
        this._assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        const track = this._mapSendLocalIdTrack.get(localId);
        if (!track)
            throw new Error('track not found');
        this._mapSendLocalIdTrack.delete(localId);
        this._sendStream.removeTrack(track);
        this._pc.addStream(this._sendStream);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        try {
            await this._pc.setLocalDescription(offer);
        }
        catch (error) {
            // NOTE: If there are no sending tracks, setLocalDescription() will fail with
            // "Failed to create channels". If so, ignore it.
            if (this._sendStream.getTracks().length === 0) {
                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());
                return;
            }
            throw error;
        }
        if (this._pc.signalingState === 'stable')
            return;
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId, track) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setMaxSpatialLayer(localId, spatialLayer) {
        throw new errors_1.UnsupportedError(' not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setRtpEncodingParameters(localId, params) {
        throw new errors_1.UnsupportedError('not supported');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getSenderStats(localId) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
        var _a;
        this._assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media
                .find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this._setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                    localSdpObject
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive({ trackId, kind, rtpParameters }) {
        var _a;
        this._assertRecvDirection();
        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
        const localId = trackId;
        const mid = kind;
        const streamId = rtpParameters.rtcp.cname;
        this._remoteSdp.receive({
            mid,
            kind,
            offerRtpParameters: rtpParameters,
            streamId,
            trackId
        });
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        const answerMediaObject = localSdpObject.media
            .find((m) => String(m.mid) === mid);
        // May need to modify codec parameters in the answer based on codec
        // parameters in the offer.
        sdpCommonUtils.applyCodecParameters({
            offerRtpParameters: rtpParameters,
            answerMediaObject
        });
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this._setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        const stream = this._pc.getRemoteStreams()
            .find((s) => s.id === streamId);
        const track = stream.getTrackById(localId);
        if (!track)
            throw new Error('remote track not found');
        // Insert into the map.
        this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });
        return { localId, track };
    }
    async stopReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('stopReceiving() [localId:%s]', localId);
        const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};
        // Remove from the map.
        this._mapRecvLocalIdInfo.delete(localId);
        this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getReceiverStats(localId) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
        var _a;
        this._assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this._setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                    localSdpObject
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async _setupTransport({ localDtlsRole, localSdpObject }) {
        if (!localSdpObject)
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await this.safeEmitAsPromise('@connect', { dtlsParameters });
        this._transportReady = true;
    }
    _assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    _assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Chrome55 = Chrome55;

},{"../Logger":146,"../errors":151,"../ortc":169,"../utils":172,"./HandlerInterface":158,"./sdp/RemoteSdp":164,"./sdp/commonUtils":165,"./sdp/planBUtils":166,"sdp-transform":175}],153:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chrome67 = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpPlanBUtils = __importStar(require("./sdp/planBUtils"));
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const logger = new Logger_1.Logger('Chrome67');
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Chrome67 extends HandlerInterface_1.HandlerInterface {
    constructor() {
        super();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Map of RTCRtpSender indexed by localId.
        this._mapSendLocalIdRtpSender = new Map();
        // Next sending localId.
        this._nextSendLocalId = 0;
        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
        // Value is an Object with mid, rtpParameters and rtpReceiver.
        this._mapRecvLocalIdInfo = new Map();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Chrome67();
    }
    get name() {
        return 'Chrome67';
    }
    close() {
        logger.debug('close()');
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b'
        });
        try {
            const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
            });
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
        });
        this._sendingRtpParametersByKind =
            {
                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
            };
        this._sendingRemoteRtpParametersByKind =
            {
                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
            };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole = dtlsParameters.role === 'server'
                ? 'client'
                : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b',
            ...additionalSettings
        }, proprietaryConstraints);
        // Handle RTCPeerConnection connection status.
        this._pc.addEventListener('iceconnectionstatechange', () => {
            switch (this._pc.iceConnectionState) {
                case 'checking':
                    this.emit('@connectionstatechange', 'connecting');
                    break;
                case 'connected':
                case 'completed':
                    this.emit('@connectionstatechange', 'connected');
                    break;
                case 'failed':
                    this.emit('@connectionstatechange', 'failed');
                    break;
                case 'disconnected':
                    this.emit('@connectionstatechange', 'disconnected');
                    break;
                case 'closed':
                    this.emit('@connectionstatechange', 'closed');
                    break;
            }
        });
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady)
            return;
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec }) {
        var _a;
        this._assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (codec) {
            logger.warn('send() | codec selection is not available in %s handler', this.name);
        }
        this._sendStream.addTrack(track);
        this._pc.addTrack(track, this._sendStream);
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        sendingRtpParameters.codecs =
            ortc.reduceCodecs(sendingRtpParameters.codecs);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        sendingRemoteRtpParameters.codecs =
            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
        if (!this._transportReady) {
            await this._setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject
            });
        }
        if (track.kind === 'video' && encodings && encodings.length > 1) {
            logger.debug('send() | enabling simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media
                .find((m) => m.type === 'video');
            sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media
            .find((m) => m.type === track.kind);
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname =
            sdpCommonUtils.getCname({ offerMediaObject });
        // Set RTP encodings.
        sendingRtpParameters.encodings =
            sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx])
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
            }
        }
        // If VP8 and there is effective simulcast, add scalabilityMode to each
        // encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'S1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        const rtpSender = this._pc.getSenders()
            .find((s) => s.track === track);
        // Insert into the map.
        this._mapSendLocalIdRtpSender.set(localId, rtpSender);
        return {
            localId: localId,
            rtpParameters: sendingRtpParameters,
            rtpSender
        };
    }
    async stopSending(localId) {
        this._assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender)
            throw new Error('associated RTCRtpSender not found');
        this._pc.removeTrack(rtpSender);
        if (rtpSender.track)
            this._sendStream.removeTrack(rtpSender.track);
        this._mapSendLocalIdRtpSender.delete(localId);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        try {
            await this._pc.setLocalDescription(offer);
        }
        catch (error) {
            // NOTE: If there are no sending tracks, setLocalDescription() will fail with
            // "Failed to create channels". If so, ignore it.
            if (this._sendStream.getTracks().length === 0) {
                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());
                return;
            }
            throw error;
        }
        if (this._pc.signalingState === 'stable')
            return;
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this._assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender)
            throw new Error('associated RTCRtpSender not found');
        const oldTrack = rtpSender.track;
        await rtpSender.replaceTrack(track);
        // Remove the old track from the local stream.
        if (oldTrack)
            this._sendStream.removeTrack(oldTrack);
        // Add the new track to the local stream.
        if (track)
            this._sendStream.addTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this._assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender)
            throw new Error('associated RTCRtpSender not found');
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer)
                encoding.active = true;
            else
                encoding.active = false;
        });
        await rtpSender.setParameters(parameters);
    }
    async setRtpEncodingParameters(localId, params) {
        this._assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender)
            throw new Error('associated RTCRtpSender not found');
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await rtpSender.setParameters(parameters);
    }
    async getSenderStats(localId) {
        this._assertSendDirection();
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender)
            throw new Error('associated RTCRtpSender not found');
        return rtpSender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
        var _a;
        this._assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media
                .find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this._setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                    localSdpObject
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive({ trackId, kind, rtpParameters }) {
        var _a;
        this._assertRecvDirection();
        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
        const localId = trackId;
        const mid = kind;
        this._remoteSdp.receive({
            mid,
            kind,
            offerRtpParameters: rtpParameters,
            streamId: rtpParameters.rtcp.cname,
            trackId
        });
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        const answerMediaObject = localSdpObject.media
            .find((m) => String(m.mid) === mid);
        // May need to modify codec parameters in the answer based on codec
        // parameters in the offer.
        sdpCommonUtils.applyCodecParameters({
            offerRtpParameters: rtpParameters,
            answerMediaObject
        });
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this._setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        const rtpReceiver = this._pc.getReceivers()
            .find((r) => r.track && r.track.id === localId);
        if (!rtpReceiver)
            throw new Error('new RTCRtpReceiver not');
        // Insert into the map.
        this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters, rtpReceiver });
        return {
            localId,
            track: rtpReceiver.track,
            rtpReceiver
        };
    }
    async stopReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('stopReceiving() [localId:%s]', localId);
        const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};
        // Remove from the map.
        this._mapRecvLocalIdInfo.delete(localId);
        this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId) {
        // Unimplemented.
    }
    async getReceiverStats(localId) {
        this._assertRecvDirection();
        const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};
        if (!rtpReceiver)
            throw new Error('associated RTCRtpReceiver not found');
        return rtpReceiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
        var _a;
        this._assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this._setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                    localSdpObject
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async _setupTransport({ localDtlsRole, localSdpObject }) {
        if (!localSdpObject)
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await this.safeEmitAsPromise('@connect', { dtlsParameters });
        this._transportReady = true;
    }
    _assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    _assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Chrome67 = Chrome67;

},{"../Logger":146,"../ortc":169,"../utils":172,"./HandlerInterface":158,"./sdp/RemoteSdp":164,"./sdp/commonUtils":165,"./sdp/planBUtils":166,"sdp-transform":175}],154:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chrome70 = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpUnifiedPlanUtils = __importStar(require("./sdp/unifiedPlanUtils"));
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const scalabilityModes_1 = require("../scalabilityModes");
const logger = new Logger_1.Logger('Chrome70');
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Chrome70 extends HandlerInterface_1.HandlerInterface {
    constructor() {
        super();
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Chrome70();
    }
    get name() {
        return 'Chrome70';
    }
    close() {
        logger.debug('close()');
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan'
        });
        try {
            pc.addTransceiver('audio');
            pc.addTransceiver('video');
            const offer = await pc.createOffer();
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
        });
        this._sendingRtpParametersByKind =
            {
                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
            };
        this._sendingRemoteRtpParametersByKind =
            {
                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
            };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole = dtlsParameters.role === 'server'
                ? 'client'
                : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
            ...additionalSettings
        }, proprietaryConstraints);
        // Handle RTCPeerConnection connection status.
        this._pc.addEventListener('iceconnectionstatechange', () => {
            switch (this._pc.iceConnectionState) {
                case 'checking':
                    this.emit('@connectionstatechange', 'connecting');
                    break;
                case 'connected':
                case 'completed':
                    this.emit('@connectionstatechange', 'connected');
                    break;
                case 'failed':
                    this.emit('@connectionstatechange', 'failed');
                    break;
                case 'disconnected':
                    this.emit('@connectionstatechange', 'disconnected');
                    break;
                case 'closed':
                    this.emit('@connectionstatechange', 'closed');
                    break;
            }
        });
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady)
            return;
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec }) {
        var _a;
        this._assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRtpParameters.codecs =
            ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRemoteRtpParameters.codecs =
            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, { direction: 'sendonly', streams: [this._sendStream] });
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        if (!this._transportReady) {
            await this._setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject
            });
        }
        if (encodings && encodings.length > 1) {
            logger.debug('send() | enabling legacy simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: encodings.length
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        // Special case for VP9 with SVC.
        let hackVp9Svc = false;
        const layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);
        if (encodings &&
            encodings.length === 1 &&
            layers.spatialLayers > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
            logger.debug('send() | enabling legacy simulcast for VP9 SVC');
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: layers.spatialLayers
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // If encodings are given, apply them now.
        if (encodings) {
            logger.debug('send() | applying given encodings');
            const parameters = transceiver.sender.getParameters();
            for (let idx = 0; idx < (parameters.encodings || []).length; ++idx) {
                const encoding = parameters.encodings[idx];
                const desiredEncoding = encodings[idx];
                // Should not happen but just in case.
                if (!desiredEncoding)
                    break;
                parameters.encodings[idx] = Object.assign(encoding, desiredEncoding);
            }
            await transceiver.sender.setParameters(parameters);
        }
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname =
            sdpCommonUtils.getCname({ offerMediaObject });
        // Set RTP encodings.
        sendingRtpParameters.encodings =
            sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx])
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
            }
        }
        // Hack for VP9 SVC.
        if (hackVp9Svc) {
            sendingRtpParameters.encodings = [sendingRtpParameters.encodings[0]];
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'S1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
        };
    }
    async stopSending(localId) {
        this._assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        this._remoteSdp.closeMediaSection(transceiver.mid);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async replaceTrack(localId, track) {
        this._assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this._assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer)
                encoding.active = true;
            else
                encoding.active = false;
        });
        await transceiver.sender.setParameters(parameters);
    }
    async setRtpEncodingParameters(localId, params) {
        this._assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
    }
    async getSenderStats(localId) {
        this._assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
        var _a;
        this._assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media
                .find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this._setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                    localSdpObject
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive({ trackId, kind, rtpParameters }) {
        var _a;
        this._assertRecvDirection();
        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
        const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
        this._remoteSdp.receive({
            mid: localId,
            kind,
            offerRtpParameters: rtpParameters,
            streamId: rtpParameters.rtcp.cname,
            trackId
        });
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        const answerMediaObject = localSdpObject.media
            .find((m) => String(m.mid) === localId);
        // May need to modify codec parameters in the answer based on codec
        // parameters in the offer.
        sdpCommonUtils.applyCodecParameters({
            offerRtpParameters: rtpParameters,
            answerMediaObject
        });
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this._setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        const transceiver = this._pc.getTransceivers()
            .find((t) => t.mid === localId);
        if (!transceiver)
            throw new Error('new RTCRtpTransceiver not found');
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            track: transceiver.receiver.track,
            rtpReceiver: transceiver.receiver
        };
    }
    async stopReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('stopReceiving() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        this._remoteSdp.closeMediaSection(transceiver.mid);
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId) {
        // Unimplemented.
    }
    async getReceiverStats(localId) {
        this._assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
        var _a;
        this._assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this._setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                    localSdpObject
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async _setupTransport({ localDtlsRole, localSdpObject }) {
        if (!localSdpObject)
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await this.safeEmitAsPromise('@connect', { dtlsParameters });
        this._transportReady = true;
    }
    _assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    _assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Chrome70 = Chrome70;

},{"../Logger":146,"../ortc":169,"../scalabilityModes":170,"../utils":172,"./HandlerInterface":158,"./sdp/RemoteSdp":164,"./sdp/commonUtils":165,"./sdp/unifiedPlanUtils":167,"sdp-transform":175}],155:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chrome74 = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpUnifiedPlanUtils = __importStar(require("./sdp/unifiedPlanUtils"));
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const scalabilityModes_1 = require("../scalabilityModes");
const logger = new Logger_1.Logger('Chrome74');
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Chrome74 extends HandlerInterface_1.HandlerInterface {
    constructor() {
        super();
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Chrome74();
    }
    get name() {
        return 'Chrome74';
    }
    close() {
        logger.debug('close()');
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan'
        });
        try {
            pc.addTransceiver('audio');
            pc.addTransceiver('video');
            const offer = await pc.createOffer();
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
        });
        this._sendingRtpParametersByKind =
            {
                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
            };
        this._sendingRemoteRtpParametersByKind =
            {
                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
            };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole = dtlsParameters.role === 'server'
                ? 'client'
                : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan',
            ...additionalSettings
        }, proprietaryConstraints);
        // Handle RTCPeerConnection connection status.
        this._pc.addEventListener('iceconnectionstatechange', () => {
            switch (this._pc.iceConnectionState) {
                case 'checking':
                    this.emit('@connectionstatechange', 'connecting');
                    break;
                case 'connected':
                case 'completed':
                    this.emit('@connectionstatechange', 'connected');
                    break;
                case 'failed':
                    this.emit('@connectionstatechange', 'failed');
                    break;
                case 'disconnected':
                    this.emit('@connectionstatechange', 'disconnected');
                    break;
                case 'closed':
                    this.emit('@connectionstatechange', 'closed');
                    break;
            }
        });
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady)
            return;
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec }) {
        var _a;
        this._assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
            });
        }
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRtpParameters.codecs =
            ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRemoteRtpParameters.codecs =
            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
            sendEncodings: encodings
        });
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        if (!this._transportReady) {
            await this._setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject
            });
        }
        // Special case for VP9 with SVC.
        let hackVp9Svc = false;
        const layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);
        if (encodings &&
            encodings.length === 1 &&
            layers.spatialLayers > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
            logger.debug('send() | enabling legacy simulcast for VP9 SVC');
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: layers.spatialLayers
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname =
            sdpCommonUtils.getCname({ offerMediaObject });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) {
            sendingRtpParameters.encodings =
                sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });
        }
        // Set RTP encodings by parsing the SDP offer and complete them with given
        // one if just a single encoding has been given.
        else if (encodings.length === 1) {
            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });
            Object.assign(newEncodings[0], encodings[0]);
            // Hack for VP9 SVC.
            if (hackVp9Svc)
                newEncodings = [newEncodings[0]];
            sendingRtpParameters.encodings = newEncodings;
        }
        // Otherwise if more than 1 encoding are given use them verbatim.
        else {
            sendingRtpParameters.encodings = encodings;
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'S1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
        };
    }
    async stopSending(localId) {
        this._assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        this._remoteSdp.closeMediaSection(transceiver.mid);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async replaceTrack(localId, track) {
        this._assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this._assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer)
                encoding.active = true;
            else
                encoding.active = false;
        });
        await transceiver.sender.setParameters(parameters);
    }
    async setRtpEncodingParameters(localId, params) {
        this._assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
    }
    async getSenderStats(localId) {
        this._assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
        var _a;
        this._assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media
                .find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this._setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                    localSdpObject
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive({ trackId, kind, rtpParameters }) {
        var _a;
        this._assertRecvDirection();
        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
        const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
        this._remoteSdp.receive({
            mid: localId,
            kind,
            offerRtpParameters: rtpParameters,
            streamId: rtpParameters.rtcp.cname,
            trackId
        });
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        const answerMediaObject = localSdpObject.media
            .find((m) => String(m.mid) === localId);
        // May need to modify codec parameters in the answer based on codec
        // parameters in the offer.
        sdpCommonUtils.applyCodecParameters({
            offerRtpParameters: rtpParameters,
            answerMediaObject
        });
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this._setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        const transceiver = this._pc.getTransceivers()
            .find((t) => t.mid === localId);
        if (!transceiver)
            throw new Error('new RTCRtpTransceiver not found');
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            track: transceiver.receiver.track,
            rtpReceiver: transceiver.receiver
        };
    }
    async stopReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('stopReceiving() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        this._remoteSdp.closeMediaSection(transceiver.mid);
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('pauseReceiving() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        transceiver.direction = 'inactive';
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('resumeReceiving() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        transceiver.direction = 'recvonly';
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this._assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
        var _a;
        this._assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this._setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                    localSdpObject
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async _setupTransport({ localDtlsRole, localSdpObject }) {
        if (!localSdpObject)
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await this.safeEmitAsPromise('@connect', { dtlsParameters });
        this._transportReady = true;
    }
    _assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    _assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Chrome74 = Chrome74;

},{"../Logger":146,"../ortc":169,"../scalabilityModes":170,"../utils":172,"./HandlerInterface":158,"./sdp/RemoteSdp":164,"./sdp/commonUtils":165,"./sdp/unifiedPlanUtils":167,"sdp-transform":175}],156:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Edge11 = void 0;
const Logger_1 = require("../Logger");
const errors_1 = require("../errors");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const edgeUtils = __importStar(require("./ortc/edgeUtils"));
const HandlerInterface_1 = require("./HandlerInterface");
const logger = new Logger_1.Logger('Edge11');
class Edge11 extends HandlerInterface_1.HandlerInterface {
    constructor() {
        super();
        // Map of RTCRtpSenders indexed by id.
        this._rtpSenders = new Map();
        // Map of RTCRtpReceivers indexed by id.
        this._rtpReceivers = new Map();
        // Next localId for sending tracks.
        this._nextSendLocalId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Edge11();
    }
    get name() {
        return 'Edge11';
    }
    close() {
        logger.debug('close()');
        // Close the ICE gatherer.
        // NOTE: Not yet implemented by Edge.
        try {
            this._iceGatherer.close();
        }
        catch (error) { }
        // Close the ICE transport.
        try {
            this._iceTransport.stop();
        }
        catch (error) { }
        // Close the DTLS transport.
        try {
            this._dtlsTransport.stop();
        }
        catch (error) { }
        // Close RTCRtpSenders.
        for (const rtpSender of this._rtpSenders.values()) {
            try {
                rtpSender.stop();
            }
            catch (error) { }
        }
        // Close RTCRtpReceivers.
        for (const rtpReceiver of this._rtpReceivers.values()) {
            try {
                rtpReceiver.stop();
            }
            catch (error) { }
        }
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        return edgeUtils.getCapabilities();
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: { OS: 0, MIS: 0 }
        };
    }
    run({ direction, // eslint-disable-line @typescript-eslint/no-unused-vars
    iceParameters, iceCandidates, dtlsParameters, sctpParameters, // eslint-disable-line @typescript-eslint/no-unused-vars
    iceServers, iceTransportPolicy, additionalSettings, // eslint-disable-line @typescript-eslint/no-unused-vars
    proprietaryConstraints, // eslint-disable-line @typescript-eslint/no-unused-vars
    extendedRtpCapabilities }) {
        logger.debug('run()');
        this._sendingRtpParametersByKind =
            {
                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
            };
        this._remoteIceParameters = iceParameters;
        this._remoteIceCandidates = iceCandidates;
        this._remoteDtlsParameters = dtlsParameters;
        this._cname = `CNAME-${utils.generateRandomNumber()}`;
        this._setIceGatherer({ iceServers, iceTransportPolicy });
        this._setIceTransport();
        this._setDtlsTransport();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async updateIceServers(iceServers) {
        // NOTE: Edge 11 does not implement iceGatherer.gater().
        throw new errors_1.UnsupportedError('not supported');
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        this._remoteIceParameters = iceParameters;
        if (!this._transportReady)
            return;
        logger.debug('restartIce() | calling iceTransport.start()');
        this._iceTransport.start(this._iceGatherer, iceParameters, 'controlling');
        for (const candidate of this._remoteIceCandidates) {
            this._iceTransport.addRemoteCandidate(candidate);
        }
        this._iceTransport.addRemoteCandidate({});
    }
    async getTransportStats() {
        return this._iceTransport.getStats();
    }
    async send(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    { track, encodings, codecOptions, codec }) {
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (!this._transportReady)
            await this._setupTransport({ localDtlsRole: 'server' });
        logger.debug('send() | calling new RTCRtpSender()');
        const rtpSender = new RTCRtpSender(track, this._dtlsTransport);
        const rtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        rtpParameters.codecs = ortc.reduceCodecs(rtpParameters.codecs, codec);
        const useRtx = rtpParameters.codecs
            .some((_codec) => /.+\/rtx$/i.test(_codec.mimeType));
        if (!encodings)
            encodings = [{}];
        for (const encoding of encodings) {
            encoding.ssrc = utils.generateRandomNumber();
            if (useRtx)
                encoding.rtx = { ssrc: utils.generateRandomNumber() };
        }
        rtpParameters.encodings = encodings;
        // Fill RTCRtpParameters.rtcp.
        rtpParameters.rtcp =
            {
                cname: this._cname,
                reducedSize: true,
                mux: true
            };
        // NOTE: Convert our standard RTCRtpParameters into those that Edge
        // expects.
        const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
        logger.debug('send() | calling rtpSender.send() [params:%o]', edgeRtpParameters);
        await rtpSender.send(edgeRtpParameters);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        // Store it.
        this._rtpSenders.set(localId, rtpSender);
        return { localId, rtpParameters, rtpSender };
    }
    async stopSending(localId) {
        logger.debug('stopSending() [localId:%s]', localId);
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender)
            throw new Error('RTCRtpSender not found');
        this._rtpSenders.delete(localId);
        try {
            logger.debug('stopSending() | calling rtpSender.stop()');
            rtpSender.stop();
        }
        catch (error) {
            logger.warn('stopSending() | rtpSender.stop() failed:%o', error);
            throw error;
        }
    }
    async replaceTrack(localId, track) {
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender)
            throw new Error('RTCRtpSender not found');
        rtpSender.setTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender)
            throw new Error('RTCRtpSender not found');
        const parameters = rtpSender.getParameters();
        parameters.encodings
            .forEach((encoding, idx) => {
            if (idx <= spatialLayer)
                encoding.active = true;
            else
                encoding.active = false;
        });
        await rtpSender.setParameters(parameters);
    }
    async setRtpEncodingParameters(localId, params) {
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender)
            throw new Error('RTCRtpSender not found');
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await rtpSender.setParameters(parameters);
    }
    async getSenderStats(localId) {
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender)
            throw new Error('RTCRtpSender not found');
        return rtpSender.getStats();
    }
    async sendDataChannel(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    options) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async receive({ trackId, kind, rtpParameters }) {
        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
        if (!this._transportReady)
            await this._setupTransport({ localDtlsRole: 'server' });
        logger.debug('receive() | calling new RTCRtpReceiver()');
        const rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, kind);
        rtpReceiver.addEventListener('error', (event) => {
            logger.error('rtpReceiver "error" event [event:%o]', event);
        });
        // NOTE: Convert our standard RTCRtpParameters into those that Edge
        // expects.
        const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
        logger.debug('receive() | calling rtpReceiver.receive() [params:%o]', edgeRtpParameters);
        await rtpReceiver.receive(edgeRtpParameters);
        const localId = trackId;
        // Store it.
        this._rtpReceivers.set(localId, rtpReceiver);
        return {
            localId,
            track: rtpReceiver.track,
            rtpReceiver
        };
    }
    async stopReceiving(localId) {
        logger.debug('stopReceiving() [localId:%s]', localId);
        const rtpReceiver = this._rtpReceivers.get(localId);
        if (!rtpReceiver)
            throw new Error('RTCRtpReceiver not found');
        this._rtpReceivers.delete(localId);
        try {
            logger.debug('stopReceiving() | calling rtpReceiver.stop()');
            rtpReceiver.stop();
        }
        catch (error) {
            logger.warn('stopReceiving() | rtpReceiver.stop() failed:%o', error);
        }
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId) {
        // Unimplemented.
    }
    async getReceiverStats(localId) {
        const rtpReceiver = this._rtpReceivers.get(localId);
        if (!rtpReceiver)
            throw new Error('RTCRtpReceiver not found');
        return rtpReceiver.getStats();
    }
    async receiveDataChannel(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    options) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    _setIceGatherer({ iceServers, iceTransportPolicy }) {
        // @ts-ignore
        const iceGatherer = new RTCIceGatherer({
            iceServers: iceServers || [],
            gatherPolicy: iceTransportPolicy || 'all'
        });
        iceGatherer.addEventListener('error', (event) => {
            logger.error('iceGatherer "error" event [event:%o]', event);
        });
        // NOTE: Not yet implemented by Edge, which starts gathering automatically.
        try {
            iceGatherer.gather();
        }
        catch (error) {
            logger.debug('_setIceGatherer() | iceGatherer.gather() failed: %s', error.toString());
        }
        this._iceGatherer = iceGatherer;
    }
    _setIceTransport() {
        const iceTransport = new RTCIceTransport(this._iceGatherer);
        // NOTE: Not yet implemented by Edge.
        iceTransport.addEventListener('statechange', () => {
            switch (iceTransport.state) {
                case 'checking':
                    this.emit('@connectionstatechange', 'connecting');
                    break;
                case 'connected':
                case 'completed':
                    this.emit('@connectionstatechange', 'connected');
                    break;
                case 'failed':
                    this.emit('@connectionstatechange', 'failed');
                    break;
                case 'disconnected':
                    this.emit('@connectionstatechange', 'disconnected');
                    break;
                case 'closed':
                    this.emit('@connectionstatechange', 'closed');
                    break;
            }
        });
        // NOTE: Not standard, but implemented by Edge.
        iceTransport.addEventListener('icestatechange', () => {
            switch (iceTransport.state) {
                case 'checking':
                    this.emit('@connectionstatechange', 'connecting');
                    break;
                case 'connected':
                case 'completed':
                    this.emit('@connectionstatechange', 'connected');
                    break;
                case 'failed':
                    this.emit('@connectionstatechange', 'failed');
                    break;
                case 'disconnected':
                    this.emit('@connectionstatechange', 'disconnected');
                    break;
                case 'closed':
                    this.emit('@connectionstatechange', 'closed');
                    break;
            }
        });
        iceTransport.addEventListener('candidatepairchange', (event) => {
            logger.debug('iceTransport "candidatepairchange" event [pair:%o]', event.pair);
        });
        this._iceTransport = iceTransport;
    }
    _setDtlsTransport() {
        const dtlsTransport = new RTCDtlsTransport(this._iceTransport);
        // NOTE: Not yet implemented by Edge.
        dtlsTransport.addEventListener('statechange', () => {
            logger.debug('dtlsTransport "statechange" event [state:%s]', dtlsTransport.state);
        });
        // NOTE: Not standard, but implemented by Edge.
        dtlsTransport.addEventListener('dtlsstatechange', () => {
            logger.debug('dtlsTransport "dtlsstatechange" event [state:%s]', dtlsTransport.state);
            if (dtlsTransport.state === 'closed')
                this.emit('@connectionstatechange', 'closed');
        });
        dtlsTransport.addEventListener('error', (event) => {
            logger.error('dtlsTransport "error" event [event:%o]', event);
        });
        this._dtlsTransport = dtlsTransport;
    }
    async _setupTransport({ localDtlsRole }) {
        logger.debug('_setupTransport()');
        // Get our local DTLS parameters.
        const dtlsParameters = this._dtlsTransport.getLocalParameters();
        dtlsParameters.role = localDtlsRole;
        // Need to tell the remote transport about our parameters.
        await this.safeEmitAsPromise('@connect', { dtlsParameters });
        // Start the RTCIceTransport.
        this._iceTransport.start(this._iceGatherer, this._remoteIceParameters, 'controlling');
        // Add remote ICE candidates.
        for (const candidate of this._remoteIceCandidates) {
            this._iceTransport.addRemoteCandidate(candidate);
        }
        // Also signal a 'complete' candidate as per spec.
        // NOTE: It should be {complete: true} but Edge prefers {}.
        // NOTE: If we don't signal end of candidates, the Edge RTCIceTransport
        // won't enter the 'completed' state.
        this._iceTransport.addRemoteCandidate({});
        // NOTE: Edge does not like SHA less than 256.
        this._remoteDtlsParameters.fingerprints = this._remoteDtlsParameters.fingerprints
            .filter((fingerprint) => {
            return (fingerprint.algorithm === 'sha-256' ||
                fingerprint.algorithm === 'sha-384' ||
                fingerprint.algorithm === 'sha-512');
        });
        // Start the RTCDtlsTransport.
        this._dtlsTransport.start(this._remoteDtlsParameters);
        this._transportReady = true;
    }
}
exports.Edge11 = Edge11;

},{"../Logger":146,"../errors":151,"../ortc":169,"../utils":172,"./HandlerInterface":158,"./ortc/edgeUtils":162}],157:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Firefox60 = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const errors_1 = require("../errors");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpUnifiedPlanUtils = __importStar(require("./sdp/unifiedPlanUtils"));
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const logger = new Logger_1.Logger('Firefox60');
const SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };
class Firefox60 extends HandlerInterface_1.HandlerInterface {
    constructor() {
        super();
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Firefox60();
    }
    get name() {
        return 'Firefox60';
    }
    close() {
        logger.debug('close()');
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require'
        });
        // NOTE: We need to add a real video track to get the RID extension mapping.
        const canvas = document.createElement('canvas');
        // NOTE: Otherwise Firefox fails in next line.
        canvas.getContext('2d');
        const fakeStream = canvas.captureStream();
        const fakeVideoTrack = fakeStream.getVideoTracks()[0];
        try {
            pc.addTransceiver('audio', { direction: 'sendrecv' });
            const videoTransceiver = pc.addTransceiver(fakeVideoTrack, { direction: 'sendrecv' });
            const parameters = videoTransceiver.sender.getParameters();
            const encodings = [
                { rid: 'r0', maxBitrate: 100000 },
                { rid: 'r1', maxBitrate: 500000 }
            ];
            parameters.encodings = encodings;
            await videoTransceiver.sender.setParameters(parameters);
            const offer = await pc.createOffer();
            try {
                canvas.remove();
            }
            catch (error) { }
            try {
                fakeVideoTrack.stop();
            }
            catch (error) { }
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                canvas.remove();
            }
            catch (error2) { }
            try {
                fakeVideoTrack.stop();
            }
            catch (error2) { }
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
        });
        this._sendingRtpParametersByKind =
            {
                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
            };
        this._sendingRemoteRtpParametersByKind =
            {
                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
            };
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            ...additionalSettings
        }, proprietaryConstraints);
        // Handle RTCPeerConnection connection status.
        this._pc.addEventListener('iceconnectionstatechange', () => {
            switch (this._pc.iceConnectionState) {
                case 'checking':
                    this.emit('@connectionstatechange', 'connecting');
                    break;
                case 'connected':
                case 'completed':
                    this.emit('@connectionstatechange', 'connected');
                    break;
                case 'failed':
                    this.emit('@connectionstatechange', 'failed');
                    break;
                case 'disconnected':
                    this.emit('@connectionstatechange', 'disconnected');
                    break;
                case 'closed':
                    this.emit('@connectionstatechange', 'closed');
                    break;
            }
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async updateIceServers(iceServers) {
        // NOTE: Firefox does not implement pc.setConfiguration().
        throw new errors_1.UnsupportedError('not supported');
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady)
            return;
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec }) {
        this._assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (encodings) {
            encodings = utils.clone(encodings, []);
            if (encodings.length > 1) {
                encodings.forEach((encoding, idx) => {
                    encoding.rid = `r${idx}`;
                });
                // Clone the encodings and reverse them because Firefox likes them
                // from high to low.
                encodings.reverse();
            }
        }
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRtpParameters.codecs =
            ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRemoteRtpParameters.codecs =
            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        // NOTE: Firefox fails sometimes to properly anticipate the closed media
        // section that it should use, so don't reuse closed media sections.
        //   https://github.com/versatica/mediasoup-client/issues/104
        //
        // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, { direction: 'sendonly', streams: [this._sendStream] });
        // NOTE: This is not spec compliants. Encodings should be given in addTransceiver
        // second argument, but Firefox does not support it.
        if (encodings) {
            const parameters = transceiver.sender.getParameters();
            parameters.encodings = encodings;
            await transceiver.sender.setParameters(parameters);
        }
        const offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        // In Firefox use DTLS role client even if we are the "offerer" since
        // Firefox does not respect ICE-Lite.
        if (!this._transportReady)
            await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname =
            sdpCommonUtils.getCname({ offerMediaObject });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) {
            sendingRtpParameters.encodings =
                sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });
        }
        // Set RTP encodings by parsing the SDP offer and complete them with given
        // one if just a single encoding has been given.
        else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
        }
        // Otherwise if more than 1 encoding are given use them verbatim (but
        // reverse them back since we reversed them above to satisfy Firefox).
        else {
            sendingRtpParameters.encodings = encodings.reverse();
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'S1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
        };
    }
    async stopSending(localId) {
        logger.debug('stopSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated transceiver not found');
        transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        // NOTE: Cannot use closeMediaSection() due to the the note above in send()
        // method.
        // this._remoteSdp!.closeMediaSection(transceiver.mid);
        this._remoteSdp.disableMediaSection(transceiver.mid);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async replaceTrack(localId, track) {
        this._assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this._assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated transceiver not found');
        const parameters = transceiver.sender.getParameters();
        // NOTE: We require encodings given from low to high, however Firefox
        // requires them in reverse order, so do magic here.
        spatialLayer = parameters.encodings.length - 1 - spatialLayer;
        parameters.encodings.forEach((encoding, idx) => {
            if (idx >= spatialLayer)
                encoding.active = true;
            else
                encoding.active = false;
        });
        await transceiver.sender.setParameters(parameters);
    }
    async setRtpEncodingParameters(localId, params) {
        this._assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
    }
    async getSenderStats(localId) {
        this._assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
        this._assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media
                .find((m) => m.type === 'application');
            if (!this._transportReady)
                await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive({ trackId, kind, rtpParameters }) {
        this._assertRecvDirection();
        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
        const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
        this._remoteSdp.receive({
            mid: localId,
            kind,
            offerRtpParameters: rtpParameters,
            streamId: rtpParameters.rtcp.cname,
            trackId
        });
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        const answerMediaObject = localSdpObject.media
            .find((m) => String(m.mid) === localId);
        // May need to modify codec parameters in the answer based on codec
        // parameters in the offer.
        sdpCommonUtils.applyCodecParameters({
            offerRtpParameters: rtpParameters,
            answerMediaObject
        });
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady)
            await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        const transceiver = this._pc.getTransceivers()
            .find((t) => t.mid === localId);
        if (!transceiver)
            throw new Error('new RTCRtpTransceiver not found');
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            track: transceiver.receiver.track,
            rtpReceiver: transceiver.receiver
        };
    }
    async stopReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('stopReceiving() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        this._remoteSdp.closeMediaSection(transceiver.mid);
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('pauseReceiving() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        transceiver.direction = 'inactive';
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('resumeReceiving() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        transceiver.direction = 'recvonly';
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this._assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
        this._assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async _setupTransport({ localDtlsRole, localSdpObject }) {
        if (!localSdpObject)
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await this.safeEmitAsPromise('@connect', { dtlsParameters });
        this._transportReady = true;
    }
    _assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    _assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Firefox60 = Firefox60;

},{"../Logger":146,"../errors":151,"../ortc":169,"../utils":172,"./HandlerInterface":158,"./sdp/RemoteSdp":164,"./sdp/commonUtils":165,"./sdp/unifiedPlanUtils":167,"sdp-transform":175}],158:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HandlerInterface = void 0;
const EnhancedEventEmitter_1 = require("../EnhancedEventEmitter");
class HandlerInterface extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    /**
     * @emits @connect - (
     *     { dtlsParameters: DtlsParameters },
     *     callback: Function,
     *     errback: Function
     *   )
     * @emits @connectionstatechange - (connectionState: ConnectionState)
     */
    constructor() {
        super();
    }
}
exports.HandlerInterface = HandlerInterface;

},{"../EnhancedEventEmitter":145}],159:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReactNative = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const errors_1 = require("../errors");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpPlanBUtils = __importStar(require("./sdp/planBUtils"));
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const logger = new Logger_1.Logger('ReactNative');
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class ReactNative extends HandlerInterface_1.HandlerInterface {
    constructor() {
        super();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Map of sending MediaStreamTracks indexed by localId.
        this._mapSendLocalIdTrack = new Map();
        // Next sending localId.
        this._nextSendLocalId = 0;
        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
        // Value is an Object with mid, rtpParameters and rtpReceiver.
        this._mapRecvLocalIdInfo = new Map();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new ReactNative();
    }
    get name() {
        return 'ReactNative';
    }
    close() {
        logger.debug('close()');
        // Free/dispose native MediaStream but DO NOT free/dispose native
        // MediaStreamTracks (that is parent's business).
        // @ts-ignore (proprietary API in react-native-webrtc).
        this._sendStream.release(/* releaseTracks */ false);
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b'
        });
        try {
            const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
            });
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
        });
        this._sendingRtpParametersByKind =
            {
                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
            };
        this._sendingRemoteRtpParametersByKind =
            {
                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
            };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole = dtlsParameters.role === 'server'
                ? 'client'
                : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b',
            ...additionalSettings
        }, proprietaryConstraints);
        // Handle RTCPeerConnection connection status.
        this._pc.addEventListener('iceconnectionstatechange', () => {
            switch (this._pc.iceConnectionState) {
                case 'checking':
                    this.emit('@connectionstatechange', 'connecting');
                    break;
                case 'connected':
                case 'completed':
                    this.emit('@connectionstatechange', 'connected');
                    break;
                case 'failed':
                    this.emit('@connectionstatechange', 'failed');
                    break;
                case 'disconnected':
                    this.emit('@connectionstatechange', 'disconnected');
                    break;
                case 'closed':
                    this.emit('@connectionstatechange', 'closed');
                    break;
            }
        });
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady)
            return;
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec }) {
        var _a;
        this._assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (codec) {
            logger.warn('send() | codec selection is not available in %s handler', this.name);
        }
        this._sendStream.addTrack(track);
        this._pc.addStream(this._sendStream);
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        sendingRtpParameters.codecs =
            ortc.reduceCodecs(sendingRtpParameters.codecs);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        sendingRemoteRtpParameters.codecs =
            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
        if (!this._transportReady) {
            await this._setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject
            });
        }
        if (track.kind === 'video' && encodings && encodings.length > 1) {
            logger.debug('send() | enabling simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media
                .find((m) => m.type === 'video');
            sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media
            .find((m) => m.type === track.kind);
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname =
            sdpCommonUtils.getCname({ offerMediaObject });
        // Set RTP encodings.
        sendingRtpParameters.encodings =
            sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx])
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
            }
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'S1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        // Insert into the map.
        this._mapSendLocalIdTrack.set(localId, track);
        return {
            localId: localId,
            rtpParameters: sendingRtpParameters
        };
    }
    async stopSending(localId) {
        this._assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        const track = this._mapSendLocalIdTrack.get(localId);
        if (!track)
            throw new Error('track not found');
        this._mapSendLocalIdTrack.delete(localId);
        this._sendStream.removeTrack(track);
        this._pc.addStream(this._sendStream);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        try {
            await this._pc.setLocalDescription(offer);
        }
        catch (error) {
            // NOTE: If there are no sending tracks, setLocalDescription() will fail with
            // "Failed to create channels". If so, ignore it.
            if (this._sendStream.getTracks().length === 0) {
                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());
                return;
            }
            throw error;
        }
        if (this._pc.signalingState === 'stable')
            return;
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId, track) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setMaxSpatialLayer(localId, spatialLayer) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setRtpEncodingParameters(localId, params) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getSenderStats(localId) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
        var _a;
        this._assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media
                .find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this._setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                    localSdpObject
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive({ trackId, kind, rtpParameters }) {
        var _a;
        this._assertRecvDirection();
        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
        const localId = trackId;
        const mid = kind;
        let streamId = rtpParameters.rtcp.cname;
        // NOTE: In React-Native we cannot reuse the same remote MediaStream for new
        // remote tracks. This is because react-native-webrtc does not react on new
        // tracks generated within already existing streams, so force the streamId
        // to be different.
        logger.debug('receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc');
        streamId += `-hack-${utils.generateRandomNumber()}`;
        this._remoteSdp.receive({
            mid,
            kind,
            offerRtpParameters: rtpParameters,
            streamId,
            trackId
        });
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        const answerMediaObject = localSdpObject.media
            .find((m) => String(m.mid) === mid);
        // May need to modify codec parameters in the answer based on codec
        // parameters in the offer.
        sdpCommonUtils.applyCodecParameters({
            offerRtpParameters: rtpParameters,
            answerMediaObject
        });
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this._setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        const stream = this._pc.getRemoteStreams()
            .find((s) => s.id === streamId);
        const track = stream.getTrackById(localId);
        if (!track)
            throw new Error('remote track not found');
        // Insert into the map.
        this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });
        return { localId, track };
    }
    async stopReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('stopReceiving() [localId:%s]', localId);
        const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};
        // Remove from the map.
        this._mapRecvLocalIdInfo.delete(localId);
        this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId) {
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getReceiverStats(localId) {
        throw new errors_1.UnsupportedError('not implemented');
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
        var _a;
        this._assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this._setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                    localSdpObject
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async _setupTransport({ localDtlsRole, localSdpObject }) {
        if (!localSdpObject)
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await this.safeEmitAsPromise('@connect', { dtlsParameters });
        this._transportReady = true;
    }
    _assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    _assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.ReactNative = ReactNative;

},{"../Logger":146,"../errors":151,"../ortc":169,"../utils":172,"./HandlerInterface":158,"./sdp/RemoteSdp":164,"./sdp/commonUtils":165,"./sdp/planBUtils":166,"sdp-transform":175}],160:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Safari11 = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpPlanBUtils = __importStar(require("./sdp/planBUtils"));
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const logger = new Logger_1.Logger('Safari11');
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Safari11 extends HandlerInterface_1.HandlerInterface {
    constructor() {
        super();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Map of RTCRtpSender indexed by localId.
        this._mapSendLocalIdRtpSender = new Map();
        // Next sending localId.
        this._nextSendLocalId = 0;
        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
        // Value is an Object with mid, rtpParameters and rtpReceiver.
        this._mapRecvLocalIdInfo = new Map();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Safari11();
    }
    get name() {
        return 'Safari11';
    }
    close() {
        logger.debug('close()');
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'plan-b'
        });
        try {
            const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
            });
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
        });
        this._sendingRtpParametersByKind =
            {
                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
            };
        this._sendingRemoteRtpParametersByKind =
            {
                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
            };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole = dtlsParameters.role === 'server'
                ? 'client'
                : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            ...additionalSettings
        }, proprietaryConstraints);
        // Handle RTCPeerConnection connection status.
        this._pc.addEventListener('iceconnectionstatechange', () => {
            switch (this._pc.iceConnectionState) {
                case 'checking':
                    this.emit('@connectionstatechange', 'connecting');
                    break;
                case 'connected':
                case 'completed':
                    this.emit('@connectionstatechange', 'connected');
                    break;
                case 'failed':
                    this.emit('@connectionstatechange', 'failed');
                    break;
                case 'disconnected':
                    this.emit('@connectionstatechange', 'disconnected');
                    break;
                case 'closed':
                    this.emit('@connectionstatechange', 'closed');
                    break;
            }
        });
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady)
            return;
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec }) {
        var _a;
        this._assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (codec) {
            logger.warn('send() | codec selection is not available in %s handler', this.name);
        }
        this._sendStream.addTrack(track);
        this._pc.addTrack(track, this._sendStream);
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        sendingRtpParameters.codecs =
            ortc.reduceCodecs(sendingRtpParameters.codecs);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        sendingRemoteRtpParameters.codecs =
            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
        if (!this._transportReady) {
            await this._setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject
            });
        }
        if (track.kind === 'video' && encodings && encodings.length > 1) {
            logger.debug('send() | enabling simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');
            sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media
            .find((m) => m.type === track.kind);
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname =
            sdpCommonUtils.getCname({ offerMediaObject });
        // Set RTP encodings.
        sendingRtpParameters.encodings =
            sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx])
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
            }
        }
        // If VP8 and there is effective simulcast, add scalabilityMode to each
        // encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'S1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        const rtpSender = this._pc.getSenders()
            .find((s) => s.track === track);
        // Insert into the map.
        this._mapSendLocalIdRtpSender.set(localId, rtpSender);
        return {
            localId: localId,
            rtpParameters: sendingRtpParameters,
            rtpSender
        };
    }
    async stopSending(localId) {
        this._assertSendDirection();
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender)
            throw new Error('associated RTCRtpSender not found');
        if (rtpSender.track)
            this._sendStream.removeTrack(rtpSender.track);
        this._mapSendLocalIdRtpSender.delete(localId);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        try {
            await this._pc.setLocalDescription(offer);
        }
        catch (error) {
            // NOTE: If there are no sending tracks, setLocalDescription() will fail with
            // "Failed to create channels". If so, ignore it.
            if (this._sendStream.getTracks().length === 0) {
                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());
                return;
            }
            throw error;
        }
        if (this._pc.signalingState === 'stable')
            return;
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this._assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender)
            throw new Error('associated RTCRtpSender not found');
        const oldTrack = rtpSender.track;
        await rtpSender.replaceTrack(track);
        // Remove the old track from the local stream.
        if (oldTrack)
            this._sendStream.removeTrack(oldTrack);
        // Add the new track to the local stream.
        if (track)
            this._sendStream.addTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this._assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender)
            throw new Error('associated RTCRtpSender not found');
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer)
                encoding.active = true;
            else
                encoding.active = false;
        });
        await rtpSender.setParameters(parameters);
    }
    async setRtpEncodingParameters(localId, params) {
        this._assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender)
            throw new Error('associated RTCRtpSender not found');
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await rtpSender.setParameters(parameters);
    }
    async getSenderStats(localId) {
        this._assertSendDirection();
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender)
            throw new Error('associated RTCRtpSender not found');
        return rtpSender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
        var _a;
        this._assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media
                .find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this._setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                    localSdpObject
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive({ trackId, kind, rtpParameters }) {
        var _a;
        this._assertRecvDirection();
        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
        const localId = trackId;
        const mid = kind;
        this._remoteSdp.receive({
            mid,
            kind,
            offerRtpParameters: rtpParameters,
            streamId: rtpParameters.rtcp.cname,
            trackId
        });
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        const answerMediaObject = localSdpObject.media
            .find((m) => String(m.mid) === mid);
        // May need to modify codec parameters in the answer based on codec
        // parameters in the offer.
        sdpCommonUtils.applyCodecParameters({
            offerRtpParameters: rtpParameters,
            answerMediaObject
        });
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this._setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        const rtpReceiver = this._pc.getReceivers()
            .find((r) => r.track && r.track.id === localId);
        if (!rtpReceiver)
            throw new Error('new RTCRtpReceiver not');
        // Insert into the map.
        this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters, rtpReceiver });
        return {
            localId,
            track: rtpReceiver.track,
            rtpReceiver
        };
    }
    async stopReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('stopReceiving() [localId:%s]', localId);
        const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};
        // Remove from the map.
        this._mapRecvLocalIdInfo.delete(localId);
        this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this._assertRecvDirection();
        const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};
        if (!rtpReceiver)
            throw new Error('associated RTCRtpReceiver not found');
        return rtpReceiver.getStats();
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId) {
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId) {
        // Unimplemented.
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
        var _a;
        this._assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this._setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                    localSdpObject
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async _setupTransport({ localDtlsRole, localSdpObject }) {
        if (!localSdpObject)
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await this.safeEmitAsPromise('@connect', { dtlsParameters });
        this._transportReady = true;
    }
    _assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    _assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Safari11 = Safari11;

},{"../Logger":146,"../ortc":169,"../utils":172,"./HandlerInterface":158,"./sdp/RemoteSdp":164,"./sdp/commonUtils":165,"./sdp/planBUtils":166,"sdp-transform":175}],161:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Safari12 = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../Logger");
const utils = __importStar(require("../utils"));
const ortc = __importStar(require("../ortc"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const sdpUnifiedPlanUtils = __importStar(require("./sdp/unifiedPlanUtils"));
const HandlerInterface_1 = require("./HandlerInterface");
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const logger = new Logger_1.Logger('Safari12');
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Safari12 extends HandlerInterface_1.HandlerInterface {
    constructor() {
        super();
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return () => new Safari12();
    }
    get name() {
        return 'Safari12';
    }
    close() {
        logger.debug('close()');
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
    }
    async getNativeRtpCapabilities() {
        logger.debug('getNativeRtpCapabilities()');
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require'
        });
        try {
            pc.addTransceiver('audio');
            pc.addTransceiver('video');
            const offer = await pc.createOffer();
            try {
                pc.close();
            }
            catch (error) { }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });
            return nativeRtpCapabilities;
        }
        catch (error) {
            try {
                pc.close();
            }
            catch (error2) { }
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
        });
        this._sendingRtpParametersByKind =
            {
                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
            };
        this._sendingRemoteRtpParametersByKind =
            {
                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
            };
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole = dtlsParameters.role === 'server'
                ? 'client'
                : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            ...additionalSettings
        }, proprietaryConstraints);
        // Handle RTCPeerConnection connection status.
        this._pc.addEventListener('iceconnectionstatechange', () => {
            switch (this._pc.iceConnectionState) {
                case 'checking':
                    this.emit('@connectionstatechange', 'connecting');
                    break;
                case 'connected':
                case 'completed':
                    this.emit('@connectionstatechange', 'connected');
                    break;
                case 'failed':
                    this.emit('@connectionstatechange', 'failed');
                    break;
                case 'disconnected':
                    this.emit('@connectionstatechange', 'disconnected');
                    break;
                case 'closed':
                    this.emit('@connectionstatechange', 'closed');
                    break;
            }
        });
    }
    async updateIceServers(iceServers) {
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady)
            return;
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec }) {
        var _a;
        this._assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRtpParameters.codecs =
            ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRemoteRtpParameters.codecs =
            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, { direction: 'sendonly', streams: [this._sendStream] });
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        if (!this._transportReady) {
            await this._setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject
            });
        }
        if (encodings && encodings.length > 1) {
            logger.debug('send() | enabling legacy simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: encodings.length
            });
            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname =
            sdpCommonUtils.getCname({ offerMediaObject });
        // Set RTP encodings.
        sendingRtpParameters.encodings =
            sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx])
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
            }
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                encoding.scalabilityMode = 'S1T3';
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
        });
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
        };
    }
    async stopSending(localId) {
        this._assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        this._remoteSdp.closeMediaSection(transceiver.mid);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async replaceTrack(localId, track) {
        this._assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this._assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer)
                encoding.active = true;
            else
                encoding.active = false;
        });
        await transceiver.sender.setParameters(parameters);
    }
    async setRtpEncodingParameters(localId, params) {
        this._assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
    }
    async getSenderStats(localId) {
        this._assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
        var _a;
        this._assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media
                .find((m) => m.type === 'application');
            if (!this._transportReady) {
                await this._setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                    localSdpObject
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive({ trackId, kind, rtpParameters }) {
        var _a;
        this._assertRecvDirection();
        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
        const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
        this._remoteSdp.receive({
            mid: localId,
            kind,
            offerRtpParameters: rtpParameters,
            streamId: rtpParameters.rtcp.cname,
            trackId
        });
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        const answerMediaObject = localSdpObject.media
            .find((m) => String(m.mid) === localId);
        // May need to modify codec parameters in the answer based on codec
        // parameters in the offer.
        sdpCommonUtils.applyCodecParameters({
            offerRtpParameters: rtpParameters,
            answerMediaObject
        });
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady) {
            await this._setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                localSdpObject
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        const transceiver = this._pc.getTransceivers()
            .find((t) => t.mid === localId);
        if (!transceiver)
            throw new Error('new RTCRtpTransceiver not found');
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            track: transceiver.receiver.track,
            rtpReceiver: transceiver.receiver
        };
    }
    async stopReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('stopReceiving() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        this._remoteSdp.closeMediaSection(transceiver.mid);
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('pauseReceiving() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        transceiver.direction = 'inactive';
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('resumeReceiving() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        transceiver.direction = 'recvonly';
        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this._assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
        var _a;
        this._assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this._setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : 'client',
                    localSdpObject
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async _setupTransport({ localDtlsRole, localSdpObject }) {
        if (!localSdpObject)
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await this.safeEmitAsPromise('@connect', { dtlsParameters });
        this._transportReady = true;
    }
    _assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    _assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Safari12 = Safari12;

},{"../Logger":146,"../ortc":169,"../utils":172,"./HandlerInterface":158,"./sdp/RemoteSdp":164,"./sdp/commonUtils":165,"./sdp/unifiedPlanUtils":167,"sdp-transform":175}],162:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mangleRtpParameters = exports.getCapabilities = void 0;
const utils = __importStar(require("../../utils"));
/**
 * Normalize ORTC based Edge's RTCRtpReceiver.getCapabilities() to produce a full
 * compliant ORTC RTCRtpCapabilities.
 */
function getCapabilities() {
    const nativeCaps = RTCRtpReceiver.getCapabilities();
    const caps = utils.clone(nativeCaps, {});
    for (const codec of caps.codecs) {
        // Rename numChannels to channels.
        codec.channels = codec.numChannels;
        delete codec.numChannels;
        // Add mimeType.
        codec.mimeType = codec.mimeType || `${codec.kind}/${codec.name}`;
        // NOTE: Edge sets some numeric parameters as string rather than number. Fix them.
        if (codec.parameters) {
            const parameters = codec.parameters;
            if (parameters.apt)
                parameters.apt = Number(parameters.apt);
            if (parameters['packetization-mode'])
                parameters['packetization-mode'] = Number(parameters['packetization-mode']);
        }
        // Delete emty parameter String in rtcpFeedback.
        for (const feedback of codec.rtcpFeedback || []) {
            if (!feedback.parameter)
                feedback.parameter = '';
        }
    }
    return caps;
}
exports.getCapabilities = getCapabilities;
/**
 * Generate RTCRtpParameters as ORTC based Edge likes.
 */
function mangleRtpParameters(rtpParameters) {
    const params = utils.clone(rtpParameters, {});
    // Rename mid to muxId.
    if (params.mid) {
        params.muxId = params.mid;
        delete params.mid;
    }
    for (const codec of params.codecs) {
        // Rename channels to numChannels.
        if (codec.channels) {
            codec.numChannels = codec.channels;
            delete codec.channels;
        }
        // Add codec.name (requried by Edge).
        if (codec.mimeType && !codec.name)
            codec.name = codec.mimeType.split('/')[1];
        // Remove mimeType.
        delete codec.mimeType;
    }
    return params;
}
exports.mangleRtpParameters = mangleRtpParameters;

},{"../../utils":172}],163:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OfferMediaSection = exports.AnswerMediaSection = exports.MediaSection = void 0;
const utils = __importStar(require("../../utils"));
class MediaSection {
    constructor({ iceParameters, iceCandidates, dtlsParameters, planB = false }) {
        this._mediaObject = {};
        this._planB = planB;
        if (iceParameters) {
            this.setIceParameters(iceParameters);
        }
        if (iceCandidates) {
            this._mediaObject.candidates = [];
            for (const candidate of iceCandidates) {
                const candidateObject = {};
                // mediasoup does mandates rtcp-mux so candidates component is always
                // RTP (1).
                candidateObject.component = 1;
                candidateObject.foundation = candidate.foundation;
                candidateObject.ip = candidate.ip;
                candidateObject.port = candidate.port;
                candidateObject.priority = candidate.priority;
                candidateObject.transport = candidate.protocol;
                candidateObject.type = candidate.type;
                if (candidate.tcpType)
                    candidateObject.tcptype = candidate.tcpType;
                this._mediaObject.candidates.push(candidateObject);
            }
            this._mediaObject.endOfCandidates = 'end-of-candidates';
            this._mediaObject.iceOptions = 'renomination';
        }
        if (dtlsParameters) {
            this.setDtlsRole(dtlsParameters.role);
        }
    }
    get mid() {
        return String(this._mediaObject.mid);
    }
    get closed() {
        return this._mediaObject.port === 0;
    }
    getObject() {
        return this._mediaObject;
    }
    setIceParameters(iceParameters) {
        this._mediaObject.iceUfrag = iceParameters.usernameFragment;
        this._mediaObject.icePwd = iceParameters.password;
    }
    disable() {
        this._mediaObject.direction = 'inactive';
        delete this._mediaObject.ext;
        delete this._mediaObject.ssrcs;
        delete this._mediaObject.ssrcGroups;
        delete this._mediaObject.simulcast;
        delete this._mediaObject.simulcast_03;
        delete this._mediaObject.rids;
    }
    close() {
        this._mediaObject.direction = 'inactive';
        this._mediaObject.port = 0;
        delete this._mediaObject.ext;
        delete this._mediaObject.ssrcs;
        delete this._mediaObject.ssrcGroups;
        delete this._mediaObject.simulcast;
        delete this._mediaObject.simulcast_03;
        delete this._mediaObject.rids;
        delete this._mediaObject.extmapAllowMixed;
    }
}
exports.MediaSection = MediaSection;
class AnswerMediaSection extends MediaSection {
    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, offerMediaObject, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false }) {
        super({ iceParameters, iceCandidates, dtlsParameters, planB });
        this._mediaObject.mid = String(offerMediaObject.mid);
        this._mediaObject.type = offerMediaObject.type;
        this._mediaObject.protocol = offerMediaObject.protocol;
        if (!plainRtpParameters) {
            this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };
            this._mediaObject.port = 7;
        }
        else {
            this._mediaObject.connection =
                {
                    ip: plainRtpParameters.ip,
                    version: plainRtpParameters.ipVersion
                };
            this._mediaObject.port = plainRtpParameters.port;
        }
        switch (offerMediaObject.type) {
            case 'audio':
            case 'video':
                {
                    this._mediaObject.direction = 'recvonly';
                    this._mediaObject.rtp = [];
                    this._mediaObject.rtcpFb = [];
                    this._mediaObject.fmtp = [];
                    for (const codec of answerRtpParameters.codecs) {
                        const rtp = {
                            payload: codec.payloadType,
                            codec: getCodecName(codec),
                            rate: codec.clockRate
                        };
                        if (codec.channels > 1)
                            rtp.encoding = codec.channels;
                        this._mediaObject.rtp.push(rtp);
                        const codecParameters = utils.clone(codec.parameters, {});
                        if (codecOptions) {
                            const { opusStereo, opusFec, opusDtx, opusMaxPlaybackRate, opusMaxAverageBitrate, opusPtime, videoGoogleStartBitrate, videoGoogleMaxBitrate, videoGoogleMinBitrate } = codecOptions;
                            const offerCodec = offerRtpParameters.codecs
                                .find((c) => (c.payloadType === codec.payloadType));
                            switch (codec.mimeType.toLowerCase()) {
                                case 'audio/opus':
                                    {
                                        if (opusStereo !== undefined) {
                                            offerCodec.parameters['sprop-stereo'] = opusStereo ? 1 : 0;
                                            codecParameters.stereo = opusStereo ? 1 : 0;
                                        }
                                        if (opusFec !== undefined) {
                                            offerCodec.parameters.useinbandfec = opusFec ? 1 : 0;
                                            codecParameters.useinbandfec = opusFec ? 1 : 0;
                                        }
                                        if (opusDtx !== undefined) {
                                            offerCodec.parameters.usedtx = opusDtx ? 1 : 0;
                                            codecParameters.usedtx = opusDtx ? 1 : 0;
                                        }
                                        if (opusMaxPlaybackRate !== undefined) {
                                            codecParameters.maxplaybackrate = opusMaxPlaybackRate;
                                        }
                                        if (opusMaxAverageBitrate !== undefined) {
                                            codecParameters.maxaveragebitrate = opusMaxAverageBitrate;
                                        }
                                        if (opusPtime !== undefined) {
                                            offerCodec.parameters.ptime = opusPtime;
                                            codecParameters.ptime = opusPtime;
                                        }
                                        break;
                                    }
                                case 'video/vp8':
                                case 'video/vp9':
                                case 'video/h264':
                                case 'video/h265':
                                    {
                                        if (videoGoogleStartBitrate !== undefined)
                                            codecParameters['x-google-start-bitrate'] = videoGoogleStartBitrate;
                                        if (videoGoogleMaxBitrate !== undefined)
                                            codecParameters['x-google-max-bitrate'] = videoGoogleMaxBitrate;
                                        if (videoGoogleMinBitrate !== undefined)
                                            codecParameters['x-google-min-bitrate'] = videoGoogleMinBitrate;
                                        break;
                                    }
                            }
                        }
                        const fmtp = {
                            payload: codec.payloadType,
                            config: ''
                        };
                        for (const key of Object.keys(codecParameters)) {
                            if (fmtp.config)
                                fmtp.config += ';';
                            fmtp.config += `${key}=${codecParameters[key]}`;
                        }
                        if (fmtp.config)
                            this._mediaObject.fmtp.push(fmtp);
                        for (const fb of codec.rtcpFeedback) {
                            this._mediaObject.rtcpFb.push({
                                payload: codec.payloadType,
                                type: fb.type,
                                subtype: fb.parameter
                            });
                        }
                    }
                    this._mediaObject.payloads = answerRtpParameters.codecs
                        .map((codec) => codec.payloadType)
                        .join(' ');
                    this._mediaObject.ext = [];
                    for (const ext of answerRtpParameters.headerExtensions) {
                        // Don't add a header extension if not present in the offer.
                        const found = (offerMediaObject.ext || [])
                            .some((localExt) => localExt.uri === ext.uri);
                        if (!found)
                            continue;
                        this._mediaObject.ext.push({
                            uri: ext.uri,
                            value: ext.id
                        });
                    }
                    // Allow both 1 byte and 2 bytes length header extensions.
                    if (extmapAllowMixed &&
                        offerMediaObject.extmapAllowMixed === 'extmap-allow-mixed') {
                        this._mediaObject.extmapAllowMixed = 'extmap-allow-mixed';
                    }
                    // Simulcast.
                    if (offerMediaObject.simulcast) {
                        this._mediaObject.simulcast =
                            {
                                dir1: 'recv',
                                list1: offerMediaObject.simulcast.list1
                            };
                        this._mediaObject.rids = [];
                        for (const rid of offerMediaObject.rids || []) {
                            if (rid.direction !== 'send')
                                continue;
                            this._mediaObject.rids.push({
                                id: rid.id,
                                direction: 'recv'
                            });
                        }
                    }
                    // Simulcast (draft version 03).
                    else if (offerMediaObject.simulcast_03) {
                        // eslint-disable-next-line camelcase
                        this._mediaObject.simulcast_03 =
                            {
                                value: offerMediaObject.simulcast_03.value.replace(/send/g, 'recv')
                            };
                        this._mediaObject.rids = [];
                        for (const rid of offerMediaObject.rids || []) {
                            if (rid.direction !== 'send')
                                continue;
                            this._mediaObject.rids.push({
                                id: rid.id,
                                direction: 'recv'
                            });
                        }
                    }
                    this._mediaObject.rtcpMux = 'rtcp-mux';
                    this._mediaObject.rtcpRsize = 'rtcp-rsize';
                    if (this._planB && this._mediaObject.type === 'video')
                        this._mediaObject.xGoogleFlag = 'conference';
                    break;
                }
            case 'application':
                {
                    // New spec.
                    if (typeof offerMediaObject.sctpPort === 'number') {
                        this._mediaObject.payloads = 'webrtc-datachannel';
                        this._mediaObject.sctpPort = sctpParameters.port;
                        this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
                    }
                    // Old spec.
                    else if (offerMediaObject.sctpmap) {
                        this._mediaObject.payloads = sctpParameters.port;
                        this._mediaObject.sctpmap =
                            {
                                app: 'webrtc-datachannel',
                                sctpmapNumber: sctpParameters.port,
                                maxMessageSize: sctpParameters.maxMessageSize
                            };
                    }
                    break;
                }
        }
    }
    setDtlsRole(role) {
        switch (role) {
            case 'client':
                this._mediaObject.setup = 'active';
                break;
            case 'server':
                this._mediaObject.setup = 'passive';
                break;
            case 'auto':
                this._mediaObject.setup = 'actpass';
                break;
        }
    }
}
exports.AnswerMediaSection = AnswerMediaSection;
class OfferMediaSection extends MediaSection {
    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, mid, kind, offerRtpParameters, streamId, trackId, oldDataChannelSpec = false }) {
        super({ iceParameters, iceCandidates, dtlsParameters, planB });
        this._mediaObject.mid = String(mid);
        this._mediaObject.type = kind;
        if (!plainRtpParameters) {
            this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };
            if (!sctpParameters)
                this._mediaObject.protocol = 'UDP/TLS/RTP/SAVPF';
            else
                this._mediaObject.protocol = 'UDP/DTLS/SCTP';
            this._mediaObject.port = 7;
        }
        else {
            this._mediaObject.connection =
                {
                    ip: plainRtpParameters.ip,
                    version: plainRtpParameters.ipVersion
                };
            this._mediaObject.protocol = 'RTP/AVP';
            this._mediaObject.port = plainRtpParameters.port;
        }
        switch (kind) {
            case 'audio':
            case 'video':
                {
                    this._mediaObject.direction = 'sendonly';
                    this._mediaObject.rtp = [];
                    this._mediaObject.rtcpFb = [];
                    this._mediaObject.fmtp = [];
                    if (!this._planB)
                        this._mediaObject.msid = `${streamId || '-'} ${trackId}`;
                    for (const codec of offerRtpParameters.codecs) {
                        const rtp = {
                            payload: codec.payloadType,
                            codec: getCodecName(codec),
                            rate: codec.clockRate
                        };
                        if (codec.channels > 1)
                            rtp.encoding = codec.channels;
                        this._mediaObject.rtp.push(rtp);
                        const fmtp = {
                            payload: codec.payloadType,
                            config: ''
                        };
                        for (const key of Object.keys(codec.parameters)) {
                            if (fmtp.config)
                                fmtp.config += ';';
                            fmtp.config += `${key}=${codec.parameters[key]}`;
                        }
                        if (fmtp.config)
                            this._mediaObject.fmtp.push(fmtp);
                        for (const fb of codec.rtcpFeedback) {
                            this._mediaObject.rtcpFb.push({
                                payload: codec.payloadType,
                                type: fb.type,
                                subtype: fb.parameter
                            });
                        }
                    }
                    this._mediaObject.payloads = offerRtpParameters.codecs
                        .map((codec) => codec.payloadType)
                        .join(' ');
                    this._mediaObject.ext = [];
                    for (const ext of offerRtpParameters.headerExtensions) {
                        this._mediaObject.ext.push({
                            uri: ext.uri,
                            value: ext.id
                        });
                    }
                    this._mediaObject.rtcpMux = 'rtcp-mux';
                    this._mediaObject.rtcpRsize = 'rtcp-rsize';
                    const encoding = offerRtpParameters.encodings[0];
                    const ssrc = encoding.ssrc;
                    const rtxSsrc = (encoding.rtx && encoding.rtx.ssrc)
                        ? encoding.rtx.ssrc
                        : undefined;
                    this._mediaObject.ssrcs = [];
                    this._mediaObject.ssrcGroups = [];
                    if (offerRtpParameters.rtcp.cname) {
                        this._mediaObject.ssrcs.push({
                            id: ssrc,
                            attribute: 'cname',
                            value: offerRtpParameters.rtcp.cname
                        });
                    }
                    if (this._planB) {
                        this._mediaObject.ssrcs.push({
                            id: ssrc,
                            attribute: 'msid',
                            value: `${streamId || '-'} ${trackId}`
                        });
                    }
                    if (rtxSsrc) {
                        if (offerRtpParameters.rtcp.cname) {
                            this._mediaObject.ssrcs.push({
                                id: rtxSsrc,
                                attribute: 'cname',
                                value: offerRtpParameters.rtcp.cname
                            });
                        }
                        if (this._planB) {
                            this._mediaObject.ssrcs.push({
                                id: rtxSsrc,
                                attribute: 'msid',
                                value: `${streamId || '-'} ${trackId}`
                            });
                        }
                        // Associate original and retransmission SSRCs.
                        this._mediaObject.ssrcGroups.push({
                            semantics: 'FID',
                            ssrcs: `${ssrc} ${rtxSsrc}`
                        });
                    }
                    break;
                }
            case 'application':
                {
                    // New spec.
                    if (!oldDataChannelSpec) {
                        this._mediaObject.payloads = 'webrtc-datachannel';
                        this._mediaObject.sctpPort = sctpParameters.port;
                        this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
                    }
                    // Old spec.
                    else {
                        this._mediaObject.payloads = sctpParameters.port;
                        this._mediaObject.sctpmap =
                            {
                                app: 'webrtc-datachannel',
                                sctpmapNumber: sctpParameters.port,
                                maxMessageSize: sctpParameters.maxMessageSize
                            };
                    }
                    break;
                }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setDtlsRole(role) {
        // Always 'actpass'.
        this._mediaObject.setup = 'actpass';
    }
    planBReceive({ offerRtpParameters, streamId, trackId }) {
        const encoding = offerRtpParameters.encodings[0];
        const ssrc = encoding.ssrc;
        const rtxSsrc = (encoding.rtx && encoding.rtx.ssrc)
            ? encoding.rtx.ssrc
            : undefined;
        const payloads = this._mediaObject.payloads.split(' ');
        for (const codec of offerRtpParameters.codecs) {
            if (payloads.includes(String(codec.payloadType))) {
                continue;
            }
            const rtp = {
                payload: codec.payloadType,
                codec: getCodecName(codec),
                rate: codec.clockRate
            };
            if (codec.channels > 1)
                rtp.encoding = codec.channels;
            this._mediaObject.rtp.push(rtp);
            const fmtp = {
                payload: codec.payloadType,
                config: ''
            };
            for (const key of Object.keys(codec.parameters)) {
                if (fmtp.config)
                    fmtp.config += ';';
                fmtp.config += `${key}=${codec.parameters[key]}`;
            }
            if (fmtp.config)
                this._mediaObject.fmtp.push(fmtp);
            for (const fb of codec.rtcpFeedback) {
                this._mediaObject.rtcpFb.push({
                    payload: codec.payloadType,
                    type: fb.type,
                    subtype: fb.parameter
                });
            }
        }
        this._mediaObject.payloads += ` ${offerRtpParameters
            .codecs
            .filter((codec) => !this._mediaObject.payloads.includes(codec.payloadType))
            .map((codec) => codec.payloadType)
            .join(' ')}`;
        this._mediaObject.payloads = this._mediaObject.payloads.trim();
        if (offerRtpParameters.rtcp.cname) {
            this._mediaObject.ssrcs.push({
                id: ssrc,
                attribute: 'cname',
                value: offerRtpParameters.rtcp.cname
            });
        }
        this._mediaObject.ssrcs.push({
            id: ssrc,
            attribute: 'msid',
            value: `${streamId || '-'} ${trackId}`
        });
        if (rtxSsrc) {
            if (offerRtpParameters.rtcp.cname) {
                this._mediaObject.ssrcs.push({
                    id: rtxSsrc,
                    attribute: 'cname',
                    value: offerRtpParameters.rtcp.cname
                });
            }
            this._mediaObject.ssrcs.push({
                id: rtxSsrc,
                attribute: 'msid',
                value: `${streamId || '-'} ${trackId}`
            });
            // Associate original and retransmission SSRCs.
            this._mediaObject.ssrcGroups.push({
                semantics: 'FID',
                ssrcs: `${ssrc} ${rtxSsrc}`
            });
        }
    }
    planBStopReceiving({ offerRtpParameters }) {
        const encoding = offerRtpParameters.encodings[0];
        const ssrc = encoding.ssrc;
        const rtxSsrc = (encoding.rtx && encoding.rtx.ssrc)
            ? encoding.rtx.ssrc
            : undefined;
        this._mediaObject.ssrcs = this._mediaObject.ssrcs
            .filter((s) => s.id !== ssrc && s.id !== rtxSsrc);
        if (rtxSsrc) {
            this._mediaObject.ssrcGroups = this._mediaObject.ssrcGroups
                .filter((group) => group.ssrcs !== `${ssrc} ${rtxSsrc}`);
        }
    }
}
exports.OfferMediaSection = OfferMediaSection;
function getCodecName(codec) {
    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch)
        throw new TypeError('invalid codec.mimeType');
    return mimeTypeMatch[2];
}

},{"../../utils":172}],164:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteSdp = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
const Logger_1 = require("../../Logger");
const MediaSection_1 = require("./MediaSection");
const logger = new Logger_1.Logger('RemoteSdp');
class RemoteSdp {
    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false }) {
        // MediaSection instances with same order as in the SDP.
        this._mediaSections = [];
        // MediaSection indices indexed by MID.
        this._midToIndex = new Map();
        this._iceParameters = iceParameters;
        this._iceCandidates = iceCandidates;
        this._dtlsParameters = dtlsParameters;
        this._sctpParameters = sctpParameters;
        this._plainRtpParameters = plainRtpParameters;
        this._planB = planB;
        this._sdpObject =
            {
                version: 0,
                origin: {
                    address: '0.0.0.0',
                    ipVer: 4,
                    netType: 'IN',
                    sessionId: 10000,
                    sessionVersion: 0,
                    username: 'mediasoup-client'
                },
                name: '-',
                timing: { start: 0, stop: 0 },
                media: []
            };
        // If ICE parameters are given, add ICE-Lite indicator.
        if (iceParameters && iceParameters.iceLite) {
            this._sdpObject.icelite = 'ice-lite';
        }
        // If DTLS parameters are given, assume WebRTC and BUNDLE.
        if (dtlsParameters) {
            this._sdpObject.msidSemantic = { semantic: 'WMS', token: '*' };
            // NOTE: We take the latest fingerprint.
            const numFingerprints = this._dtlsParameters.fingerprints.length;
            this._sdpObject.fingerprint =
                {
                    type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,
                    hash: dtlsParameters.fingerprints[numFingerprints - 1].value
                };
            this._sdpObject.groups = [{ type: 'BUNDLE', mids: '' }];
        }
        // If there are plain RPT parameters, override SDP origin.
        if (plainRtpParameters) {
            this._sdpObject.origin.address = plainRtpParameters.ip;
            this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;
        }
    }
    updateIceParameters(iceParameters) {
        logger.debug('updateIceParameters() [iceParameters:%o]', iceParameters);
        this._iceParameters = iceParameters;
        this._sdpObject.icelite = iceParameters.iceLite ? 'ice-lite' : undefined;
        for (const mediaSection of this._mediaSections) {
            mediaSection.setIceParameters(iceParameters);
        }
    }
    updateDtlsRole(role) {
        logger.debug('updateDtlsRole() [role:%s]', role);
        this._dtlsParameters.role = role;
        for (const mediaSection of this._mediaSections) {
            mediaSection.setDtlsRole(role);
        }
    }
    getNextMediaSectionIdx() {
        // If a closed media section is found, return its index.
        for (let idx = 0; idx < this._mediaSections.length; ++idx) {
            const mediaSection = this._mediaSections[idx];
            if (mediaSection.closed)
                return { idx, reuseMid: mediaSection.mid };
        }
        // If no closed media section is found, return next one.
        return { idx: this._mediaSections.length };
    }
    send({ offerMediaObject, reuseMid, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false }) {
        const mediaSection = new MediaSection_1.AnswerMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            plainRtpParameters: this._plainRtpParameters,
            planB: this._planB,
            offerMediaObject,
            offerRtpParameters,
            answerRtpParameters,
            codecOptions,
            extmapAllowMixed
        });
        // Unified-Plan with closed media section replacement.
        if (reuseMid) {
            this._replaceMediaSection(mediaSection, reuseMid);
        }
        // Unified-Plan or Plan-B with different media kind.
        else if (!this._midToIndex.has(mediaSection.mid)) {
            this._addMediaSection(mediaSection);
        }
        // Plan-B with same media kind.
        else {
            this._replaceMediaSection(mediaSection);
        }
    }
    receive({ mid, kind, offerRtpParameters, streamId, trackId }) {
        const idx = this._midToIndex.get(mid);
        let mediaSection;
        if (idx !== undefined)
            mediaSection = this._mediaSections[idx];
        // Unified-Plan or different media kind.
        if (!mediaSection) {
            mediaSection = new MediaSection_1.OfferMediaSection({
                iceParameters: this._iceParameters,
                iceCandidates: this._iceCandidates,
                dtlsParameters: this._dtlsParameters,
                plainRtpParameters: this._plainRtpParameters,
                planB: this._planB,
                mid,
                kind,
                offerRtpParameters,
                streamId,
                trackId
            });
            // Let's try to recycle a closed media section (if any).
            // NOTE: Yes, we can recycle a closed m=audio section with a new m=video.
            const oldMediaSection = this._mediaSections.find((m) => (m.closed));
            if (oldMediaSection) {
                this._replaceMediaSection(mediaSection, oldMediaSection.mid);
            }
            else {
                this._addMediaSection(mediaSection);
            }
        }
        // Plan-B.
        else {
            mediaSection.planBReceive({ offerRtpParameters, streamId, trackId });
            this._replaceMediaSection(mediaSection);
        }
    }
    disableMediaSection(mid) {
        const idx = this._midToIndex.get(mid);
        if (idx === undefined) {
            throw new Error(`no media section found with mid '${mid}'`);
        }
        const mediaSection = this._mediaSections[idx];
        mediaSection.disable();
    }
    closeMediaSection(mid) {
        const idx = this._midToIndex.get(mid);
        if (idx === undefined) {
            throw new Error(`no media section found with mid '${mid}'`);
        }
        const mediaSection = this._mediaSections[idx];
        // NOTE: Closing the first m section is a pain since it invalidates the
        // bundled transport, so let's avoid it.
        if (mid === this._firstMid) {
            logger.debug('closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]', mid);
            this.disableMediaSection(mid);
            return;
        }
        mediaSection.close();
        // Regenerate BUNDLE mids.
        this._regenerateBundleMids();
    }
    planBStopReceiving({ mid, offerRtpParameters }) {
        const idx = this._midToIndex.get(mid);
        if (idx === undefined) {
            throw new Error(`no media section found with mid '${mid}'`);
        }
        const mediaSection = this._mediaSections[idx];
        mediaSection.planBStopReceiving({ offerRtpParameters });
        this._replaceMediaSection(mediaSection);
    }
    sendSctpAssociation({ offerMediaObject }) {
        const mediaSection = new MediaSection_1.AnswerMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            sctpParameters: this._sctpParameters,
            plainRtpParameters: this._plainRtpParameters,
            offerMediaObject
        });
        this._addMediaSection(mediaSection);
    }
    receiveSctpAssociation({ oldDataChannelSpec = false } = {}) {
        const mediaSection = new MediaSection_1.OfferMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            sctpParameters: this._sctpParameters,
            plainRtpParameters: this._plainRtpParameters,
            mid: 'datachannel',
            kind: 'application',
            oldDataChannelSpec
        });
        this._addMediaSection(mediaSection);
    }
    getSdp() {
        // Increase SDP version.
        this._sdpObject.origin.sessionVersion++;
        return sdpTransform.write(this._sdpObject);
    }
    _addMediaSection(newMediaSection) {
        if (!this._firstMid)
            this._firstMid = newMediaSection.mid;
        // Add to the vector.
        this._mediaSections.push(newMediaSection);
        // Add to the map.
        this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);
        // Add to the SDP object.
        this._sdpObject.media.push(newMediaSection.getObject());
        // Regenerate BUNDLE mids.
        this._regenerateBundleMids();
    }
    _replaceMediaSection(newMediaSection, reuseMid) {
        // Store it in the map.
        if (typeof reuseMid === 'string') {
            const idx = this._midToIndex.get(reuseMid);
            if (idx === undefined) {
                throw new Error(`no media section found for reuseMid '${reuseMid}'`);
            }
            const oldMediaSection = this._mediaSections[idx];
            // Replace the index in the vector with the new media section.
            this._mediaSections[idx] = newMediaSection;
            // Update the map.
            this._midToIndex.delete(oldMediaSection.mid);
            this._midToIndex.set(newMediaSection.mid, idx);
            // Update the SDP object.
            this._sdpObject.media[idx] = newMediaSection.getObject();
            // Regenerate BUNDLE mids.
            this._regenerateBundleMids();
        }
        else {
            const idx = this._midToIndex.get(newMediaSection.mid);
            if (idx === undefined) {
                throw new Error(`no media section found with mid '${newMediaSection.mid}'`);
            }
            // Replace the index in the vector with the new media section.
            this._mediaSections[idx] = newMediaSection;
            // Update the SDP object.
            this._sdpObject.media[idx] = newMediaSection.getObject();
        }
    }
    _regenerateBundleMids() {
        if (!this._dtlsParameters)
            return;
        this._sdpObject.groups[0].mids = this._mediaSections
            .filter((mediaSection) => !mediaSection.closed)
            .map((mediaSection) => mediaSection.mid)
            .join(' ');
    }
}
exports.RemoteSdp = RemoteSdp;

},{"../../Logger":146,"./MediaSection":163,"sdp-transform":175}],165:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyCodecParameters = exports.getCname = exports.extractDtlsParameters = exports.extractRtpCapabilities = void 0;
const sdpTransform = __importStar(require("sdp-transform"));
function extractRtpCapabilities({ sdpObject }) {
    // Map of RtpCodecParameters indexed by payload type.
    const codecsMap = new Map();
    // Array of RtpHeaderExtensions.
    const headerExtensions = [];
    // Whether a m=audio/video section has been already found.
    let gotAudio = false;
    let gotVideo = false;
    for (const m of sdpObject.media) {
        const kind = m.type;
        switch (kind) {
            case 'audio':
                {
                    if (gotAudio)
                        continue;
                    gotAudio = true;
                    break;
                }
            case 'video':
                {
                    if (gotVideo)
                        continue;
                    gotVideo = true;
                    break;
                }
            default:
                {
                    continue;
                }
        }
        // Get codecs.
        for (const rtp of m.rtp) {
            const codec = {
                kind: kind,
                mimeType: `${kind}/${rtp.codec}`,
                preferredPayloadType: rtp.payload,
                clockRate: rtp.rate,
                channels: rtp.encoding,
                parameters: {},
                rtcpFeedback: []
            };
            codecsMap.set(codec.preferredPayloadType, codec);
        }
        // Get codec parameters.
        for (const fmtp of m.fmtp || []) {
            const parameters = sdpTransform.parseParams(fmtp.config);
            const codec = codecsMap.get(fmtp.payload);
            if (!codec)
                continue;
            // Specials case to convert parameter value to string.
            if (parameters && parameters.hasOwnProperty('profile-level-id'))
                parameters['profile-level-id'] = String(parameters['profile-level-id']);
            codec.parameters = parameters;
        }
        // Get RTCP feedback for each codec.
        for (const fb of m.rtcpFb || []) {
            const codec = codecsMap.get(fb.payload);
            if (!codec)
                continue;
            const feedback = {
                type: fb.type,
                parameter: fb.subtype
            };
            if (!feedback.parameter)
                delete feedback.parameter;
            codec.rtcpFeedback.push(feedback);
        }
        // Get RTP header extensions.
        for (const ext of m.ext || []) {
            // Ignore encrypted extensions (not yet supported in mediasoup).
            if (ext['encrypt-uri'])
                continue;
            const headerExtension = {
                kind: kind,
                uri: ext.uri,
                preferredId: ext.value
            };
            headerExtensions.push(headerExtension);
        }
    }
    const rtpCapabilities = {
        codecs: Array.from(codecsMap.values()),
        headerExtensions: headerExtensions
    };
    return rtpCapabilities;
}
exports.extractRtpCapabilities = extractRtpCapabilities;
function extractDtlsParameters({ sdpObject }) {
    const mediaObject = (sdpObject.media || [])
        .find((m) => (m.iceUfrag && m.port !== 0));
    if (!mediaObject)
        throw new Error('no active media section found');
    const fingerprint = mediaObject.fingerprint || sdpObject.fingerprint;
    let role;
    switch (mediaObject.setup) {
        case 'active':
            role = 'client';
            break;
        case 'passive':
            role = 'server';
            break;
        case 'actpass':
            role = 'auto';
            break;
    }
    const dtlsParameters = {
        role,
        fingerprints: [
            {
                algorithm: fingerprint.type,
                value: fingerprint.hash
            }
        ]
    };
    return dtlsParameters;
}
exports.extractDtlsParameters = extractDtlsParameters;
function getCname({ offerMediaObject }) {
    const ssrcCnameLine = (offerMediaObject.ssrcs || [])
        .find((line) => line.attribute === 'cname');
    if (!ssrcCnameLine)
        return '';
    return ssrcCnameLine.value;
}
exports.getCname = getCname;
/**
 * Apply codec parameters in the given SDP m= section answer based on the
 * given RTP parameters of an offer.
 */
function applyCodecParameters({ offerRtpParameters, answerMediaObject }) {
    for (const codec of offerRtpParameters.codecs) {
        const mimeType = codec.mimeType.toLowerCase();
        // Avoid parsing codec parameters for unhandled codecs.
        if (mimeType !== 'audio/opus')
            continue;
        const rtp = (answerMediaObject.rtp || [])
            .find((r) => r.payload === codec.payloadType);
        if (!rtp)
            continue;
        // Just in case.
        answerMediaObject.fmtp = answerMediaObject.fmtp || [];
        let fmtp = answerMediaObject.fmtp
            .find((f) => f.payload === codec.payloadType);
        if (!fmtp) {
            fmtp = { payload: codec.payloadType, config: '' };
            answerMediaObject.fmtp.push(fmtp);
        }
        const parameters = sdpTransform.parseParams(fmtp.config);
        switch (mimeType) {
            case 'audio/opus':
                {
                    const spropStereo = codec.parameters['sprop-stereo'];
                    if (spropStereo !== undefined)
                        parameters.stereo = spropStereo ? 1 : 0;
                    break;
                }
        }
        // Write the codec fmtp.config back.
        fmtp.config = '';
        for (const key of Object.keys(parameters)) {
            if (fmtp.config)
                fmtp.config += ';';
            fmtp.config += `${key}=${parameters[key]}`;
        }
    }
}
exports.applyCodecParameters = applyCodecParameters;

},{"sdp-transform":175}],166:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addLegacySimulcast = exports.getRtpEncodings = void 0;
function getRtpEncodings({ offerMediaObject, track }) {
    // First media SSRC (or the only one).
    let firstSsrc;
    const ssrcs = new Set();
    for (const line of offerMediaObject.ssrcs || []) {
        if (line.attribute !== 'msid')
            continue;
        const trackId = line.value.split(' ')[1];
        if (trackId === track.id) {
            const ssrc = line.id;
            ssrcs.add(ssrc);
            if (!firstSsrc)
                firstSsrc = ssrc;
        }
    }
    if (ssrcs.size === 0)
        throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);
    const ssrcToRtxSsrc = new Map();
    // First assume RTX is used.
    for (const line of offerMediaObject.ssrcGroups || []) {
        if (line.semantics !== 'FID')
            continue;
        let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
        ssrc = Number(ssrc);
        rtxSsrc = Number(rtxSsrc);
        if (ssrcs.has(ssrc)) {
            // Remove both the SSRC and RTX SSRC from the set so later we know that they
            // are already handled.
            ssrcs.delete(ssrc);
            ssrcs.delete(rtxSsrc);
            // Add to the map.
            ssrcToRtxSsrc.set(ssrc, rtxSsrc);
        }
    }
    // If the set of SSRCs is not empty it means that RTX is not being used, so take
    // media SSRCs from there.
    for (const ssrc of ssrcs) {
        // Add to the map.
        ssrcToRtxSsrc.set(ssrc, null);
    }
    const encodings = [];
    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
        const encoding = { ssrc };
        if (rtxSsrc)
            encoding.rtx = { ssrc: rtxSsrc };
        encodings.push(encoding);
    }
    return encodings;
}
exports.getRtpEncodings = getRtpEncodings;
/**
 * Adds multi-ssrc based simulcast into the given SDP media section offer.
 */
function addLegacySimulcast({ offerMediaObject, track, numStreams }) {
    if (numStreams <= 1)
        throw new TypeError('numStreams must be greater than 1');
    let firstSsrc;
    let firstRtxSsrc;
    let streamId;
    // Get the SSRC.
    const ssrcMsidLine = (offerMediaObject.ssrcs || [])
        .find((line) => {
        if (line.attribute !== 'msid')
            return false;
        const trackId = line.value.split(' ')[1];
        if (trackId === track.id) {
            firstSsrc = line.id;
            streamId = line.value.split(' ')[0];
            return true;
        }
        else {
            return false;
        }
    });
    if (!ssrcMsidLine)
        throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);
    // Get the SSRC for RTX.
    (offerMediaObject.ssrcGroups || [])
        .some((line) => {
        if (line.semantics !== 'FID')
            return false;
        const ssrcs = line.ssrcs.split(/\s+/);
        if (Number(ssrcs[0]) === firstSsrc) {
            firstRtxSsrc = Number(ssrcs[1]);
            return true;
        }
        else {
            return false;
        }
    });
    const ssrcCnameLine = offerMediaObject.ssrcs
        .find((line) => (line.attribute === 'cname' && line.id === firstSsrc));
    if (!ssrcCnameLine)
        throw new Error(`a=ssrc line with cname information not found [track.id:${track.id}]`);
    const cname = ssrcCnameLine.value;
    const ssrcs = [];
    const rtxSsrcs = [];
    for (let i = 0; i < numStreams; ++i) {
        ssrcs.push(firstSsrc + i);
        if (firstRtxSsrc)
            rtxSsrcs.push(firstRtxSsrc + i);
    }
    offerMediaObject.ssrcGroups = offerMediaObject.ssrcGroups || [];
    offerMediaObject.ssrcs = offerMediaObject.ssrcs || [];
    offerMediaObject.ssrcGroups.push({
        semantics: 'SIM',
        ssrcs: ssrcs.join(' ')
    });
    for (let i = 0; i < ssrcs.length; ++i) {
        const ssrc = ssrcs[i];
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: 'cname',
            value: cname
        });
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: 'msid',
            value: `${streamId} ${track.id}`
        });
    }
    for (let i = 0; i < rtxSsrcs.length; ++i) {
        const ssrc = ssrcs[i];
        const rtxSsrc = rtxSsrcs[i];
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: 'cname',
            value: cname
        });
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: 'msid',
            value: `${streamId} ${track.id}`
        });
        offerMediaObject.ssrcGroups.push({
            semantics: 'FID',
            ssrcs: `${ssrc} ${rtxSsrc}`
        });
    }
}
exports.addLegacySimulcast = addLegacySimulcast;

},{}],167:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addLegacySimulcast = exports.getRtpEncodings = void 0;
function getRtpEncodings({ offerMediaObject }) {
    const ssrcs = new Set();
    for (const line of offerMediaObject.ssrcs || []) {
        const ssrc = line.id;
        ssrcs.add(ssrc);
    }
    if (ssrcs.size === 0)
        throw new Error('no a=ssrc lines found');
    const ssrcToRtxSsrc = new Map();
    // First assume RTX is used.
    for (const line of offerMediaObject.ssrcGroups || []) {
        if (line.semantics !== 'FID')
            continue;
        let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
        ssrc = Number(ssrc);
        rtxSsrc = Number(rtxSsrc);
        if (ssrcs.has(ssrc)) {
            // Remove both the SSRC and RTX SSRC from the set so later we know that they
            // are already handled.
            ssrcs.delete(ssrc);
            ssrcs.delete(rtxSsrc);
            // Add to the map.
            ssrcToRtxSsrc.set(ssrc, rtxSsrc);
        }
    }
    // If the set of SSRCs is not empty it means that RTX is not being used, so take
    // media SSRCs from there.
    for (const ssrc of ssrcs) {
        // Add to the map.
        ssrcToRtxSsrc.set(ssrc, null);
    }
    const encodings = [];
    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
        const encoding = { ssrc };
        if (rtxSsrc)
            encoding.rtx = { ssrc: rtxSsrc };
        encodings.push(encoding);
    }
    return encodings;
}
exports.getRtpEncodings = getRtpEncodings;
/**
 * Adds multi-ssrc based simulcast into the given SDP media section offer.
 */
function addLegacySimulcast({ offerMediaObject, numStreams }) {
    if (numStreams <= 1)
        throw new TypeError('numStreams must be greater than 1');
    // Get the SSRC.
    const ssrcMsidLine = (offerMediaObject.ssrcs || [])
        .find((line) => line.attribute === 'msid');
    if (!ssrcMsidLine)
        throw new Error('a=ssrc line with msid information not found');
    const [streamId, trackId] = ssrcMsidLine.value.split(' ');
    const firstSsrc = ssrcMsidLine.id;
    let firstRtxSsrc;
    // Get the SSRC for RTX.
    (offerMediaObject.ssrcGroups || [])
        .some((line) => {
        if (line.semantics !== 'FID')
            return false;
        const ssrcs = line.ssrcs.split(/\s+/);
        if (Number(ssrcs[0]) === firstSsrc) {
            firstRtxSsrc = Number(ssrcs[1]);
            return true;
        }
        else {
            return false;
        }
    });
    const ssrcCnameLine = offerMediaObject.ssrcs
        .find((line) => line.attribute === 'cname');
    if (!ssrcCnameLine)
        throw new Error('a=ssrc line with cname information not found');
    const cname = ssrcCnameLine.value;
    const ssrcs = [];
    const rtxSsrcs = [];
    for (let i = 0; i < numStreams; ++i) {
        ssrcs.push(firstSsrc + i);
        if (firstRtxSsrc)
            rtxSsrcs.push(firstRtxSsrc + i);
    }
    offerMediaObject.ssrcGroups = [];
    offerMediaObject.ssrcs = [];
    offerMediaObject.ssrcGroups.push({
        semantics: 'SIM',
        ssrcs: ssrcs.join(' ')
    });
    for (let i = 0; i < ssrcs.length; ++i) {
        const ssrc = ssrcs[i];
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: 'cname',
            value: cname
        });
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: 'msid',
            value: `${streamId} ${trackId}`
        });
    }
    for (let i = 0; i < rtxSsrcs.length; ++i) {
        const ssrc = ssrcs[i];
        const rtxSsrc = rtxSsrcs[i];
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: 'cname',
            value: cname
        });
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: 'msid',
            value: `${streamId} ${trackId}`
        });
        offerMediaObject.ssrcGroups.push({
            semantics: 'FID',
            ssrcs: `${ssrc} ${rtxSsrc}`
        });
    }
}
exports.addLegacySimulcast = addLegacySimulcast;

},{}],168:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.debug = exports.parseScalabilityMode = exports.detectDevice = exports.Device = exports.version = exports.types = void 0;
const debug_1 = __importDefault(require("debug"));
exports.debug = debug_1.default;
const Device_1 = require("./Device");
Object.defineProperty(exports, "Device", { enumerable: true, get: function () { return Device_1.Device; } });
Object.defineProperty(exports, "detectDevice", { enumerable: true, get: function () { return Device_1.detectDevice; } });
const types = __importStar(require("./types"));
exports.types = types;
/**
 * Expose mediasoup-client version.
 */
exports.version = '3.6.47';
/**
 * Expose parseScalabilityMode() function.
 */
var scalabilityModes_1 = require("./scalabilityModes");
Object.defineProperty(exports, "parseScalabilityMode", { enumerable: true, get: function () { return scalabilityModes_1.parse; } });

},{"./Device":144,"./scalabilityModes":170,"./types":171,"debug":138}],169:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.canReceive = exports.canSend = exports.generateProbatorRtpParameters = exports.reduceCodecs = exports.getSendingRemoteRtpParameters = exports.getSendingRtpParameters = exports.getRecvRtpCapabilities = exports.getExtendedRtpCapabilities = exports.validateSctpStreamParameters = exports.validateSctpParameters = exports.validateNumSctpStreams = exports.validateSctpCapabilities = exports.validateRtcpParameters = exports.validateRtpEncodingParameters = exports.validateRtpHeaderExtensionParameters = exports.validateRtpCodecParameters = exports.validateRtpParameters = exports.validateRtpHeaderExtension = exports.validateRtcpFeedback = exports.validateRtpCodecCapability = exports.validateRtpCapabilities = void 0;
const h264 = __importStar(require("h264-profile-level-id"));
const utils = __importStar(require("./utils"));
const RTP_PROBATOR_MID = 'probator';
const RTP_PROBATOR_SSRC = 1234;
const RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;
/**
 * Validates RtpCapabilities. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCapabilities(caps) {
    if (typeof caps !== 'object')
        throw new TypeError('caps is not an object');
    // codecs is optional. If unset, fill with an empty array.
    if (caps.codecs && !Array.isArray(caps.codecs))
        throw new TypeError('caps.codecs is not an array');
    else if (!caps.codecs)
        caps.codecs = [];
    for (const codec of caps.codecs) {
        validateRtpCodecCapability(codec);
    }
    // headerExtensions is optional. If unset, fill with an empty array.
    if (caps.headerExtensions && !Array.isArray(caps.headerExtensions))
        throw new TypeError('caps.headerExtensions is not an array');
    else if (!caps.headerExtensions)
        caps.headerExtensions = [];
    for (const ext of caps.headerExtensions) {
        validateRtpHeaderExtension(ext);
    }
}
exports.validateRtpCapabilities = validateRtpCapabilities;
/**
 * Validates RtpCodecCapability. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCodecCapability(codec) {
    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
    if (typeof codec !== 'object')
        throw new TypeError('codec is not an object');
    // mimeType is mandatory.
    if (!codec.mimeType || typeof codec.mimeType !== 'string')
        throw new TypeError('missing codec.mimeType');
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch)
        throw new TypeError('invalid codec.mimeType');
    // Just override kind with media component of mimeType.
    codec.kind = mimeTypeMatch[1].toLowerCase();
    // preferredPayloadType is optional.
    if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== 'number')
        throw new TypeError('invalid codec.preferredPayloadType');
    // clockRate is mandatory.
    if (typeof codec.clockRate !== 'number')
        throw new TypeError('missing codec.clockRate');
    // channels is optional. If unset, set it to 1 (just if audio).
    if (codec.kind === 'audio') {
        if (typeof codec.channels !== 'number')
            codec.channels = 1;
    }
    else {
        delete codec.channels;
    }
    // parameters is optional. If unset, set it to an empty object.
    if (!codec.parameters || typeof codec.parameters !== 'object')
        codec.parameters = {};
    for (const key of Object.keys(codec.parameters)) {
        let value = codec.parameters[key];
        if (value === undefined) {
            codec.parameters[key] = '';
            value = '';
        }
        if (typeof value !== 'string' && typeof value !== 'number') {
            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
        }
        // Specific parameters validation.
        if (key === 'apt') {
            if (typeof value !== 'number')
                throw new TypeError('invalid codec apt parameter');
        }
    }
    // rtcpFeedback is optional. If unset, set it to an empty array.
    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback))
        codec.rtcpFeedback = [];
    for (const fb of codec.rtcpFeedback) {
        validateRtcpFeedback(fb);
    }
}
exports.validateRtpCodecCapability = validateRtpCodecCapability;
/**
 * Validates RtcpFeedback. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtcpFeedback(fb) {
    if (typeof fb !== 'object')
        throw new TypeError('fb is not an object');
    // type is mandatory.
    if (!fb.type || typeof fb.type !== 'string')
        throw new TypeError('missing fb.type');
    // parameter is optional. If unset set it to an empty string.
    if (!fb.parameter || typeof fb.parameter !== 'string')
        fb.parameter = '';
}
exports.validateRtcpFeedback = validateRtcpFeedback;
/**
 * Validates RtpHeaderExtension. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpHeaderExtension(ext) {
    if (typeof ext !== 'object')
        throw new TypeError('ext is not an object');
    // kind is mandatory.
    if (ext.kind !== 'audio' && ext.kind !== 'video')
        throw new TypeError('invalid ext.kind');
    // uri is mandatory.
    if (!ext.uri || typeof ext.uri !== 'string')
        throw new TypeError('missing ext.uri');
    // preferredId is mandatory.
    if (typeof ext.preferredId !== 'number')
        throw new TypeError('missing ext.preferredId');
    // preferredEncrypt is optional. If unset set it to false.
    if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean')
        throw new TypeError('invalid ext.preferredEncrypt');
    else if (!ext.preferredEncrypt)
        ext.preferredEncrypt = false;
    // direction is optional. If unset set it to sendrecv.
    if (ext.direction && typeof ext.direction !== 'string')
        throw new TypeError('invalid ext.direction');
    else if (!ext.direction)
        ext.direction = 'sendrecv';
}
exports.validateRtpHeaderExtension = validateRtpHeaderExtension;
/**
 * Validates RtpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpParameters(params) {
    if (typeof params !== 'object')
        throw new TypeError('params is not an object');
    // mid is optional.
    if (params.mid && typeof params.mid !== 'string')
        throw new TypeError('params.mid is not a string');
    // codecs is mandatory.
    if (!Array.isArray(params.codecs))
        throw new TypeError('missing params.codecs');
    for (const codec of params.codecs) {
        validateRtpCodecParameters(codec);
    }
    // headerExtensions is optional. If unset, fill with an empty array.
    if (params.headerExtensions && !Array.isArray(params.headerExtensions))
        throw new TypeError('params.headerExtensions is not an array');
    else if (!params.headerExtensions)
        params.headerExtensions = [];
    for (const ext of params.headerExtensions) {
        validateRtpHeaderExtensionParameters(ext);
    }
    // encodings is optional. If unset, fill with an empty array.
    if (params.encodings && !Array.isArray(params.encodings))
        throw new TypeError('params.encodings is not an array');
    else if (!params.encodings)
        params.encodings = [];
    for (const encoding of params.encodings) {
        validateRtpEncodingParameters(encoding);
    }
    // rtcp is optional. If unset, fill with an empty object.
    if (params.rtcp && typeof params.rtcp !== 'object')
        throw new TypeError('params.rtcp is not an object');
    else if (!params.rtcp)
        params.rtcp = {};
    validateRtcpParameters(params.rtcp);
}
exports.validateRtpParameters = validateRtpParameters;
/**
 * Validates RtpCodecParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpCodecParameters(codec) {
    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
    if (typeof codec !== 'object')
        throw new TypeError('codec is not an object');
    // mimeType is mandatory.
    if (!codec.mimeType || typeof codec.mimeType !== 'string')
        throw new TypeError('missing codec.mimeType');
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch)
        throw new TypeError('invalid codec.mimeType');
    // payloadType is mandatory.
    if (typeof codec.payloadType !== 'number')
        throw new TypeError('missing codec.payloadType');
    // clockRate is mandatory.
    if (typeof codec.clockRate !== 'number')
        throw new TypeError('missing codec.clockRate');
    const kind = mimeTypeMatch[1].toLowerCase();
    // channels is optional. If unset, set it to 1 (just if audio).
    if (kind === 'audio') {
        if (typeof codec.channels !== 'number')
            codec.channels = 1;
    }
    else {
        delete codec.channels;
    }
    // parameters is optional. If unset, set it to an empty object.
    if (!codec.parameters || typeof codec.parameters !== 'object')
        codec.parameters = {};
    for (const key of Object.keys(codec.parameters)) {
        let value = codec.parameters[key];
        if (value === undefined) {
            codec.parameters[key] = '';
            value = '';
        }
        if (typeof value !== 'string' && typeof value !== 'number') {
            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
        }
        // Specific parameters validation.
        if (key === 'apt') {
            if (typeof value !== 'number')
                throw new TypeError('invalid codec apt parameter');
        }
    }
    // rtcpFeedback is optional. If unset, set it to an empty array.
    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback))
        codec.rtcpFeedback = [];
    for (const fb of codec.rtcpFeedback) {
        validateRtcpFeedback(fb);
    }
}
exports.validateRtpCodecParameters = validateRtpCodecParameters;
/**
 * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpHeaderExtensionParameters(ext) {
    if (typeof ext !== 'object')
        throw new TypeError('ext is not an object');
    // uri is mandatory.
    if (!ext.uri || typeof ext.uri !== 'string')
        throw new TypeError('missing ext.uri');
    // id is mandatory.
    if (typeof ext.id !== 'number')
        throw new TypeError('missing ext.id');
    // encrypt is optional. If unset set it to false.
    if (ext.encrypt && typeof ext.encrypt !== 'boolean')
        throw new TypeError('invalid ext.encrypt');
    else if (!ext.encrypt)
        ext.encrypt = false;
    // parameters is optional. If unset, set it to an empty object.
    if (!ext.parameters || typeof ext.parameters !== 'object')
        ext.parameters = {};
    for (const key of Object.keys(ext.parameters)) {
        let value = ext.parameters[key];
        if (value === undefined) {
            ext.parameters[key] = '';
            value = '';
        }
        if (typeof value !== 'string' && typeof value !== 'number')
            throw new TypeError('invalid header extension parameter');
    }
}
exports.validateRtpHeaderExtensionParameters = validateRtpHeaderExtensionParameters;
/**
 * Validates RtpEncodingParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpEncodingParameters(encoding) {
    if (typeof encoding !== 'object')
        throw new TypeError('encoding is not an object');
    // ssrc is optional.
    if (encoding.ssrc && typeof encoding.ssrc !== 'number')
        throw new TypeError('invalid encoding.ssrc');
    // rid is optional.
    if (encoding.rid && typeof encoding.rid !== 'string')
        throw new TypeError('invalid encoding.rid');
    // rtx is optional.
    if (encoding.rtx && typeof encoding.rtx !== 'object') {
        throw new TypeError('invalid encoding.rtx');
    }
    else if (encoding.rtx) {
        // RTX ssrc is mandatory if rtx is present.
        if (typeof encoding.rtx.ssrc !== 'number')
            throw new TypeError('missing encoding.rtx.ssrc');
    }
    // dtx is optional. If unset set it to false.
    if (!encoding.dtx || typeof encoding.dtx !== 'boolean')
        encoding.dtx = false;
    // scalabilityMode is optional.
    if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== 'string')
        throw new TypeError('invalid encoding.scalabilityMode');
}
exports.validateRtpEncodingParameters = validateRtpEncodingParameters;
/**
 * Validates RtcpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtcpParameters(rtcp) {
    if (typeof rtcp !== 'object')
        throw new TypeError('rtcp is not an object');
    // cname is optional.
    if (rtcp.cname && typeof rtcp.cname !== 'string')
        throw new TypeError('invalid rtcp.cname');
    // reducedSize is optional. If unset set it to true.
    if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean')
        rtcp.reducedSize = true;
}
exports.validateRtcpParameters = validateRtcpParameters;
/**
 * Validates SctpCapabilities. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateSctpCapabilities(caps) {
    if (typeof caps !== 'object')
        throw new TypeError('caps is not an object');
    // numStreams is mandatory.
    if (!caps.numStreams || typeof caps.numStreams !== 'object')
        throw new TypeError('missing caps.numStreams');
    validateNumSctpStreams(caps.numStreams);
}
exports.validateSctpCapabilities = validateSctpCapabilities;
/**
 * Validates NumSctpStreams. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateNumSctpStreams(numStreams) {
    if (typeof numStreams !== 'object')
        throw new TypeError('numStreams is not an object');
    // OS is mandatory.
    if (typeof numStreams.OS !== 'number')
        throw new TypeError('missing numStreams.OS');
    // MIS is mandatory.
    if (typeof numStreams.MIS !== 'number')
        throw new TypeError('missing numStreams.MIS');
}
exports.validateNumSctpStreams = validateNumSctpStreams;
/**
 * Validates SctpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateSctpParameters(params) {
    if (typeof params !== 'object')
        throw new TypeError('params is not an object');
    // port is mandatory.
    if (typeof params.port !== 'number')
        throw new TypeError('missing params.port');
    // OS is mandatory.
    if (typeof params.OS !== 'number')
        throw new TypeError('missing params.OS');
    // MIS is mandatory.
    if (typeof params.MIS !== 'number')
        throw new TypeError('missing params.MIS');
    // maxMessageSize is mandatory.
    if (typeof params.maxMessageSize !== 'number')
        throw new TypeError('missing params.maxMessageSize');
}
exports.validateSctpParameters = validateSctpParameters;
/**
 * Validates SctpStreamParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateSctpStreamParameters(params) {
    if (typeof params !== 'object')
        throw new TypeError('params is not an object');
    // streamId is mandatory.
    if (typeof params.streamId !== 'number')
        throw new TypeError('missing params.streamId');
    // ordered is optional.
    let orderedGiven = false;
    if (typeof params.ordered === 'boolean')
        orderedGiven = true;
    else
        params.ordered = true;
    // maxPacketLifeTime is optional.
    if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number')
        throw new TypeError('invalid params.maxPacketLifeTime');
    // maxRetransmits is optional.
    if (params.maxRetransmits && typeof params.maxRetransmits !== 'number')
        throw new TypeError('invalid params.maxRetransmits');
    if (params.maxPacketLifeTime && params.maxRetransmits)
        throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');
    if (orderedGiven &&
        params.ordered &&
        (params.maxPacketLifeTime || params.maxRetransmits)) {
        throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');
    }
    else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {
        params.ordered = false;
    }
    // label is optional.
    if (params.label && typeof params.label !== 'string')
        throw new TypeError('invalid params.label');
    // protocol is optional.
    if (params.protocol && typeof params.protocol !== 'string')
        throw new TypeError('invalid params.protocol');
}
exports.validateSctpStreamParameters = validateSctpStreamParameters;
/**
 * Generate extended RTP capabilities for sending and receiving.
 */
function getExtendedRtpCapabilities(localCaps, remoteCaps) {
    const extendedRtpCapabilities = {
        codecs: [],
        headerExtensions: []
    };
    // Match media codecs and keep the order preferred by remoteCaps.
    for (const remoteCodec of remoteCaps.codecs || []) {
        if (isRtxCodec(remoteCodec))
            continue;
        const matchingLocalCodec = (localCaps.codecs || [])
            .find((localCodec) => (matchCodecs(localCodec, remoteCodec, { strict: true, modify: true })));
        if (!matchingLocalCodec)
            continue;
        const extendedCodec = {
            mimeType: matchingLocalCodec.mimeType,
            kind: matchingLocalCodec.kind,
            clockRate: matchingLocalCodec.clockRate,
            channels: matchingLocalCodec.channels,
            localPayloadType: matchingLocalCodec.preferredPayloadType,
            localRtxPayloadType: undefined,
            remotePayloadType: remoteCodec.preferredPayloadType,
            remoteRtxPayloadType: undefined,
            localParameters: matchingLocalCodec.parameters,
            remoteParameters: remoteCodec.parameters,
            rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)
        };
        extendedRtpCapabilities.codecs.push(extendedCodec);
    }
    // Match RTX codecs.
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
        const matchingLocalRtxCodec = localCaps.codecs
            .find((localCodec) => (isRtxCodec(localCodec) &&
            localCodec.parameters.apt === extendedCodec.localPayloadType));
        const matchingRemoteRtxCodec = remoteCaps.codecs
            .find((remoteCodec) => (isRtxCodec(remoteCodec) &&
            remoteCodec.parameters.apt === extendedCodec.remotePayloadType));
        if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
            extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;
            extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;
        }
    }
    // Match header extensions.
    for (const remoteExt of remoteCaps.headerExtensions) {
        const matchingLocalExt = localCaps.headerExtensions
            .find((localExt) => (matchHeaderExtensions(localExt, remoteExt)));
        if (!matchingLocalExt)
            continue;
        const extendedExt = {
            kind: remoteExt.kind,
            uri: remoteExt.uri,
            sendId: matchingLocalExt.preferredId,
            recvId: remoteExt.preferredId,
            encrypt: matchingLocalExt.preferredEncrypt,
            direction: 'sendrecv'
        };
        switch (remoteExt.direction) {
            case 'sendrecv':
                extendedExt.direction = 'sendrecv';
                break;
            case 'recvonly':
                extendedExt.direction = 'sendonly';
                break;
            case 'sendonly':
                extendedExt.direction = 'recvonly';
                break;
            case 'inactive':
                extendedExt.direction = 'inactive';
                break;
        }
        extendedRtpCapabilities.headerExtensions.push(extendedExt);
    }
    return extendedRtpCapabilities;
}
exports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
/**
 * Generate RTP capabilities for receiving media based on the given extended
 * RTP capabilities.
 */
function getRecvRtpCapabilities(extendedRtpCapabilities) {
    const rtpCapabilities = {
        codecs: [],
        headerExtensions: []
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
        const codec = {
            mimeType: extendedCodec.mimeType,
            kind: extendedCodec.kind,
            preferredPayloadType: extendedCodec.remotePayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.localParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback
        };
        rtpCapabilities.codecs.push(codec);
        // Add RTX codec.
        if (!extendedCodec.remoteRtxPayloadType)
            continue;
        const rtxCodec = {
            mimeType: `${extendedCodec.kind}/rtx`,
            kind: extendedCodec.kind,
            preferredPayloadType: extendedCodec.remoteRtxPayloadType,
            clockRate: extendedCodec.clockRate,
            parameters: {
                apt: extendedCodec.remotePayloadType
            },
            rtcpFeedback: []
        };
        rtpCapabilities.codecs.push(rtxCodec);
        // TODO: In the future, we need to add FEC, CN, etc, codecs.
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
        // Ignore RTP extensions not valid for receiving.
        if (extendedExtension.direction !== 'sendrecv' &&
            extendedExtension.direction !== 'recvonly') {
            continue;
        }
        const ext = {
            kind: extendedExtension.kind,
            uri: extendedExtension.uri,
            preferredId: extendedExtension.recvId,
            preferredEncrypt: extendedExtension.encrypt,
            direction: extendedExtension.direction
        };
        rtpCapabilities.headerExtensions.push(ext);
    }
    return rtpCapabilities;
}
exports.getRecvRtpCapabilities = getRecvRtpCapabilities;
/**
 * Generate RTP parameters of the given kind for sending media.
 * NOTE: mid, encodings and rtcp fields are left empty.
 */
function getSendingRtpParameters(kind, extendedRtpCapabilities) {
    const rtpParameters = {
        mid: undefined,
        codecs: [],
        headerExtensions: [],
        encodings: [],
        rtcp: {}
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
        if (extendedCodec.kind !== kind)
            continue;
        const codec = {
            mimeType: extendedCodec.mimeType,
            payloadType: extendedCodec.localPayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.localParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback
        };
        rtpParameters.codecs.push(codec);
        // Add RTX codec.
        if (extendedCodec.localRtxPayloadType) {
            const rtxCodec = {
                mimeType: `${extendedCodec.kind}/rtx`,
                payloadType: extendedCodec.localRtxPayloadType,
                clockRate: extendedCodec.clockRate,
                parameters: {
                    apt: extendedCodec.localPayloadType
                },
                rtcpFeedback: []
            };
            rtpParameters.codecs.push(rtxCodec);
        }
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
        // Ignore RTP extensions of a different kind and those not valid for sending.
        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||
            (extendedExtension.direction !== 'sendrecv' &&
                extendedExtension.direction !== 'sendonly')) {
            continue;
        }
        const ext = {
            uri: extendedExtension.uri,
            id: extendedExtension.sendId,
            encrypt: extendedExtension.encrypt,
            parameters: {}
        };
        rtpParameters.headerExtensions.push(ext);
    }
    return rtpParameters;
}
exports.getSendingRtpParameters = getSendingRtpParameters;
/**
 * Generate RTP parameters of the given kind suitable for the remote SDP answer.
 */
function getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {
    const rtpParameters = {
        mid: undefined,
        codecs: [],
        headerExtensions: [],
        encodings: [],
        rtcp: {}
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
        if (extendedCodec.kind !== kind)
            continue;
        const codec = {
            mimeType: extendedCodec.mimeType,
            payloadType: extendedCodec.localPayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.remoteParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback
        };
        rtpParameters.codecs.push(codec);
        // Add RTX codec.
        if (extendedCodec.localRtxPayloadType) {
            const rtxCodec = {
                mimeType: `${extendedCodec.kind}/rtx`,
                payloadType: extendedCodec.localRtxPayloadType,
                clockRate: extendedCodec.clockRate,
                parameters: {
                    apt: extendedCodec.localPayloadType
                },
                rtcpFeedback: []
            };
            rtpParameters.codecs.push(rtxCodec);
        }
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
        // Ignore RTP extensions of a different kind and those not valid for sending.
        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||
            (extendedExtension.direction !== 'sendrecv' &&
                extendedExtension.direction !== 'sendonly')) {
            continue;
        }
        const ext = {
            uri: extendedExtension.uri,
            id: extendedExtension.sendId,
            encrypt: extendedExtension.encrypt,
            parameters: {}
        };
        rtpParameters.headerExtensions.push(ext);
    }
    // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.
    if (rtpParameters.headerExtensions.some((ext) => (ext.uri === 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01'))) {
        for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback || [])
                .filter((fb) => fb.type !== 'goog-remb');
        }
    }
    else if (rtpParameters.headerExtensions.some((ext) => (ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time'))) {
        for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback || [])
                .filter((fb) => fb.type !== 'transport-cc');
        }
    }
    else {
        for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback || [])
                .filter((fb) => (fb.type !== 'transport-cc' &&
                fb.type !== 'goog-remb'));
        }
    }
    return rtpParameters;
}
exports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;
/**
 * Reduce given codecs by returning an array of codecs "compatible" with the
 * given capability codec. If no capability codec is given, take the first
 * one(s).
 *
 * Given codecs must be generated by ortc.getSendingRtpParameters() or
 * ortc.getSendingRemoteRtpParameters().
 *
 * The returned array of codecs also include a RTX codec if available.
 */
function reduceCodecs(codecs, capCodec) {
    const filteredCodecs = [];
    // If no capability codec is given, take the first one (and RTX).
    if (!capCodec) {
        filteredCodecs.push(codecs[0]);
        if (isRtxCodec(codecs[1]))
            filteredCodecs.push(codecs[1]);
    }
    // Otherwise look for a compatible set of codecs.
    else {
        for (let idx = 0; idx < codecs.length; ++idx) {
            if (matchCodecs(codecs[idx], capCodec)) {
                filteredCodecs.push(codecs[idx]);
                if (isRtxCodec(codecs[idx + 1]))
                    filteredCodecs.push(codecs[idx + 1]);
                break;
            }
        }
        if (filteredCodecs.length === 0)
            throw new TypeError('no matching codec found');
    }
    return filteredCodecs;
}
exports.reduceCodecs = reduceCodecs;
/**
 * Create RTP parameters for a Consumer for the RTP probator.
 */
function generateProbatorRtpParameters(videoRtpParameters) {
    // Clone given reference video RTP parameters.
    videoRtpParameters = utils.clone(videoRtpParameters, {});
    // This may throw.
    validateRtpParameters(videoRtpParameters);
    const rtpParameters = {
        mid: RTP_PROBATOR_MID,
        codecs: [],
        headerExtensions: [],
        encodings: [{ ssrc: RTP_PROBATOR_SSRC }],
        rtcp: { cname: 'probator' }
    };
    rtpParameters.codecs.push(videoRtpParameters.codecs[0]);
    rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;
    rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;
    return rtpParameters;
}
exports.generateProbatorRtpParameters = generateProbatorRtpParameters;
/**
 * Whether media can be sent based on the given RTP capabilities.
 */
function canSend(kind, extendedRtpCapabilities) {
    return extendedRtpCapabilities.codecs.
        some((codec) => codec.kind === kind);
}
exports.canSend = canSend;
/**
 * Whether the given RTP parameters can be received with the given RTP
 * capabilities.
 */
function canReceive(rtpParameters, extendedRtpCapabilities) {
    // This may throw.
    validateRtpParameters(rtpParameters);
    if (rtpParameters.codecs.length === 0)
        return false;
    const firstMediaCodec = rtpParameters.codecs[0];
    return extendedRtpCapabilities.codecs
        .some((codec) => codec.remotePayloadType === firstMediaCodec.payloadType);
}
exports.canReceive = canReceive;
function isRtxCodec(codec) {
    if (!codec)
        return false;
    return /.+\/rtx$/i.test(codec.mimeType);
}
function matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {
    const aMimeType = aCodec.mimeType.toLowerCase();
    const bMimeType = bCodec.mimeType.toLowerCase();
    if (aMimeType !== bMimeType)
        return false;
    if (aCodec.clockRate !== bCodec.clockRate)
        return false;
    if (aCodec.channels !== bCodec.channels)
        return false;
    // Per codec special checks.
    switch (aMimeType) {
        case 'video/h264':
            {
                // If strict matching check profile-level-id.
                if (strict) {
                    const aPacketizationMode = aCodec.parameters['packetization-mode'] || 0;
                    const bPacketizationMode = bCodec.parameters['packetization-mode'] || 0;
                    if (aPacketizationMode !== bPacketizationMode)
                        return false;
                    if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters))
                        return false;
                    let selectedProfileLevelId;
                    try {
                        selectedProfileLevelId =
                            h264.generateProfileLevelIdForAnswer(aCodec.parameters, bCodec.parameters);
                    }
                    catch (error) {
                        return false;
                    }
                    if (modify) {
                        if (selectedProfileLevelId) {
                            aCodec.parameters['profile-level-id'] = selectedProfileLevelId;
                            bCodec.parameters['profile-level-id'] = selectedProfileLevelId;
                        }
                        else {
                            delete aCodec.parameters['profile-level-id'];
                            delete bCodec.parameters['profile-level-id'];
                        }
                    }
                }
                break;
            }
        case 'video/vp9':
            {
                // If strict matching check profile-id.
                if (strict) {
                    const aProfileId = aCodec.parameters['profile-id'] || 0;
                    const bProfileId = bCodec.parameters['profile-id'] || 0;
                    if (aProfileId !== bProfileId)
                        return false;
                }
                break;
            }
    }
    return true;
}
function matchHeaderExtensions(aExt, bExt) {
    if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind)
        return false;
    if (aExt.uri !== bExt.uri)
        return false;
    return true;
}
function reduceRtcpFeedback(codecA, codecB) {
    const reducedRtcpFeedback = [];
    for (const aFb of codecA.rtcpFeedback || []) {
        const matchingBFb = (codecB.rtcpFeedback || [])
            .find((bFb) => (bFb.type === aFb.type &&
            (bFb.parameter === aFb.parameter || (!bFb.parameter && !aFb.parameter))));
        if (matchingBFb)
            reducedRtcpFeedback.push(matchingBFb);
    }
    return reducedRtcpFeedback;
}

},{"./utils":172,"h264-profile-level-id":140}],170:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const ScalabilityModeRegex = new RegExp('^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})');
function parse(scalabilityMode) {
    const match = ScalabilityModeRegex.exec(scalabilityMode || '');
    if (match) {
        return {
            spatialLayers: Number(match[1]),
            temporalLayers: Number(match[2])
        };
    }
    else {
        return {
            spatialLayers: 1,
            temporalLayers: 1
        };
    }
}
exports.parse = parse;

},{}],171:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Device"), exports);
__exportStar(require("./Transport"), exports);
__exportStar(require("./Producer"), exports);
__exportStar(require("./Consumer"), exports);
__exportStar(require("./DataProducer"), exports);
__exportStar(require("./DataConsumer"), exports);
__exportStar(require("./RtpParameters"), exports);
__exportStar(require("./SctpParameters"), exports);
__exportStar(require("./handlers/HandlerInterface"), exports);
__exportStar(require("./errors"), exports);

},{"./Consumer":141,"./DataConsumer":142,"./DataProducer":143,"./Device":144,"./Producer":147,"./RtpParameters":148,"./SctpParameters":149,"./Transport":150,"./errors":151,"./handlers/HandlerInterface":158}],172:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateRandomNumber = exports.clone = void 0;
/**
 * Clones the given data.
 */
function clone(data, defaultValue) {
    if (typeof data === 'undefined')
        return defaultValue;
    return JSON.parse(JSON.stringify(data));
}
exports.clone = clone;
/**
 * Generates a random positive integer.
 */
function generateRandomNumber() {
    return Math.round(Math.random() * 10000000);
}
exports.generateRandomNumber = generateRandomNumber;

},{}],173:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],174:[function(require,module,exports){
var grammar = module.exports = {
  v: [{
    name: 'version',
    reg: /^(\d*)$/
  }],
  o: [{
    // o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: 'origin',
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
    format: '%s %s %d %s IP%d %s'
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{ name: 'name' }],
  i: [{ name: 'description' }],
  u: [{ name: 'uri' }],
  e: [{ name: 'email' }],
  p: [{ name: 'phone' }],
  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly...
  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
  // k: [{}], // outdated thing ignored
  t: [{
    // t=0 0
    name: 'timing',
    reg: /^(\d*) (\d*)/,
    names: ['start', 'stop'],
    format: '%d %d'
  }],
  c: [{
    // c=IN IP4 10.47.197.26
    name: 'connection',
    reg: /^IN IP(\d) (\S*)/,
    names: ['version', 'ip'],
    format: 'IN IP%d %s'
  }],
  b: [{
    // b=AS:4000
    push: 'bandwidth',
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ['type', 'limit'],
    format: '%s:%s'
  }],
  m: [{
    // m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
    names: ['type', 'port', 'protocol', 'payloads'],
    format: '%s %d %s %s'
  }],
  a: [
    {
      // a=rtpmap:110 opus/48000/2
      push: 'rtp',
      reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ['payload', 'codec', 'rate', 'encoding'],
      format: function (o) {
        return (o.encoding)
          ? 'rtpmap:%d %s/%s/%s'
          : o.rate
            ? 'rtpmap:%d %s/%s'
            : 'rtpmap:%d %s';
      }
    },
    {
      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      // a=fmtp:111 minptime=10; useinbandfec=1
      push: 'fmtp',
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ['payload', 'config'],
      format: 'fmtp:%d %s'
    },
    {
      // a=control:streamid=0
      name: 'control',
      reg: /^control:(.*)/,
      format: 'control:%s'
    },
    {
      // a=rtcp:65179 IN IP4 193.84.77.194
      name: 'rtcp',
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ['port', 'netType', 'ipVer', 'address'],
      format: function (o) {
        return (o.address != null)
          ? 'rtcp:%d %s IP%d %s'
          : 'rtcp:%d';
      }
    },
    {
      // a=rtcp-fb:98 trr-int 100
      push: 'rtcpFbTrrInt',
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ['payload', 'value'],
      format: 'rtcp-fb:%s trr-int %d'
    },
    {
      // a=rtcp-fb:98 nack rpsi
      push: 'rtcpFb',
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ['payload', 'type', 'subtype'],
      format: function (o) {
        return (o.subtype != null)
          ? 'rtcp-fb:%s %s %s'
          : 'rtcp-fb:%s %s';
      }
    },
    {
      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      // a=extmap:1/recvonly URI-gps-string
      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
      push: 'ext',
      reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
      names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],
      format: function (o) {
        return (
          'extmap:%d' +
          (o.direction ? '/%s' : '%v') +
          (o['encrypt-uri'] ? ' %s' : '%v') +
          ' %s' +
          (o.config ? ' %s' : '')
        );
      }
    },
    {
      // a=extmap-allow-mixed
      name: 'extmapAllowMixed',
      reg: /^(extmap-allow-mixed)/
    },
    {
      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: 'crypto',
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ['id', 'suite', 'config', 'sessionConfig'],
      format: function (o) {
        return (o.sessionConfig != null)
          ? 'crypto:%d %s %s %s'
          : 'crypto:%d %s %s';
      }
    },
    {
      // a=setup:actpass
      name: 'setup',
      reg: /^setup:(\w*)/,
      format: 'setup:%s'
    },
    {
      // a=connection:new
      name: 'connectionType',
      reg: /^connection:(new|existing)/,
      format: 'connection:%s'
    },
    {
      // a=mid:1
      name: 'mid',
      reg: /^mid:([^\s]*)/,
      format: 'mid:%s'
    },
    {
      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
      name: 'msid',
      reg: /^msid:(.*)/,
      format: 'msid:%s'
    },
    {
      // a=ptime:20
      name: 'ptime',
      reg: /^ptime:(\d*(?:\.\d*)*)/,
      format: 'ptime:%d'
    },
    {
      // a=maxptime:60
      name: 'maxptime',
      reg: /^maxptime:(\d*(?:\.\d*)*)/,
      format: 'maxptime:%d'
    },
    {
      // a=sendrecv
      name: 'direction',
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    {
      // a=ice-lite
      name: 'icelite',
      reg: /^(ice-lite)/
    },
    {
      // a=ice-ufrag:F7gI
      name: 'iceUfrag',
      reg: /^ice-ufrag:(\S*)/,
      format: 'ice-ufrag:%s'
    },
    {
      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: 'icePwd',
      reg: /^ice-pwd:(\S*)/,
      format: 'ice-pwd:%s'
    },
    {
      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: 'fingerprint',
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ['type', 'hash'],
      format: 'fingerprint:%s %s'
    },
    {
      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
      push:'candidates',
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],
      format: function (o) {
        var str = 'candidate:%s %d %s %d %s %d typ %s';

        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';

        // NB: candidate has three optional chunks, so %void middles one if it's missing
        str += (o.tcptype != null) ? ' tcptype %s' : '%v';

        if (o.generation != null) {
          str += ' generation %d';
        }

        str += (o['network-id'] != null) ? ' network-id %d' : '%v';
        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';
        return str;
      }
    },
    {
      // a=end-of-candidates (keep after the candidates line for readability)
      name: 'endOfCandidates',
      reg: /^(end-of-candidates)/
    },
    {
      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: 'remoteCandidates',
      reg: /^remote-candidates:(.*)/,
      format: 'remote-candidates:%s'
    },
    {
      // a=ice-options:google-ice
      name: 'iceOptions',
      reg: /^ice-options:(\S*)/,
      format: 'ice-options:%s'
    },
    {
      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: 'ssrcs',
      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
      names: ['id', 'attribute', 'value'],
      format: function (o) {
        var str = 'ssrc:%d';
        if (o.attribute != null) {
          str += ' %s';
          if (o.value != null) {
            str += ':%s';
          }
        }
        return str;
      }
    },
    {
      // a=ssrc-group:FEC 1 2
      // a=ssrc-group:FEC-FR 3004364195 1080772241
      push: 'ssrcGroups',
      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
      names: ['semantics', 'ssrcs'],
      format: 'ssrc-group:%s %s'
    },
    {
      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: 'msidSemantic',
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ['semantic', 'token'],
      format: 'msid-semantic: %s %s' // space after ':' is not accidental
    },
    {
      // a=group:BUNDLE audio video
      push: 'groups',
      reg: /^group:(\w*) (.*)/,
      names: ['type', 'mids'],
      format: 'group:%s %s'
    },
    {
      // a=rtcp-mux
      name: 'rtcpMux',
      reg: /^(rtcp-mux)/
    },
    {
      // a=rtcp-rsize
      name: 'rtcpRsize',
      reg: /^(rtcp-rsize)/
    },
    {
      // a=sctpmap:5000 webrtc-datachannel 1024
      name: 'sctpmap',
      reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
      names: ['sctpmapNumber', 'app', 'maxMessageSize'],
      format: function (o) {
        return (o.maxMessageSize != null)
          ? 'sctpmap:%s %s %s'
          : 'sctpmap:%s %s';
      }
    },
    {
      // a=x-google-flag:conference
      name: 'xGoogleFlag',
      reg: /^x-google-flag:([^\s]*)/,
      format: 'x-google-flag:%s'
    },
    {
      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
      push: 'rids',
      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
      names: ['id', 'direction', 'params'],
      format: function (o) {
        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';
      }
    },
    {
      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
      // a=imageattr:* send [x=800,y=640] recv *
      // a=imageattr:100 recv [x=320,y=240]
      push: 'imageattrs',
      reg: new RegExp(
        // a=imageattr:97
        '^imageattr:(\\d+|\\*)' +
        // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
        '[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
        // recv [x=330,y=250]
        '(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'
      ),
      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],
      format: function (o) {
        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    {
      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
      // a=simulcast:recv 1;4,5 send 6;7
      name: 'simulcast',
      reg: new RegExp(
        // a=simulcast:
        '^simulcast:' +
        // send 1,2,3;~4,~5
        '(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
        // space + recv 6;~7,~8
        '(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
        // end
        '$'
      ),
      names: ['dir1', 'list1', 'dir2', 'list2'],
      format: function (o) {
        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    {
      // old simulcast draft 03 (implemented by Firefox)
      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
      // a=simulcast: recv pt=97;98 send pt=97
      // a=simulcast: send rid=5;6;7 paused=6,7
      name: 'simulcast_03',
      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
      names: ['value'],
      format: 'simulcast: %s'
    },
    {
      // a=framerate:25
      // a=framerate:29.97
      name: 'framerate',
      reg: /^framerate:(\d+(?:$|\.\d+))/,
      format: 'framerate:%s'
    },
    {
      // RFC4570
      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
      name: 'sourceFilter',
      reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],
      format: 'source-filter: %s %s %s %s %s'
    },
    {
      // a=bundle-only
      name: 'bundleOnly',
      reg: /^(bundle-only)/
    },
    {
      // a=label:1
      name: 'label',
      reg: /^label:(.+)/,
      format: 'label:%s'
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
      name: 'sctpPort',
      reg: /^sctp-port:(\d+)$/,
      format: 'sctp-port:%s'
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
      name: 'maxMessageSize',
      reg: /^max-message-size:(\d+)$/,
      format: 'max-message-size:%s'
    },
    {
      // RFC7273
      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
      push:'tsRefClocks',
      reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
      names: ['clksrc', 'clksrcExt'],
      format: function (o) {
        return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');
      }
    },
    {
      // RFC7273
      // a=mediaclk:direct=963214424
      name:'mediaClk',
      reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
      names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],
      format: function (o) {
        var str = 'mediaclk:';
        str += (o.id != null ? 'id=%s %s' : '%v%s');
        str += (o.mediaClockValue != null ? '=%s' : '');
        str += (o.rateNumerator != null ? ' rate=%s' : '');
        str += (o.rateDenominator != null ? '/%s' : '');
        return str;
      }
    },
    {
      // a=keywds:keywords
      name: 'keywords',
      reg: /^keywds:(.+)$/,
      format: 'keywds:%s'
    },
    {
      // a=content:main
      name: 'content',
      reg: /^content:(.+)/,
      format: 'content:%s'
    },
    // BFCP https://tools.ietf.org/html/rfc4583
    {
      // a=floorctrl:c-s
      name: 'bfcpFloorCtrl',
      reg: /^floorctrl:(c-only|s-only|c-s)/,
      format: 'floorctrl:%s'
    },
    {
      // a=confid:1
      name: 'bfcpConfId',
      reg: /^confid:(\d+)/,
      format: 'confid:%s'
    },
    {
      // a=userid:1
      name: 'bfcpUserId',
      reg: /^userid:(\d+)/,
      format: 'userid:%s'
    },
    {
      // a=floorid:1
      name: 'bfcpFloorId',
      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
      names: ['id', 'mStream'],
      format: 'floorid:%s mstrm:%s'
    },
    {
      // any a= that we don't understand is kept verbatim on media.invalid
      push: 'invalid',
      names: ['value']
    }
  ]
};

// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function (key) {
  var objs = grammar[key];
  objs.forEach(function (obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = '%s';
    }
  });
});

},{}],175:[function(require,module,exports){
var parser = require('./parser');
var writer = require('./writer');

exports.write = writer;
exports.parse = parser.parse;
exports.parseParams = parser.parseParams;
exports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().
exports.parsePayloads = parser.parsePayloads;
exports.parseRemoteCandidates = parser.parseRemoteCandidates;
exports.parseImageAttributes = parser.parseImageAttributes;
exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;

},{"./parser":176,"./writer":177}],176:[function(require,module,exports){
var toIntIfInt = function (v) {
  return String(Number(v)) === v ? Number(v) : v;
};

var attachProperties = function (match, location, names, rawName) {
  if (rawName && !names) {
    location[rawName] = toIntIfInt(match[1]);
  }
  else {
    for (var i = 0; i < names.length; i += 1) {
      if (match[i+1] != null) {
        location[names[i]] = toIntIfInt(match[i+1]);
      }
    }
  }
};

var parseReg = function (obj, location, content) {
  var needsBlank = obj.name && obj.names;
  if (obj.push && !location[obj.push]) {
    location[obj.push] = [];
  }
  else if (needsBlank && !location[obj.name]) {
    location[obj.name] = {};
  }
  var keyLocation = obj.push ?
    {} :  // blank object that will be pushed
    needsBlank ? location[obj.name] : location; // otherwise, named location or root

  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);

  if (obj.push) {
    location[obj.push].push(keyLocation);
  }
};

var grammar = require('./grammar');
var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);

exports.parse = function (sdp) {
  var session = {}
    , media = []
    , location = session; // points at where properties go under (one of the above)

  // parse lines we understand
  sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
    var type = l[0];
    var content = l.slice(2);
    if (type === 'm') {
      media.push({rtp: [], fmtp: []});
      location = media[media.length-1]; // point at latest media line
    }

    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
      var obj = grammar[type][j];
      if (obj.reg.test(content)) {
        return parseReg(obj, location, content);
      }
    }
  });

  session.media = media; // link it up
  return session;
};

var paramReducer = function (acc, expr) {
  var s = expr.split(/=(.+)/, 2);
  if (s.length === 2) {
    acc[s[0]] = toIntIfInt(s[1]);
  } else if (s.length === 1 && expr.length > 1) {
    acc[s[0]] = undefined;
  }
  return acc;
};

exports.parseParams = function (str) {
  return str.split(/;\s?/).reduce(paramReducer, {});
};

// For backward compatibility - alias will be removed in 3.0.0
exports.parseFmtpConfig = exports.parseParams;

exports.parsePayloads = function (str) {
  return str.toString().split(' ').map(Number);
};

exports.parseRemoteCandidates = function (str) {
  var candidates = [];
  var parts = str.split(' ').map(toIntIfInt);
  for (var i = 0; i < parts.length; i += 3) {
    candidates.push({
      component: parts[i],
      ip: parts[i + 1],
      port: parts[i + 2]
    });
  }
  return candidates;
};

exports.parseImageAttributes = function (str) {
  return str.split(' ').map(function (item) {
    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});
  });
};

exports.parseSimulcastStreamList = function (str) {
  return str.split(';').map(function (stream) {
    return stream.split(',').map(function (format) {
      var scid, paused = false;

      if (format[0] !== '~') {
        scid = toIntIfInt(format);
      } else {
        scid = toIntIfInt(format.substring(1, format.length));
        paused = true;
      }

      return {
        scid: scid,
        paused: paused
      };
    });
  });
};

},{"./grammar":174}],177:[function(require,module,exports){
var grammar = require('./grammar');

// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function (formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function (x) {
    if (i >= len) {
      return x; // missing argument
    }
    var arg = args[i];
    i += 1;
    switch (x) {
    case '%%':
      return '%';
    case '%s':
      return String(arg);
    case '%d':
      return Number(arg);
    case '%v':
      return '';
    }
  });
  // NB: we discard excess arguments - they are typically undefined from makeLine
};

var makeLine = function (type, obj, location) {
  var str = obj.format instanceof Function ?
    (obj.format(obj.push ? location : location[obj.name])) :
    obj.format;

  var args = [type + '=' + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      }
      else { // for mLine and push attributes
        args.push(location[obj.names[i]]);
      }
    }
  }
  else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
};

// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = [
  'v', 'o', 's', 'i',
  'u', 'e', 'p', 'c',
  'b', 't', 'r', 'z', 'a'
];
var defaultInnerOrder = ['i', 'c', 'b', 'a'];


module.exports = function (session, opts) {
  opts = opts || {};
  // ensure certain properties exist
  if (session.version == null) {
    session.version = 0; // 'v=0' must be there (only defined version atm)
  }
  if (session.name == null) {
    session.name = ' '; // 's= ' must be there if no meaningful name set
  }
  session.media.forEach(function (mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = '';
    }
  });

  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp = [];

  // loop through outerOrder for matching properties on session
  outerOrder.forEach(function (type) {
    grammar[type].forEach(function (obj) {
      if (obj.name in session && session[obj.name] != null) {
        sdp.push(makeLine(type, obj, session));
      }
      else if (obj.push in session && session[obj.push] != null) {
        session[obj.push].forEach(function (el) {
          sdp.push(makeLine(type, obj, el));
        });
      }
    });
  });

  // then for each media line, follow the innerOrder
  session.media.forEach(function (mLine) {
    sdp.push(makeLine('m', grammar.m[0], mLine));

    innerOrder.forEach(function (type) {
      grammar[type].forEach(function (obj) {
        if (obj.name in mLine && mLine[obj.name] != null) {
          sdp.push(makeLine(type, obj, mLine));
        }
        else if (obj.push in mLine && mLine[obj.push] != null) {
          mLine[obj.push].forEach(function (el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });

  return sdp.join('\r\n') + '\r\n';
};

},{"./grammar":174}],178:[function(require,module,exports){
arguments[4][120][0].apply(exports,arguments)
},{"./nil.js":180,"./parse.js":181,"./stringify.js":185,"./v1.js":186,"./v3.js":187,"./v4.js":189,"./v5.js":190,"./validate.js":191,"./version.js":192,"dup":120}],179:[function(require,module,exports){
arguments[4][121][0].apply(exports,arguments)
},{"dup":121}],180:[function(require,module,exports){
arguments[4][122][0].apply(exports,arguments)
},{"dup":122}],181:[function(require,module,exports){
arguments[4][123][0].apply(exports,arguments)
},{"./validate.js":191,"dup":123}],182:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124}],183:[function(require,module,exports){
arguments[4][125][0].apply(exports,arguments)
},{"dup":125}],184:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126}],185:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"./validate.js":191,"dup":127}],186:[function(require,module,exports){
arguments[4][128][0].apply(exports,arguments)
},{"./rng.js":183,"./stringify.js":185,"dup":128}],187:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"./md5.js":179,"./v35.js":188,"dup":129}],188:[function(require,module,exports){
arguments[4][130][0].apply(exports,arguments)
},{"./parse.js":181,"./stringify.js":185,"dup":130}],189:[function(require,module,exports){
arguments[4][131][0].apply(exports,arguments)
},{"./rng.js":183,"./stringify.js":185,"dup":131}],190:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"./sha1.js":184,"./v35.js":188,"dup":132}],191:[function(require,module,exports){
arguments[4][133][0].apply(exports,arguments)
},{"./regex.js":182,"dup":133}],192:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"./validate.js":191,"dup":134}]},{},[135]);
